#
# Possible values:
#  * class
#    Description of classes.
#    + name
#      a C++ class name.
#
#    + desc
#      a (Doxygen) comment describing the class.
#
#    + hide
#      if True, output within <<- and ->>.
#
#    + super
#      a possibly empty space separated list of superclass names.
#
#  * attributes:
#    + name
#      a C++ attribute name
#
#    + type
#      a C++ type name
#
#    + abstract
#      If True, don't output.
#
#    + mandatory
#      + True
#        *_get methods return a const ref.
#      + False
#        *_get methods return a const pointer.
#
#    + init=VALUE
#      If set, the value used to initialize the member.
#      This attribute will not have a argument in the constructors.
#
#    + owned
#      - True: Pointer members are "delete"'d.
#      - False: They are not.
#
#    + access composed by [ 'r', 'w, 'W' ]
#      - r: provide a *_get const accessor.
#      - w: provide a *_get accessor that returns a reference
#        for possible modifications.
#      - W: provide a *_set accessor.
#    + desc, a short description of the attribute
#    + hide, some code in the final tarball (no fixme)
#
# Defaults:
#  * class:
#    + desc: the name of the class
#
#  * attributes:
#    + mandatory: True
#    + access: rw
#    + owned: True
#

---

#<escapes<-
Escapable:
  hide: True
  inline:
    header prologue: '# include "ast/fwd.hh"'
  attributes:
    - escape_tag: { type: bool,  access: r, desc: '"escape_tag" flag', hide: true }
    - escape: { type: bool, init: 'true', access: rW, desc: '"escape" flag' }
#->>


#<type<-
Typable:
  desc: |2

      /** \class ast::Typable
       ** \brief Hold a type information.
       **
       ** A Typable node holds a type information (type::Type) about
       ** this node.  This can be:
       ** \li the type of the node itself, if it is a Exp or a Ty, or
       ** \li the type of of the declared object, in case of a Dec.
       */
 
  hide: True
  inline:
    header prologue: '# include "ast/fwd.hh"'
  attributes:
    - type:
        type: 'const type::Type*'
        mandatory: False
        init: '0'
        access: rW
        owned: False
        desc: Type of the node


TypeConstructor:
  desc: |2

      /** \class ast::TypeConstructor
       ** \brief Create a new type.
       */

  hide: True
  inline:
    header prologue: '# include "ast/fwd.hh"'
    inline prologue: '# include "type/types.hh"'
  attributes:
    - created_type:
        type: 'const type::Type*'
        mandatory: False
        init: '0'
        access: rW
        owned: True
        desc: Type created by this node
#->>


Ast:
  inline:
    header prologue: '# include "ast/fwd.hh"'
  attributes:
    - location:
        type: Location
        access: rW
        desc: Scanner position information


Dec:
#<no-type<-
  super: Ast
#->>
#<type<-
  super: Ast Typable
#->>
  attributes:
    - name:
        type: 'symbol::Symbol'
        access: rW
        desc: Name of the defined entity
        owned: False


FunctionDec:
#<no-type<-
  super: Dec
#->>
#<type<-
  super: Dec TypeConstructor
#->>
#<escapes<-
  inline:
    header inside: |2

        //<<-
        public:
          /// Return the list of the escapes.
          std::list<bool> escapes_get () const
          {
            //<<
            std::list<bool> res;
            VarDecs::Ds::const_iterator i;
            const VarDecs::Ds formals = formals_->decs_get ();
            for (i = formals.begin (); i != formals.end (); ++i)
              res.push_back ((*i)->escape_get ());
            return res;
            //>>
          }
        //->>
#->>

  attributes:
    - formals: { type: 'VarDecs*', desc: Formal arguments }
    - result:  { type: 'NameTy*', mandatory: False, desc: Result type}
    - body: { type: 'Exp*', access: rwW, mandatory: False, desc: Instructions }
    - sl_needed:
        hide: True
        type: bool
        init: 'body_ != 0'
        access: rW
        desc: '"need to escape static link" flag'
    - sl_escapes:
        hide: True
        type: bool
        init: 'body_ != 0'
        access: rW
        desc: '"escape static link" flag'


TypeDec:
#<no-type<-
  super: Dec
#->>
#<type<-
  super: Dec TypeConstructor
#->>
  attributes:
    - ty: { type: 'Ty*', desc: Type definition }


VarDec:
#<no-escapes<-
  super: Dec
#->>
#<escapes<-
  super: Dec Escapable
#->>
  attributes:
    - type_name:
        type: NameTy*
        mandatory: False
        desc: Optional type of the declared variable

    - init:
        type: Exp*
        mandatory: False
        desc: The initial value (expression) assigned to the variable


DecsList:
  super: Ast
  attributes:
    - decs:
        type: 'DecsList::decs_type'
        access: rw
        owned: True
        desc: Declarations
  inline:
    header inside: |2
        public:
          typedef std::list<Decs*> decs_type;

          /// Prepend \a d.
          void push_front (Decs* d);
          /// Append \a d.
          void push_back (Decs* d);

          /// Splice the content of \a ds in front of this list.
          void splice_front (DecsList& ds);
          /// Splice the content of \a ds at the back this list.
          void splice_back (DecsList& ds);

          /// Construct a DecsList node.
          DecsList (const Location& location);

    impl prologue: '#include "ast/decs.hh"'
    impl inside: |2
        void
        DecsList::push_front (Decs* d)
        {
          decs_.push_front (d);
          location_.begin = d->location_get ().begin;
        }

        void
        DecsList::push_back (Decs* d)
        {
          decs_.push_back (d);
          location_.end = d->location_get ().end;
        }

        void
        DecsList::splice_front (DecsList& ds)
        {
          decs_.splice (decs_.begin (), ds.decs_get ());
        }

        void
        DecsList::splice_back (DecsList& ds)
        {
          decs_.splice (decs_.end (), ds.decs_get ());
        }

        DecsList::DecsList (const Location& location)
          : Ast (location)
        {}

Exp:
#<no-type<-
  super: Ast
#->>
#<type<-
  super: Ast Typable
#->>

IntExp:
  super: Exp
  attributes: [ { value: { type: int, access: r, desc: Stored integer value } } ]


StringExp:
  super: Exp
  hide: True
  attributes: [ { value: { type: 'std::string', desc: Stored string value } } ]


NilExp:
  super: Exp


ArrayExp:
  super: Exp
  hide: True
  attributes:
    - type_name:
        type: NameTy*
        desc: Identifier of the stored elements type
    - size:
        type: Exp*
        desc: Size of the array
    - init:
        type: Exp*
        desc: Initial value assigned to all elements of the array


FieldInit:
  super: Ast
  attributes:
    - name:
        type: 'symbol::Symbol'
        owned: False
        desc: Name of the field
        access: rW
    - init: { type: 'Exp*', desc: Initial value of the field }


RecordExp:
  super: Exp
  hide: True
  attributes:
    - type_name: { type: 'NameTy*', desc: Identifier of the record type }
    - fields: { type: 'fieldinits_type*', desc: List of field initializations }


OpExp:
  super: Exp
  inline:
    header inside: |2

        public:
          /// Operator qualifier.
          enum Oper
            {
              // Arithmetics.
              /** \brief "+" */ add,
              /** \brief "-" */ sub,
              /** \brief "*" */ mul,
              /** \brief "/" */ div,

              // Comparison.
              /** \brief "=" */  eq,
              /** \brief "<>" */ ne,
              /** \brief "<" */  lt,
              /** \brief "<=" */ le,
              /** \brief ">" */  gt,
              /** \brief ">=" */ ge
            };

    header epilogue: |2

      // Return a representation of an operator.
      std::string
      str (ast::OpExp::Oper oper);

    impl epilogue: |2

      //<<
      std::string
      str (ast::OpExp::Oper oper)
      {
        std::string s;
        switch (oper)
          {
          case ast::OpExp::add: s = "+";  break;
          case ast::OpExp::sub: s = "-";  break;
          case ast::OpExp::mul: s = "*";  break;
          case ast::OpExp::div: s = "/";  break;
          case ast::OpExp::eq : s = "=";  break;
          case ast::OpExp::ne : s = "<>"; break;
          case ast::OpExp::lt : s = "<";  break;
          case ast::OpExp::le : s = "<="; break;
          case ast::OpExp::gt : s = ">";  break;
          case ast::OpExp::ge : s = ">="; break;
          }
        return s;
      }
      //>>

  attributes:
    - left: { type: 'Exp*', desc: Left operand }
    - oper: { type: OpExp::Oper, access: r, desc: Operator }
    - right: { type: 'Exp*', desc: Right operand }


AssignExp:
  super: Exp
  hide: True
  attributes:
    - var: { type: 'Var*', desc: Reference to the affected variable }
    - exp: { type: 'Exp*', desc: Assigned value }

CallExp:
  super: Exp
  hide: True
  inline:
    header inside: |2

        //<<-
        public:
          /// Set the function name (used in overload).
          void name_set (const symbol::Symbol& n)
          {
            name_ = n;
          }
        //->>

  attributes:
    - name:
        type: 'symbol::Symbol'
        access: r
        desc: Identifier of the called function
        owned: False
    - args:
        type: exps_type*
        desc: List of arguments passed to the function
    - def:
        type: FunctionDec*
        access: rW
        init: 0
        mandatory: False
        owned: False
        desc: Definition site


IfExp:
  super: Exp
  hide: True
  inline:
    header prologue: '# include "ast/seq-exp.hh"'
    header inside: |2
        public:
          IfExp (const Location& location, Exp* test, Exp* thenclause)
            : Exp (location),
              test_ (test),
              thenclause_ (thenclause),
              elseclause_ (new SeqExp (location, new exps_type ()))
          {}

  attributes:
    - test: { type: 'Exp*', desc: Condition }
    - thenclause:
        type: Exp*
        desc: Instructions executed if condition is true
    - elseclause:
        type: Exp*
        desc: Instructions executed if condition is false


ForExp:
  super: Exp
  attributes:
    - vardec: { type: 'VarDec*', desc: Implicit variable declaration }
    - hi: { type: 'Exp*', desc: High bound of the loop }
    - body: { type: 'Exp*', desc: Instructions executed in the loop }


WhileExp:
  super: Exp
  attributes:
    - test: { type: 'Exp*', desc: Exit condition of the loop }
    - body: { type: 'Exp*', desc: Instructions executed in the loop }


BreakExp:
  super: Exp
  hide: True
  attributes:
    - def:
        type: Exp*
        access: rW
        init: 0
        mandatory: False
        owned: False
        desc: The loop it breaks


LetExp:
  super: Exp
  hide: True
  inline:
    header prologue: '# include "misc/contract.hh"'
  attributes:
    - decs: { type: 'DecsList*', desc: List of declarations }
    - body: { type: 'Exp*', access: rw, desc: List of instructions }

SeqExp:
  super: Exp
  hide: True
  attributes:
    - exps: { type: 'exps_type*', desc: List of expressions }

CastExp:
  desc: |2

      /** \class ast::CastExp
       ** \brief Cast the type of an expression to a given type.
       **
       ** This node is only used in the bound checking transformation
       ** (see desugar::bound_checks_add).  You don't need to worry
       ** about it (nor about the `cast' keyword) if you don't implement
       ** this option.
       */

  super: Exp
  attributes:
    - exp: { type: 'Exp*', desc: The cast expression }
    - ty:  { type: 'Ty*', desc: The target type }


Var:
  super: Exp
  hide: True


FieldVar:
  super: Var
  hide: True
  attributes:
    - var: { type: 'Var*', desc: The record that holds the field }
    - field:
        type: 'symbol::Symbol'
        owned: False
        desc: "The field's name"
        access: rW
    - index:
        type: int
        init: -1
        access: rW
        desc: Handle the number of the field in the record that holds it


SimpleVar:
  super: Var
  attributes:
    - name:
        type: 'symbol::Symbol'
        owned: False
        desc: "Variable's name"
        access: rW
    - def:
        type: VarDec*
        access: rW
        init: 0
        mandatory: False
        owned: False
        desc: Definition site


SubscriptVar:
  super: Var
  attributes:
    - var: { type: 'Var*', desc: The mother variable }
    - index: { type: 'Exp*', desc: The offset expression }

CastVar:
  desc: |2

      /** \class ast::CastVar
       ** \brief Cast the type of an l-value to a given type.
       **
       ** This node is only used in the bound checking transformation
       ** (see desugar::bound_checks_add).  You don't need to worry
       ** about it (nor about the `cast' keyword) if you don't implement
       ** this option.
       */

  super: Var
  attributes:
    - var: { type: 'Var*', desc: The cast variable }
    - ty:  { type: 'Ty*', desc: The target type }

Field:
  super: Ast
  attributes:
    - name:
        type: 'symbol::Symbol'
        owned: False
        desc: The field name
        access: rW
    - type_name: { type: 'NameTy*', desc: The field type name }


Ty:
#<no-type<-
  super: Ast
#->>
#<type<-
  super: Ast Typable TypeConstructor
#->>

ArrayTy:
  super: Ty
  attributes: [ { base_type: { type: 'NameTy*', desc: Name of the base type } } ]


NameTy:
  super: Ty
  attributes:
    - name:
        type: 'symbol::Symbol'
        owned: False
        desc: The name of the type
        access: rW
    - def:
        type: TypeDec*
        access: rW
        init: 0
        mandatory: False
        owned: False
        desc: Definition site


RecordTy:
  super: Ty
  hide: True
  attributes: [ { fields: { type: 'fields_type*', desc: The field list } } ]

# Local Variables:
# mode: text
# End:
