#							-*- Yaml -*-
# Possible values:
#  * class
#    Description of classes.
#    + name
#      a C++ class name.
#
#    + desc
#      a (Doxygen) comment describing the class.
#
#    + super
#      a possibly empty space separated list of superclass names.
#
#  * attributes:
#    + name
#      a C++ attribute name
#
#    + type
#      a C++ type name
#
#    + abstract
#      If True, don't output.
#
#    + mandatory
#      + True
#        *_get methods return a const ref.
#      + False
#        *_get methods return a const pointer.
#
#    + init=VALUE
#      If set, the value used to initialize the member.
#      This attribute will not have a argument in the constructors.
#
#    + owned
#      - True: Pointer members are "delete"'d.
#      - False: They are not.
#
#    + access composed by [ 'r', 'w', 'W' ]
#      - r: provide a *_get const accessor.
#      - w: provide a *_get accessor that returns a reference
#        for possible modifications.
#      - W: provide a *_set accessor.
#
#    + desc, a short description of the attribute
#
#    + default
#      The code to output in the default visitor.  The current node
#      is in the variable "n".
#
#    + printer
#      The way the node is pretty-printed, using so ad-hoc syntactic
#      sugar. A pretty-printer is specified by actions in a yaml list.
#      The available actions are:
#      - $foo: Pretty-print the foo_ attribute of the node.
#      - ~bar: Pretty-print recursively the bar_ child of the node.
#      - '{ /* code */ }': Insert a block of code
#      - Any valid rhs for operator <<.
#
# Defaults:
#  * class:
#    + desc: the name of the class
#
#  * attributes:
#    + mandatory: True
#    + access: rw
#    + owned: True
#

---


## -------------- ##
## Root classes.  ##
## -------------- ##

Ast:
  inline:
    header prologue: '# include "ast/fwd.hh"'
  attributes:
    - location:
        type: loc
        access: rW
        desc: Scanner position information
    - up:
        type: 'Ast*'
        init: '0'
        access: rW
        desc: Parent node
  default: super_type::operator() (n);

Exp:
  super: Ast


## ------ ##
## Tags.  ##
## ------ ##

TagExp:
  super: Exp
  attributes:
    - tag: { type: 'Exp*', desc: The tagging expression }
    - exp: { type: 'Exp*', desc: The tagged expression }


## ------- ##
## Scope.  ##
## ------- ##

ScopeExp:
  super: Exp
  attributes:
    - exp: { type: 'Exp*', desc: The scoped expression }


BinaryExp:
  super: Exp
  desc: /// Expressions with two sub expressions
  attributes:
    - lhs: { type: 'Exp*', desc: Left-hand side expression }
    - rhs: { type: 'Exp*', desc: Right-hand side expression }

AndExp:
  super: BinaryExp
  printer:
    - ~lhs
    - '" & "'
    - ~rhs

PipeExp:
  super: BinaryExp
  printer:
    - ~lhs
    - '" | "'
    - ~rhs

CommaExp:
  super: BinaryExp
  printer:
    - ~lhs
    - '" , "'
    - ~rhs

SemicolonExp:
  super: BinaryExp
  printer:
    - ~lhs
    - '" ; "'
    - ~rhs


# Identifier constructs

DotExp:
  super: Exp
  attributes:
    - exp: { type: 'Exp*', desc: Object the variable is attached to (or null if root) }
    - symbol:  { type: 'libport::Symbol*', desc: Name of the variable separated from exp with a dot }

IdExp:
  super: Exp
  attributes:
    - symbol:  { type: 'libport::Symbol*', desc: Name of the symbol to be name-resolved }

Var:
  super: DotExp

ArrowExp:
  super: Exp
  attributes:
    - var: { type: 'Var*', desc: variable whose property is accessed }
    - symbol:  { type: 'libport::Symbol*', desc: Name of the property }

TagOpExp:
  super: Exp
  inline:
    header inside: |2

        public:
          /// Operator qualifier.
          enum type
            {
              stop,
              freeze,
              unfreeze,
              block,
              unblock,
            };
  attributes:
    - tag: { type: Exp*, desc: Tag of the tag-operation command }
    - oper: { type: TagOpExp::type, access: r, desc: Operator }

IfExp:
  super: Exp
  attributes:
    - test: { type: 'Exp*', desc: Condition }
    - thenclause:
        type: Exp*
        desc: Instructions executed if condition is true
    - elseclause:
        type: Exp*
        desc: Instructions executed if condition is false

AtExp:
  super: Exp
  attributes:
    - test: { type: 'Exp*', desc: Condition }
    - atclause:
        type: Exp*
        desc: Instructions executed at the moment when condition becomes true
    - onleaveclause:
        type: Exp*
        desc: Instructions executed onleave

AliasExp:
  super: Exp
  desc: |2

      /** \class ast::AliasExp
       ** \brief Set an alias flag in the object given, to point to one of
       ** its attribute (typically, 'val'). For backward compat only.
       */

  attributes:
    - obj: { type: 'Exp*', desc: Reference to the object to alias }
    - alias: { type: 'libport::Symbol*', desc: Aliased attribute }

AssignExp:
  super: Exp
  attributes:
    - lvalue: { type: 'Var*', desc: Reference to the affected variable }
    - exp: { type: 'Exp*', desc: Assigned value }

InheritsExp:
  super: Exp
  attributes:
    - inheritor: { type: 'Exp*', desc: Reference to the inheriting object }
    - inherited: { type: 'Exp*', desc: Reference to the inherited object }

DisinheritsExp:
  super: Exp
  attributes:
    - disinheritor: { type: 'Exp*', desc: Reference to the disinheriting object }
    - disinherited: { type: 'Exp*', desc: Reference to the diinherited object }

DeleteExp:
  super: Exp
  attributes:
    - obj:
        type: 'Exp*'
        desc: Reference to the object to delete

ExternalExp:
  super: Exp
  inline:
    header inside: |2

        public:
          /// External binding type.
          enum Type
            {
              var,
              function,
              event,
            };
  attributes:
    - fromobj: { type: 'Exp*', desc: Reference to the bound-from object }
    - attribute: { type: 'libport::Symbol*', desc: Bound attribute }
    - type: { type: ExternalExp::Type, access: r, desc: External binding type }
    - qualifier:  { type: int, desc: Binding qualifier used to specify the number of args in a function }

ReturnExp:
  super: Exp
  attributes:
    - exp: { type: 'Exp*', desc: Returned value }
    - cont: { type: bool, desc: Continuation flag for return& }

WaitExp:
  super: Exp
  attributes:
    - duration: { type: 'Exp*', desc: Time to wait }

WaitUntilExp:
  super: Exp
  attributes:
    - condition: { type: 'Exp*', desc: Condition to wait }

WheneverExp:
  super: Exp
  attributes:
    - test: { type: 'Exp*', desc: Condition }
    - wheneverclause:
        type: Exp*
        desc: Instructions executed whenever condition is true
    - elseclause:
        type: Exp*
        desc: Instructions executed whenever condition is false

YieldExp:
  super: Exp
  desc: /// Also known as nop, noop etc.
  printer:
    - '"noop"'

EmitExp:
  super: Exp
  attributes:
    - name:
        type: 'Exp*'
        desc: Reference to the called event
    - args:
        type: 'exps_type*'
        desc: List of arguments passed to the event


# Expressions

ExecExp:
  super: Exp
  attributes:
    - toexec:
        type: 'Exp*'
        access: r
        desc: String to execute

FloatExp:
  super: Exp
  attributes:
    - value:
        type: ufloat
        access: r
        desc: Float value
  printer:
    - $value

StringExp:
  super: Exp
  attributes:
    - value:
        type: 'std::string'
        access: r
        desc: String value

ListExp:
  super: Exp
  attributes:
    - value:
        type: 'exps_type*'
        access: r
        desc: Stored list value

## FIXME: Disabled because I don't know how to free the exp_pairs_type
## pointer.  The machinery is not ready.
##MapExp:
##  super: Exp
##  attributes:
##    - value:
##        type: 'exp_pairs_type*'
##        access: r
##        desc: Stored pair values

RefExp:
  super: Exp
  attributes:
    - value:
        type: 'Exp*'
        access: r
        desc: Stored reference

OpVarExp:
  super: Exp
  inline:
    header inside: |2

        public:
          /// Operator qualifier.
          enum type
            {
              copy,  ///< Copy
              addr,  ///< @
              group, ///< group
            };
  attributes:
    - operand: { type: 'Var*', desc: Operand }
    - oper: { type: OpVarExp::type, access: r, desc: Operator }

NegOpExp:
  super: Exp
  attributes: [ { operand: { type: 'Exp*', desc: Operand of the negation operator } } ]

OpExp:
  super: BinaryExp
  inline:
    header prologue: '# include "libport/assert.hh"'
    header inside: |2

        public:
          /// Operator qualifier.
          enum type
            {
              // Arithmetics.
              add,  ///< "+"
              sub,  ///< "-"
              mul,  ///< "*"
              div,  ///< "/"
              exp,  ///< "^"
              mod,  ///< "%"

              // Logics.
              land, ///< "&&"
              lor,  ///< "||"

              // Comparison.
              equ,  ///< "=="
              req,  ///< "~="
              neq,  ///< "!="
              lth,  ///< "<"
              leq,  ///< "<="
              gth,  ///< ">"
              geq,  ///< ">="
            };

          /// Pretty printing the operator.
          const char* as_string (OpExp::type t) const;

    header after: |2
      std::ostream& operator<< (std::ostream&o, OpExp::type t);

    inline inside: |2

        inline
        std::ostream&
        operator<< (std::ostream&o, OpExp::type t)
        {
          switch (t)
          {
      # define CASE(From, To) case OpExp::From: return o << To; break
            CASE (add, "+");
            CASE (sub, "-");
            CASE (mul, "*");
            CASE (div, "/");
            CASE (exp, "^");
            CASE (mod, "%");
            CASE (land,"&&");
            CASE (lor, "||");
            CASE (equ, "==");
            CASE (req, "~=");
            CASE (neq, "!=");
            CASE (lth, "<");
            CASE (leq, "<=");
            CASE (gth, ">");
            CASE (geq, ">=");
      # undef CASE
          }
          pabort("unreachable");
        }

  attributes:
    - oper: { type: OpExp::type, access: r, desc: Operator }
  printer:
    - ~lhs
    - $oper
    - ~rhs

CallExp:
  super: Exp
  attributes:
    - target:
        type: 'Exp*'
        desc: The target of the message passing.
        mandatory: False
    - name:
        type: 'libport::Symbol'
        desc: Name of the called function
    - args:
        type: 'exps_type*'
        desc: Arguments passed to the function
  printer:
    - ~target
    - $name
    - '"("'
    - libport::separate (n.args_get (), libport::make_pair (',', libport::iendl));
    - '")"'
ArrayExp:
  super: Exp
  attributes:
    - name:
        type: 'Exp*'
        desc: Reference to the array
    - arg:
        type: 'Exp*'
        desc: Index of the array

NewExp:
  super: Exp
  attributes:
    - obj:
        type: 'Exp*'
        desc: Reference to the object to clone
    - args:
        type: 'exps_type*'
        desc: List of arguments passed to the constructor


# Types (embryonic for now)

Ty:
  super: Ast

NameTy:
  super: Ty
  attributes:
    - name:
        type: 'libport::Symbol'
        owned: False
        desc: The name of the type
        access: rW


# Declarations

Dec:
  super: Exp
  attributes:
    - exp:
        type: 'Var*'
        mandatory: False
        desc: Object the variable is attached to (or null if root)
    - symbol:
        type: 'libport::Symbol*'
        desc: Name of the variable, separated from exp with a dot

VarDec:
  super: Dec
  attributes:
    - type_name:
        type: NameTy*
        mandatory: False
        desc: Optional type of the declared variable
    - init:
        type: Exp*
        mandatory: False
        desc: The initial value (expression) assigned to the variable

FunctionDec:
  super: Dec
  attributes:
    - formals: { type: 'vardecs_type*', desc: Formal arguments }
    - result:  { type: 'NameTy*', mandatory: False, desc: Result type}
    - body: { type: 'Exp*', access: rwW, mandatory: False, desc: Instructions }

EventDec:
  super: Dec
  attributes:
    - formals: { type: 'vardecs_type*', desc: Formal arguments }

## FIXME: This does not work currently, because the machinery is not ready
## to free lists of pairs.
##
## ClassDec:
##   super: Dec
##   attributes:
##     - inherits: { type: 'exps_type*', mandatory: False, desc: Inherited classes }
##     - decs: { type: 'decs_type*', mandatory: False, desc: List of declarations }

TagDec:
  super: Dec

# Local Variables:
# mode: text
# End:
