#                                                      -*- Yaml -*-
#
---

# ---------------- #
# AST parameters.  #
# ---------------- #

# The generator will accept these types as is, without looking for a
# particular header.  Also, they are handled by copy.
atomic_types:
  - "bool"
  - "int"
  - "unsigned"
  - "ufloat"

# Likewise, but these types are handled by references, because of
# their size.
# compound_types:
# - "DecsList::decs_type"

# In most cases, the name of the header to include can be computed
# from the name of the type.  Below are the exceptions.
includes_map:
  "std::string": "<string>"

  "ufloat": '"libport/ufloat.h"'

  "libport::Symbol": '"libport/symbol.hh"'
  "symbols_type": '"ast/fwd.hh"'

  "exps_type": '"ast/exp.hh"'

  "decs_type": '"ast/dec.hh"'
  "vardecs_type": '"ast/var-dec.hh"'

  "exp_pair_type": '"ast/exp.hh"'
  "exp_pairs_type": '"ast/exp.hh"'

  "flavor_type": '"ast/flavor.hh"'

  "exec_exps_type" : '"ast/fwd.hh"'

# FIXME: Can we compute this list from atomic_types?
non_visitable_types:
  - "bool"
  - "int"
  - "unsigned"
  - "std::string"
  - "misc::symbol"
  - "const misc::symbol"
  - "Location"

collections:
#  - "exps_type"
#  - "fields_type"
#  - "fieldinits_type"
#  - "DecsList::decs_type"

# The function to clear a list of pointers.
deep_clear: "libport::deep_clear"

# The beginning of visitor.hh, for includes.
visitor_hh_prologue: |2

  # include <functional>
 
  # include <boost/preprocessor/array.hpp>
  # include <boost/preprocessor/repeat.hpp>
 
  # include "libport/select-const.hh"
 
  # include "ast/fwd.hh"

# The beginning of default-visitor.hh, for includes.
default_visitor_hh_prologue: |2

  # include <functional>
  # include <ostream>
  # include "ast/visitor.hh"
  # include "ast/fwd.hh"
  # include "libport/select-const.hh"

# The beginning of fwd.hh, for includes.
fwd_hh_prologue: |2

  # include <list>
  # include <vector>
  
  # include "libport/fwd.hh"

# The end of the fwd.hh file, in the namespace.
fwd_hh_epilogue: |2

    // List types.
    typedef std::list<Exp*> exps_type;
    typedef std::pair<Exp*, Exp*> exp_pair_type;
    typedef std::list<exp_pair_type> exp_pairs_type;
    //typedef std::list<VarDec*> vardecs_type;
    //typedef std::list<Dec*> decs_type;
  
    // FIXME: Should not be pointers, but the machinery is not ready
    // for that.
    typedef std::list<libport::Symbol*> symbols_type;

printer_cc_prologue: |2

  #include "libport/indent.hh"
  #include "libport/pair.hh"
  #include "libport/escape.hh"
  #include "libport/separator.hh"

  #include <boost/foreach.hpp>
  #define foreach BOOST_FOREACH

---

# ----------- #
# AST Nodes.  #
# ----------- #

# Possible values:
#  * class
#    Description of classes.
#    + name
#      a C++ class name.
#
#    + desc
#      a (Doxygen) comment describing the class.
#
#    + super
#      a possibly empty space separated list of superclass names.
#
#  * attributes:
#    + name
#      a C++ attribute name
#
#    + type
#      a C++ type name
#
#    + abstract
#      If True, don't output.
#
#    + mandatory
#      + True
#        *_get methods return a const ref.
#      + False
#        *_get methods return a const pointer.
#
#    + init=VALUE
#      If set, the value used to initialize the member.
#      This attribute will not have a argument in the constructors.
#
#    + owned
#      - True: Pointer members are "delete"'d.
#      - False: They are not.
#
#    + access composed by [ 'r', 'w', 'W' ]
#      - r: provide a *_get const accessor.
#      - w: provide a *_get accessor that returns a reference
#        for possible modifications.
#      - W: provide a *_set accessor.
#
#    + desc, a short description of the attribute
#
#    + default
#      The code to output in the default visitor.  The current node
#      is in the variable "n".
#
#    + printer
#      The way the node is pretty-printed, using so ad-hoc syntactic
#      sugar. A pretty-printer is specified by actions in a yaml list.
#      The available actions are:
#      - $foo: Pretty-print the foo_ attribute of the node.
#      - ~bar: Pretty-print recursively the bar_ child of the node.
#      - '{ /* code */ }': Insert a block of code
#      - Any valid rhs for operator <<.
#
# Defaults:
#  * class:
#    + desc: the name of the class
#
#  * attributes:
#    + mandatory: True
#    + access: rw
#    + owned: True
#

## -------------- ##
## Root classes.  ##
## -------------- ##

Ast:
  inline:
    header prologue: '# include "ast/fwd.hh"'
  attributes:
    - location:
        type: loc
        access: rW
        desc: Scanner position information
    - up:
        type: 'Ast*'
        init: '0'
        access: rW
        desc: Parent node
  default: super_type::operator() (n);

Exp:
  super: Ast


## ------ ##
## Tags.  ##
## ------ ##

Tag:
  super: Exp
  attributes:
    - tag: { type: 'Exp*', desc: The tagging expression }
    - exp: { type: 'Exp*', desc: The tagged expression }
  printer:
    - ~tag
    - '": "'
    - ~exp


## ------- ##
## Scope.  ##
## ------- ##

Scope:
  super: Exp
  attributes:
    - target: { type: 'Exp*', mandatory: false, desc: The default target }
    - body:   { type: 'Exp*', desc: The scoped expression }
  default: |2
    if (n.target_get())
      operator()(*n.target_get());
    operator()(n.body_get());
  printer:
    - '{
         if (n.target_get())
           ostr_ << "do " << *n.target_get() << " ";
       }'
    - '"{"'
    - 'libport::incendl'
    - ~body
    - 'libport::decendl'
    - '"}"'

## -------------------- ##
## Composing commands.  ##
## -------------------- ##

Flavorable:
  attributes:
    - flavor: { type: flavor_type, desc: Execution model }

Nary:
  super: Exp
  desc: /// A list of expressions to run possibly in background.
  attributes:
    - children:
        type: 'exec_exps_type'
        desc: Subtrees possibly qualified to be background.
        access: rw
    - toplevel:
        type: 'bool'
        desc: Whether or not this node is a top-level node.
        access: rW
  printer:
    - $children
  inline:
    header prologue: |
        # include "ast/flavor.hh"
        namespace ast
        {
          // An expression and its flavor.
          typedef std::pair<Exp*, flavor_type> exec_exp_type;
          
          /// Report \a e on \a o.
          std::ostream& operator<<(std::ostream& o, const exec_exp_type& e);
          
          // A list of such expressions.
          typedef std::list<exec_exp_type> exec_exps_type;

          /// Report \a e on \a o.
          std::ostream& operator<<(std::ostream& o, const exec_exps_type& e);
        }

    header inside: |2
        public:
          /// A completely empty Nary node.
          Nary();

          /// Drop the children.
          void clear ();

          /// Are there any children?
          bool empty() const;

          /// Push a new expression.
          void push_back(ast::Exp* e);

          /// Push a new expression.
          /// Add the expression @a e at the end of this, set the
          /// *previous* execution type to be @a k.
          /// \precondition this is not empty.
          void push_back(flavor_type k, ast::Exp* e);

          /// Return the last child.
          exec_exp_type& back ();

          /// Sets the flavor of the last child.
          void back_flavor_set (flavor_type k);

          /// Drop the last children.
          void pop_back ();

          /// Splice the content of \a rhs at the back this list.
          void splice_back (Nary& rhs);

    impl prologue: |2
      #include <boost/foreach.hpp>
        
      #include "libport/indent.hh"
      #include "libport/separator.hh"

      #include "ast/pretty-printer.hh"

      namespace libport
      {
      
        // Specialization to free the children.
        template<>
        struct Delete<ast::exec_exp_type>
        {
          void operator () (ast::exec_exp_type& t)
          {
            delete t.first;
          }
        };

      } // libport

    impl inside: |2
        Nary::Nary ()
          : Exp (ast::loc()),
            children_ (),
            toplevel_ (false)
        { }

        void
        Nary::clear ()
        {
          children_.clear ();
        }

        bool
        Nary::empty () const
        {
          return children_.empty();
        }

        void
        Nary::push_back(ast::Exp* e)
        {
          children_.push_back (ast::exec_exp_type (e, flavor_none));
        }

        void
        Nary::push_back(flavor_type k, ast::Exp* e)
        {
          assert(!children_.empty());
          children_.back().second = k;
          push_back (e);
        }

        exec_exp_type&
        Nary::back ()
        {
          return children_.back();
        }

        void
        Nary::back_flavor_set (flavor_type k)
        {
           if (!children_.empty ())
             children_.back ().second = k;
        }
      
        void
        Nary::pop_back ()
        {
          children_.pop_back();
        }
      
        void
        Nary::splice_back (Nary& rhs)
        {
          children_.splice (children_.end (), rhs.children_get ());
        }
      
        std::ostream&
        operator<<(std::ostream& o, const exec_exp_type& e)
        {
          o << *e.first;
          if (e.second != flavor_none)
            o << e.second;
          return o;
        }
        
        std::ostream&
        operator<<(std::ostream& o, const exec_exps_type& es)
        {
          return o << libport::separate (es, libport::iendl);
        }

Binary:
  super: Exp
  desc: /// Expressions with two sub expressions
  attributes:
    - lhs:
        type: 'Exp*'
        desc: Left-hand side expression
        access: rwW
    - rhs:
        type: 'Exp*'
        desc: Right-hand side expression
        access: rwW
  default: |2
    operator()(n.lhs_get());
    operator()(n.rhs_get());

And:
  super: Binary
  printer:
    - ~lhs
    - '" & "'
    - ~rhs

Pipe:
  super: Binary
  printer:
    - ~lhs
    - '" | "'
    - ~rhs



# Identifier constructs

# Dot:
#   super: Exp
#   attributes:
#     - exp: { type: 'Exp*', desc: Object the variable is attached to (or null if root) }
#     - symbol:  { type: 'libport::Symbol*', desc: Name of the variable separated from exp with a dot }

# Id:
#   super: Exp
#   attributes:
#     - symbol:  { type: 'libport::Symbol*', desc: Name of the symbol to be name-resolved }

# Var:
#   super: Dot

# Arrow:
#   super: Exp
#   attributes:
#     - var: { type: 'Var*', desc: variable whose property is accessed }
#     - symbol:  { type: 'libport::Symbol*', desc: Name of the property }

# TagOp:
#   super: Exp
#   inline:
#     header inside: |2
#
#         public:
#           /// Operator qualifier.
#           enum type
#             {
#               stop,
#               freeze,
#               unfreeze,
#               block,
#               unblock,
#             };
#   attributes:
#     - tag: { type: Exp*, desc: Tag of the tag-operation command }
#     - oper: { type: TagOp::type, access: r, desc: Operator }

If:
  super: Exp
  attributes:
    - test:
        type: Exp*
        desc: Condition to select thenclause or elseclause
    - thenclause:
        type: Exp*
        desc: Executed if test is true
    - elseclause:
        type: Exp*
        desc: Executed if test is false
  default: |2
    operator()(n.test_get());
    operator()(n.thenclause_get());
    operator()(n.elseclause_get());
  printer:
    - '"if ("'
    - ~test
    - '")"'
    - libport::incendl
    - ~thenclause
    - libport::decendl
    - '"else"'
    - libport::incendl
    - ~elseclause
    - libport::decindent

While:
  super:
    - Exp
    - Flavorable
  attributes:
    - test:
        type: Exp*
        desc: Condition to continue
    - body:
        type: Exp*
        desc: Executed if test is true
  default: |2
    operator()(n.test_get());
    operator()(n.body_get());
  printer:
    - '"while"'
    - '{
         if (n.flavor_get() != flavor_semicolon)
           ostr_ << n.flavor_get();
       }'
    - '"("'
    - ~test
    - '")"'
    - libport::incendl
    - ~body
    - libport::decindent

# At:
#   super: Exp
#   attributes:
#     - test: { type: 'Exp*', desc: Condition }
#     - atclause:
#         type: Exp*
#         desc: Instructions executed at the moment when condition becomes true
#     - onleaveclause:
#         type: Exp*
#         desc: Instructions executed onleave

# Alias:
#   super: Exp
#   desc: |2
#
#       /** \class ast::Alias
#        ** \brief Set an alias flag in the object given, to point to one of
#        ** its attribute (typically, 'val'). For backward compat only.
#        */
#
#   attributes:
#     - obj: { type: 'Exp*', desc: Reference to the object to alias }
#     - alias: { type: 'libport::Symbol*', desc: Aliased attribute }
 
# Inherits:
#   super: Exp
#   attributes:
#     - inheritor: { type: 'Exp*', desc: Reference to the inheriting object }
#     - inherited: { type: 'Exp*', desc: Reference to the inherited object }

# Disinherits:
#   super: Exp
#   attributes:
#     - disinheritor: { type: 'Exp*', desc: Reference to the disinheriting object }
#     - disinherited: { type: 'Exp*', desc: Reference to the diinherited object }

# Delete:
#   super: Exp
#   attributes:
#     - obj:
#         type: 'Exp*'
#         desc: Reference to the object to delete

# External:
#   super: Exp
#   inline:
#     header inside: |2

#         public:
#           /// External binding type.
#           enum Type
#             {
#               var,
#               function,
#               event,
#             };
#   attributes:
#     - fromobj: { type: 'Exp*', desc: Reference to the bound-from object }
#     - attribute: { type: 'libport::Symbol*', desc: Bound attribute }
#     - type: { type: External::Type, access: r, desc: External binding type }
#     - qualifier:  { type: int, desc: Binding qualifier used to specify the number of args in a function }

Return:
  super: Exp
  attributes:
    - exp: { type: 'Exp*', desc: Returned value }
    - cont: { type: bool, desc: Continuation flag for return& }
  printer:
    - '"return"'
    - '{
         if (n.cont_get())
           ostr_ << "&";
       }'
    - '" "'
    - ~exp

# Wait:
#   super: Exp
#   attributes:
#     - duration: { type: 'Exp*', desc: Time to wait }

# WaitUntil:
#   super: Exp
#   attributes:
#     - condition: { type: 'Exp*', desc: Condition to wait }

# Whenever:
#   super: Exp
#   attributes:
#     - test: { type: 'Exp*', desc: Condition }
#     - wheneverclause:
#         type: Exp*
#         desc: Instructions executed whenever condition is true
#     - elseclause:
#         type: Exp*
#         desc: Instructions executed whenever condition is false
 
Noop:
  super: Exp
  desc: /// Also known as nop, noop etc.
  attributes:
    - implicit: { type: bool, desc: Whether not spelled out in the source }
  printer:
    - '"noop"'

# Emit:
#   super: Exp
#   attributes:
#     - name:
#         type: 'Exp*'
#         desc: Reference to the called event
#     - args:
#         type: 'exps_type*'
#         desc: List of arguments passed to the event
 

# Expressions

# Exec:
#   super: Exp
#   attributes:
#     - toexec:
#         type: 'Exp*'
#         access: r
#         desc: String to execute
 
Float:
  super: Exp
  attributes:
    - value:
        type: ufloat
        access: r
        desc: Float value
  printer:
    - $value

String:
  super: Exp
  attributes:
    - value:
        type: 'std::string'
        access: r
        desc: String value
  printer:
    - "'\"'"
# FIXME: It really stinks not to be able to use $value here.
    - libport::escape(n.value_get())
    - "'\"'"

List:
  super: Exp
  attributes:
    - value:
        type: 'exps_type*'
        access: r
        desc: Stored list value
  printer:
    - '"["'
    - '{
        ostr_ << libport::separate (n.value_get(), ", ");
       }'
    - '"]"'

## FIXME: Disabled because I don't know how to free the exp_pairs_type
## pointer.  The machinery is not ready.
##Map:
##  super: Exp
##  attributes:
##    - value:
##        type: 'exp_pairs_type*'
##        access: r
##        desc: Stored pair values

# Ref:
#   super: Exp
#   attributes:
#     - value:
#         type: 'Exp*'
#         access: r
#         desc: Stored reference

# OpVar:
#   super: Exp
#   inline:
#     header inside: |2

#         public:
#           /// Operator qualifier.
#           enum type
#             {
#               copy,  ///< Copy
#               addr,  ///< @
#               group, ///< group
#             };
#   attributes:
#     - operand: { type: 'Var*', desc: Operand }
#     - oper: { type: OpVar::type, access: r, desc: Operator }
 
Call:
  desc: /// Function calls, and attribute look-ups.
  super: Exp
  attributes:
    - name:
        type: 'libport::Symbol'
        desc: Name of the called function
    - args:
        type: 'exps_type*'
        desc: Arguments passed to the function
  printer:
    - '{
         if (n.args_get().front ())
           {
             n.args_get().front ()->accept(*this);
             ostr_ << " . ";
           }
       }'
    - $name
    - '{
          if (n.args_get ().size() >= 2)
            ostr_ << "("
                  << libport::incindent
                  << libport::separate (exps_type (++n.args_get ().begin(),
                                                   n.args_get ().end()),
                                        ", ")
                  << libport::decindent
                  << ")";
       }'

# Array:
#   super: Exp
#   attributes:
#     - name:
#         type: 'Exp*'
#         desc: Reference to the array
#     - arg:
#         type: 'Exp*'
#         desc: Index of the array
 
New:
  super: Exp
  attributes:
    - obj:
        type: 'Exp*'
        desc: Reference to the object to clone
    - args:
        type: 'exps_type*'
        desc: List of arguments passed to the constructor


# Types (embryonic for now)

# Ty:
#   super: Ast

# NameTy:
#   super: Ty
#   attributes:
#     - name:
#         type: 'libport::Symbol'
#         owned: False
#         desc: The name of the type
#         access: rW
 

# Declarations

# Dec:
#   super: Exp
#   attributes:
#     - exp:
#         type: 'Var*'
#         mandatory: False
#         desc: Object the variable is attached to (or null if root)
#     - symbol:
#         type: 'libport::Symbol*'
#         desc: Name of the variable, separated from exp with a dot

# VarDec:
#   super: Dec
#   attributes:
#     - type_name:
#         type: NameTy*
#         mandatory: False
#         desc: Optional type of the declared variable
#     - init:
#         type: Exp*
#         mandatory: False
#         desc: The initial value (expression) assigned to the variable
 
Function:
  super: Exp
  attributes:
    - formals: { type: 'symbols_type', desc: Formal arguments }
    - body: { type: 'Exp*', access: rwW, mandatory: False, desc: Body }
  printer:
    - '"function ("'
    - libport::separate (n.formals_get(), ", ")
    - '") "'
    - ~body

# EventDec:
#   super: Dec
#   attributes:
#     - formals: { type: 'vardecs_type*', desc: Formal arguments }
 
## FIXME: This does not work currently, because the machinery is not ready
## to free lists of pairs.
##
## ClassDec:
##   super: Dec
##   attributes:
##     - inherits: { type: 'exps_type*', mandatory: False, desc: Inherited classes }
##     - decs: { type: 'decs_type*', mandatory: False, desc: List of declarations }

# TagDec:
#   super: Dec
 
# Local Variables:
# mode: yaml
# End:
