#                                                      -*- Yaml -*-
#
---

# ---------------- #
# AST parameters.  #
# ---------------- #

# The base directory to prepend to all the file names generated in the
# generated Makefile snippet.  If this ast-nodes.mk is to be included
# by ast/Makefile.am, then define to empty.  If it is included by its
# parent Makefile.am, define to "ast/".
ast_basedir: "ast/"

# The name of the directory/namespace that contains our auxiliary C++
# library.
auxlib: "libport"

# The name of the directory/namespace that contains the cloner.
clonerlib: "ast"

# The generator will accept these types as is, without looking for a
# particular header.  Also, they are handled by copy.
atomic_types:
  - "bool"
  - "int"
  - "ufloat"
  - "unsigned"

# Likewise, but these types are handled by references, because of
# their size.
# compound_types:
# - "DecsList::decs_type"

# In most cases, the name of the header to include can be computed
# from the name of the type.  Below are the exceptions.
includes_map:
  "local_declarations_type":    '<ast/local-declarations-type.hh>'
  "exps_type":                  '<ast/exps-type.hh>'
  "flavor_type":                '<ast/flavor.hh>'
  "libport::RefCounted":        '<libport/ref-counted.hh>'
  "libport::Symbol":            '<libport/symbol.hh>'
  "std::string":                '<string>'
  "symbols_type":               '<ast/symbols-type.hh>'
  "ufloat":                     '<libport/ufloat.h>'
  "modifiers_type":             '<libport/hash.hh>'

# FIXME: Can't we compute this list from atomic_types?  Or simply, one
# cannot visit something which is not a defined ast node?
# Used by the cloner.
non_visitable_types:
  - "bool"
  - "flavor_type"
  - "libport::Symbol"
  - "loc"
  - "std::string"
  - "ufloat"
  - "unsigned"

# In the cloner, these require "recurse_collection".
collections:
  - "exps_type"
  - "local_declarations_type"
  - "symbols_type"
  - "modifiers_type"

# The function to clear a list of pointers.
deep_clear: "libport::deep_clear"

# A regexp mathing the types that need to be deep-cleared.
deep_clear_p: '^$'

# The beginning of visitor.hh, for includes.
visitor_hh_prologue: |2

  # include <functional>

  # include <boost/preprocessor/array.hpp>
  # include <boost/preprocessor/repeat.hpp>

  # include <libport/select-const.hh>

  # include <ast/fwd.hh>

# The beginning of default-visitor.hh, for includes.
default_visitor_hh_prologue: |2

  # include <functional>
  # include <ostream>

  # include <libport/select-const.hh>

  # include <ast/visitor.hh>

# The beginning of fwd.hh, for includes.
fwd_hh_prologue: |2
  # include <boost/ptr_container/ptr_vector.hpp>

  # include <libport/fwd.hh>
  # include <libport/hash.hh>
  # include <libport/separator.hh>

# The end of the fwd.hh file, in the namespace.
fwd_hh_epilogue: |2

  typedef libport::hash_map<libport::Symbol, ast::rExp> modifiers_type;

printer_cc_prologue: |2

  #include <libport/foreach.hh>
  #include <libport/escape.hh>
  #include <libport/indent.hh>
  #include <libport/pair.hh>

  #include <kernel/userver.hh>
---

# ----------- #
# AST Nodes.  #
# ----------- #

# Possible values:
#  * class
#    Description of classes.
#    + name
#      a C++ class name.
#
#    + desc
#      a (Doxygen) comment describing the class.
#
#    + super
#      a possibly empty space separated list of superclass names.
#
#    + inline
#      code to include verbatim at some selected places:
#      [header, inline, impl] x [prologue, inside, epilogue].
#       *.hh     *.hxx  *.cc
#       prologue: in the #include section.
#       inside:   in the class definition/namespace
#       epilogue: after the class definition, in the namespace.
#
#  * clone_by_ref
#    Boolean, by default false. If true, the cloner will simply
#    reuse the node itself as it will never change.
#
#  * cloner_prologue
#    Code to execute before cloning this node
#
#  * attributes:
#    + name
#      a C++ attribute name
#
#    + type
#      a C++ type name
#
#    + abstract
#      If True, don't output.
#
#    + mandatory
#      + True
#        *_get methods return a const ref.
#      + False
#        *_get methods return a const pointer.
#
#    + init
#      If set, the value used to initialize the member.
#      This attribute will not have an argument in the constructors.
#
#    + owned
#      - True: Pointer members are "delete"'d.
#      - False: They are not.
#
#    + access composed by [ 'r', 'w', 'W' ]        (defaults to rw)
#      - r: provide a *_get const accessor.
#      - w: provide a *_get accessor that returns a reference
#        for possible modifications.
#      - W: provide a *_set accessor.
#
#    + desc, a short description of the attribute
#
#    + default
#      The code to output in the default visitor.  The current node
#      is in the variable "n".
#
#    + printer
#      The way the node is pretty-printed, using so ad-hoc syntactic
#      sugar. A pretty-printer is specified by actions in a yaml list.
#      The available actions are:
#      - $foo: Pretty-print the foo_ attribute of the node.
#      - ~bar: Pretty-print recursively the bar_ child of the node.
#      - '{ /* code */ }': Insert a block of code
#      - Any valid rhs for operator <<.
#
# Defaults:
#  * class:
#    + desc: the name of the class
#
#  * attributes:
#    + mandatory: True
#    + access: rw
#    + owned: True
#

## -------------- ##
## Root classes.  ##
## -------------- ##

Ast:
  super: 'libport::RefCounted'
  inline:
    header prologue: |2
      # include <ast/fwd.hh>
      namespace runner { class Interpreter; }
  attributes:
    - doc:
        type: 'std::string'
        access: rW
        init: '""'
    - location:
        type: loc
        access: rW
        desc: Scanner position information
    - original:
        type: rConstAst
        access: rW
        desc: Original node, if this is a rewrite
        init: "0"

Exp:
  super:
    - Ast
  inline:
    header inside: |2
        public:
          /// Whether is an instance of ast::Implicit.
          virtual bool implicit() const;
    impl inside: |2
          bool Exp::implicit() const
          {
            return false;
          }

MetaExp:
  desc: /// A node which is a placeholder for an Exp.
  super: Exp
  attributes:
    - id:
        type: unsigned
        desc: The index of the meta-variable.
  printer:
    - '"%exp:"'
    - $id

## ------ ##
## Tags.  ##
## ------ ##

Tag:
  super: Exp
  attributes:
    - exp: { type: 'rExp', desc: The tagging expression }
  printer:
    - ~exp

TaggedStmt:
  super: Exp
  attributes:
    - tag: { type: 'rTag', desc: The tagging expression }
    - exp: { type: 'rExp', desc: The tagged expression }
  printer:
    - ~tag
    - '": "'
    - ~exp


## ------- ##
## Scope.  ##
## ------- ##

Scope:
  super: Exp
  concrete: True
  attributes:
    - body:
        type: 'rExp'
        desc: The scoped expression
        access: rwW
  printer:
    - '"{"'
    - 'libport::incendl'
    - ~body
    - 'libport::decendl'
    - '"}"'

Do:
  super: Scope
  attributes:
    - target: { type: 'rExp', desc: The default target }
  default: |2
    operator()(n->target_get().get());
    visit((typename Const<Scope>::type*) n);
  printer:
    - '{ ostr_ << "do " << *n->target_get() << " "; }'
    - '{ visit(reinterpret_cast<const Scope*>(n)); }'

## -------------------- ##
## Composing commands.  ##
## -------------------- ##

Flavored:
  super: Exp
  attributes:
    - flavor:
        type: flavor_type
        desc: Execution model
        access: rW


Message:
  super: Exp
  desc: /// Display a message when visited.
  attributes:
    - text:
        type: 'std::string'
        desc: The message to display when visited
    - tag:
        type: 'std::string'
        desc: The tag for the message.
  printer:
    - $tag
    - '" "'
    - $text

Stmt:
  super:
    - Flavored
  desc: /// An expression with its flavor
  attributes:
    - expression:
        type: 'rExp'
        desc: Unqualified expression
        access: rw
  printer:
    - ~expression
    - '{
         if (n->flavor_get() != flavor_none)
           ostr_ << n->flavor_get();
       }'

Nary:
  super: Exp
  desc: /// A list of \c Exp, mainly Stmt and Message.
  attributes:
    - children:
        type: 'exps_type*'
        desc: Subtrees possibly qualified to be background.
        access: rwW
        init: "new exps_type()"
    - toplevel:
        type: 'bool'
        desc: Whether is a top-level node.
        access: rW
        init: "false"
  default: |2
    foreach (libport::shared_ptr<typename Const<ast::Ast>::type> c, n->children_get())
      operator()(c.get());

  printer:
    - $children
  inline:
    header prologue: |2
      #include <ast/flavor.hh>
    header inside: |2
        public:
          /// A completely empty Nary node.
          Nary();

          /// Drop the children.
          void clear ();

          /// Are there any children?
          bool empty() const;

          /// Push a new expression, creating a Statement node.
          void push_back(rExp e, flavor_type f = flavor_none);

          /// Idem, at the front.
          void push_front(rExp e, flavor_type f = flavor_none);

          /// Push a message.
          void message_push(const std::string& text, const std::string& tag);

          /// Sets the flavor of the last child.
          void back_flavor_set (flavor_type k, const loc& l);

          /// Sets the flavor of the last child without modifying location.
          void back_flavor_set (flavor_type k);

          /// Get the flavor of the last child.
          flavor_type back_flavor_get() const;

          /// Drop the last children.
          void pop_back ();

          /// Splice the content of \a rhs at the back this list.
          void splice_back (rNary rhs);

       private:
          /// Return the last child if there is one of the right type.
          template <typename T>
          libport::shared_ptr<T> back ();

          /// Return the last child if there is one of the right type.
          template <typename T>
          libport::shared_ptr<const T> back () const;

          /// Adjust the whole location.
          void location_adjust ();

    impl prologue: |2
      #include <libport/indent.hh>
      #include <libport/separator.hh>

      #include <ast/message.hh>
      #include <ast/stmt.hh>

    impl inside: |2
        Nary::Nary ()
          : Exp(loc()),
            children_(new exps_type()),
            toplevel_(false)
        {}

        void
        Nary::clear ()
        {
          children_->clear ();
          location_ = loc();
        }

        bool
        Nary::empty () const
        {
          return children_->empty();
        }

        void
        Nary::location_adjust ()
        {
          if (empty())
            location_.initialize(0);
          else
          {
            location_.begin = children_->front()->location_get().begin;
            location_.end   = children_->back() ->location_get().end;
          }
        }

        static ast::Stmt* stmt(ast::Exp* e, flavor_type f)
        {
          if (ast::Stmt* s = dynamic_cast<ast::Stmt*>(e))
            return s;
          else
            return new Stmt(e->location_get(), f, e);
        }

        void
        Nary::push_back(rExp e, flavor_type f)
        {
          children_->push_back(stmt(e.get(), f));
          location_adjust();
        }

        void
        Nary::push_front(rExp e, flavor_type f)
        {
          children_->push_front(stmt(e.get(), f));
          location_adjust();
        }

        void
        Nary::message_push(const std::string& text, const std::string& tag)
        {
          children_->push_back(new Message(loc(), text, tag));
        }

        template <typename T>
        libport::shared_ptr<T>
        Nary::back ()
        {
          return (empty()
                  ? libport::shared_ptr<T>()
                  : libport::unsafe_cast<T>(children_->back()));
        }

        template <typename T>
        libport::shared_ptr<const T>
        Nary::back () const
        {
          return (empty()
                  ? libport::shared_ptr<const T>()
                  : libport::unsafe_cast<const T>(children_->back()));
        }

        void
        Nary::back_flavor_set (flavor_type k, const loc& l)
        {
          if (rStmt b = back<Stmt>())
          {
            b->flavor_set(k);
            b->location_set(b->location_get () + l);
          }
          location_adjust();
        }

        void
        Nary::back_flavor_set (flavor_type k)
        {
          if (rStmt b = back<Stmt>())
             b->flavor_set(k);
        }

        flavor_type
        Nary::back_flavor_get() const
        {
          if (rConstStmt b = back<Stmt>())
            return b->flavor_get ();
          return flavor_none;
        }

        void
        Nary::pop_back ()
        {
          children_->pop_back();
          location_adjust();
        }

        void
        Nary::splice_back(rNary rhs)
        {
          foreach (rExp elt, rhs->children_get())
            children_->push_back(elt);
          rhs->clear();
          location_adjust();
        }

Composite:
  super: Exp
  attributes:
    - children:
        type:   'exps_type'
        access: rwW
        desc:   Subexpressions

And:
  super: Composite
  printer:
    - 'libport::separate(n->children_get(), " & ")'

Pipe:
  super: Composite
  printer:
    - 'libport::separate(n->children_get(), " | ")'

If:
  super: Exp
  attributes:
    - test:
        type: rExp
        desc: Condition to select thenclause or elseclause
    - thenclause:
        type: rScope
        desc: Executed if test is true
    - elseclause:
        type: rScope
        desc: Executed if test is false
  printer:
    - '"if ("'
    - ~test
    - '")"'
    - libport::iendl
    - ~thenclause
    - libport::iendl
    - '"else"'
    - libport::iendl
    - ~elseclause

While:
  super:
    - Flavored
  attributes:
    - test:
        type: rExp
        desc: Condition to continue
    - body:
        type: rScope
        desc: Executed if test is true
  printer:
    - '"while"'
    - '{
         if (n->flavor_get() != flavor_semicolon)
           ostr_ << n->flavor_get();
       }'
    - '"("'
    - ~test
    - '")"'
    - libport::iendl
    - ~body

Foreach:
  super:
    - Flavored
  attributes:
    - index:
        type: 'rLocalDeclaration'
        desc: The variable storing de values on which iterate.
    - list:
        type: rExp
        desc: The list containing the values on which iterate.
    - body:
        type: rScope
        desc: Executed for each value in the list
  printer:
    - '"for "'
    - '{ n->index_get()->what_get().print_escaped(ostr_); }'
    - '" in "'
    - ~list
    - libport::iendl
    - ~body

Break:
  desc: /// Break from a loop.
  super: Exp
  printer:
    - '"break"'

Continue:
  desc: /// Continue execution of a loop.
  super: Exp
  printer:
    - '"continue"'

Return:
  desc: /// Return a value from a function or closure.
  super: Exp
  attributes:
    - value:
        type: 'rExp'
        desc: The value to return. May be empty.
        mandatory: False
  printer:
    - '"return"'
    - "{
         if (n->value_get())
           ostr_ << ' ' << *n->value_get();
       }"

Noop:
  super: Scope
  desc: /// Also known as nop, noop etc.
  printer:
    - '"{}"'


## --------------------- ##
## Native Urbi objects.  ##
## --------------------- ##

Implicit:
  super: Exp
  desc: /// Implicit target for messages.
  clone_by_ref: true
  inline:
    header inside: |2
        public:
          /// Whether is an instance of ast::Implicit.
          virtual bool implicit() const;
    impl inside: |2
          bool Implicit::implicit() const
          {
            return true;
          }
  printer:
    - '"<IMPLICIT>"'

Float:
  super: Exp
  attributes:
    - value:
        type: ufloat
        access: r
        desc: Float value
  clone_by_ref: true
  printer:
    - $value

String:
  super: Exp
  attributes:
    - value:
        type: 'std::string'
        access: r
        desc: String value
  clone_by_ref: true
  printer:
    - "'\"'"
# FIXME: It really stinks not to be able to use $value here.
    - libport::escape(n->value_get())
    - "'\"'"

List:
  super: Exp
  attributes:
    - value:
        type: 'exps_type*'
        access: rw
        desc: Stored list value
  printer:
    - '"["'
    - 'libport::separate (n->value_get(), ", ")'
    - '"]"'
  default: |2
    foreach (libport::shared_ptr<typename Const<ast::Exp>::type> exp, n->value_get())
      operator()(exp.get());

LValue:
  super: Exp
  inline:
    header prologue: |2
      # include <ast/print.hh>
    header inside: |2
        public:
          /// This lvalue as a call
          ast::rCall call();
    impl inside: |2
          ast::rCall LValue::call()
          {
            ast::rCall res = dynamic_cast<ast::Call*>(this);
            passert("Invalid call: " << *this, res);
            return res;
          }

LValueArgs:
  super: LValue
  attributes:
    - arguments:
        type: 'exps_type*'
        access: rwW
        mandatory: false
        desc: Arguments passed to the function


Call:
  desc: /// Function calls, and attribute look-ups.
  super: LValueArgs
  attributes:
    - target:
        type: rExp
        desc: The target of the call
        access: rW
    - name:
        type: 'libport::Symbol'
        desc: Name of the called function
  inline:
    header inside: |2
        public:
          /// Whether the target is implicit.
          bool target_implicit() const;
    inline inside: |2
          inline bool Call::target_implicit() const
          {
            return target_->implicit();
          }
  default: |2
    visit((typename Const<Exp>::type*) n);
    operator()(n->target_get().get());
    if (n->arguments_get())
    {
      foreach (libport::shared_ptr<typename Const<ast::Exp>::type> e, *n->arguments_get())
        operator()(e.get());
    }
  printer:
    - '{
         if (!(n->target_get()->implicit()))
           ostr_ << *n->target_get() << " . ";
       }'
    - '{
         n->name_get().print_escaped(ostr_);
       }'
    - '{
         if (n->arguments_get())
           ostr_
            << "("
            << libport::incindent
            << libport::separate(*n->arguments_get(), ", ")
            << libport::decindent
            << ")";
       }'

MetaLValue:
  desc: /// A node which is a placeholder for a Call.
  super: LValueArgs
  attributes:
    - id:
        type: unsigned
        desc: The index of the meta-variable.
  printer:
    - '"%lvalue:"'
    - $id

MetaArgs:
  super: LValue
  attributes:
    - lvalue:
        type: rLValue
        desc: Target metavalue
    - id:
        type: unsigned
        desc: Index of the arguments meta-variable
  printer:
    - ~lvalue
    - '"(%exps:"'
    - $id
    - '")"'

Lazy:
  desc:
    /// When calling a function, it is unknown whether it will
    /// needed the lazy (AST) or strict (value) version of the arguments.
    /// So we pass both, and let the function decide.
  super: Exp
  attributes:
    - lazy:
        type: rExp
        access: rwW
    - strict:
        type: rExp
        access: rwW
  printer:
    - ~strict
    - '{
         static bool pprinter = getenv("PPRINTER");
         if (pprinter)
           ostr_ << "/* " << *n->lazy_get() << " */";
       }'

Routine:
  super: Exp
  attributes:
    - formals:
        type: 'local_declarations_type*'
        mandatory: False
        desc: Formal arguments.  If null, a lazy function.
        access: rwW
    - body:
        type: 'rScope'
        access: rwW
        mandatory: False
        desc: Body
    - local_variables:
        type: 'local_declarations_type*'
        init: "0"
        mandatory: False
        access: rwW
    - captured_variables:
        type: 'local_declarations_type*'
        init: "new local_declarations_type()"
        mandatory: False
        access: rwW
    - local_size:
        type: unsigned
        init: '0'
        access: rW
    - closed_size:
        type: unsigned
        init: '0'
        access: rW
    - uses_call:
        type: bool
        init: 'false'
        access: rW
  inline:
    header inside: |2
        public:
          /// Whether the arguments must be evaluated.
          bool strict () const;
    inline inside: |2
          inline bool Routine::strict() const
          {
            return formals_;
          }
  printer:
    - '{
         if (n->formals_get ())
           ostr_ << "(" << *n->formals_get() << ") ";
       }'
    - ~body

Function:
  super: Routine
  attributes:
    - closed_variables:
        type: symbols_type*
        access: rwW
        init: 'new symbols_type()'
  # Cloning a list of reference such as this one requires a mapping table
  # in the cloner. Forbid it for now.
  cloner_prologue: assert(!e->local_variables_get());
  printer:
    - '"function "'
    - '{visit(reinterpret_cast<const Routine*>(n));}'

Closure:
  super: Routine
  # Cloning a list of reference such as this one requires a mapping table
  # in the cloner. Forbid it for now.
  cloner_prologue: assert(!e->local_variables_get());
  printer:
    - '"closure "'
    - '{visit(reinterpret_cast<const Routine*>(n));}'

LocalWrite:
  super: Exp
  attributes:
    - what:
        type:   'libport::Symbol'
        desc:   Name of the symbol being declared or updated.
        access: rW
    - value:
        type: rExp
        desc: Initialization value.
        access: rwW
    - local_index:
        type: unsigned
        access: rwW
        init: '0'

LocalDeclaration:
  super: LocalWrite
  attributes:
    - closed:
        type: 'bool'
        desc: Whether this variable is closed-over by a subcontext
        access: rW
        init: 'false'
  printer:
    - '"var "'
    - $what
    - '{
         if (n->value_get())
         {
           ostr_ << " = ";
           operator()(n->value_get().get());
         }
       }'

LocalAssignment:
  super: LocalWrite
  attributes:
    - depth:
        type: unsigned
        desc: the number of contexts to rewind to find the actual variable
        access: rwW
    - declaration:
        type: rLocalDeclaration
        access: rwW
        init: '0'
  inline:
    header inside: |2
      public:
        bool closed_get() const;
        unsigned local_index_get() const;
    impl inside: |2
      bool LocalAssignment::closed_get() const
      {
        assert(declaration_);
        return declaration_->closed_get();
      }
      unsigned LocalAssignment::local_index_get() const
      {
        assert(declaration_);
        return declaration_->local_index_get();
      }

  cloner_prologue: 'assert(!e->declaration_get());'
  printer:
    - $what
    - '" = "'
    - ~value

Write:
  super: Exp
  attributes:
    - what:
        type: rLValue
        desc: What is being declared
        access: r
    - value:
        type: rExp
        desc: Initialization value.
        access: r
    - modifiers:
        type: modifiers_type*
        desc: Time and trajectory modifiers
        access: rW
        mandatory: false
  printer:
    - ~what
    - '" = "'
    - ~value
    - '{
         if (const modifiers_type* modifiers = n->modifiers_get())
           foreach (const modifiers_type::value_type& modifier, *modifiers)
           {
             ostr_ << " ";
             ostr_ << modifier.first << ": ";
             operator()(modifier.second.get());
           }
       }'

Declaration:
  super: Write
  printer:
    - '"var "'
    - '{ visit(static_cast<const ast::Write*>(n)); }'

Assignment:
  super: Write

OpAssignment:
  super: Write
  attributes:
    - op:
        type: 'libport::Symbol'
  printer:
    - ~what
    - '" "'
    - $op
    - '"= "'
    - ~value

Local:
  super: Exp
  attributes:
    - name:
        type: 'libport::Symbol'
        desc: Name of the local variable.
    - arguments:
        type: 'exps_type*'
        access: rwW
        mandatory: false
        desc: Arguments passed to the function
    - depth:
        type: unsigned
        access: rwW
        desc: How many contexts we have to rewind to find the actual value of the
              variable (thus 0 means this is an actual local variable).
    - declaration:
        type: rLocalDeclaration
        access: rwW
        init: '0'
  cloner_prologue: 'assert(!e->declaration_get());'
  inline:
    header inside: |2
      public:
        bool closed_get() const;
        unsigned local_index_get() const;
    impl inside: |2
      bool Local::closed_get() const
      {
        assert(declaration_);
        return declaration_->closed_get();
      }
      unsigned Local::local_index_get() const
      {
        assert(declaration_);
        return declaration_->local_index_get();
      }
  default: |2
    visit((typename Const<Exp>::type*) n);
    if (n->arguments_get())
    {
      foreach (libport::shared_ptr<typename Const<ast::Exp>::type> e, *n->arguments_get())
        operator()(e.get());
    }
  printer:
    - $name
    - '{
         if (n->arguments_get())
           ostr_
            << "("
            << libport::incindent
            << libport::separate(*n->arguments_get(), ", ")
            << libport::decindent
            << ")";
       }'

This:
  super: Exp
  printer:
    - '"this"'

CallMsg:
  super: Exp
  printer:
    - '"call"'

Binding:
  super: Exp
  attributes:
    - name:
        type: 'libport::Symbol'
        access: r
  printer:
    - '"var "'
    - $name

Unary:
  super: Exp
  desc: /// Expressions with a expression
  attributes:
    - exp:
        type: rLValue
        desc: Operand
        access: r

Incrementation:
  super: Unary
  printer:
    - ~exp
    - '"++"'

Decrementation:
  super: Unary
  printer:
    - ~exp
    - '"--"'

PropertyAction:
  super: Exp
  attributes:
    - owner:
        type: rCall
    - name:
        type: libport::Symbol
  printer:
    - ~owner
    - '"->"'
    - $name

PropertyWrite:
  super: PropertyAction
  attributes:
    - value:
        type: rExp
  printer:
    - '{ visit(static_cast<const PropertyAction*>(n)); }'
    - '" = "'
    - ~value

PropertyRead:
  super: PropertyAction

Delete:
  super: Exp
  attributes:
    - what:
        type: rLValue
  printer:
    - '"delete "'
    - ~what

MetaCall:
  super: LValueArgs
  attributes:
    - target:
        type: rExp
    - id:
        type: unsigned

Class:
  super: Exp
  attributes:
    - what:
        type: rLValue
        desc: Lvalue where to store the class
    - protos:
        type: 'exps_type*'
        mandatory: false
        desc: Prototypes
    - content:
        type: rNary
        desc: Class content
  printer:
    - '"class "'
    - ~what
    -  '{
          if (const exps_type* protos = n->protos_get())
          {
            ostr_ << ": ";
            (void) protos;
            ostr_ << libport::separate(*protos, ", ");
          }
        }'
    - 'libport::iendl'
    - '"{"'
    - 'libport::incendl'
    - ~content
    - 'libport::decendl'
    - '"}"'

Emit:
  super: Exp
  attributes:
    - event:
        type: rExp
        desc: The emitted event
    - arguments:
        type: exps_type*
        desc: Values carried by the event
        mandatory: false
    - duration:
        type: rExp
        desc: Duration of the emission
        mandatory: false
  printer:
    - '"emit "'
    - ~event
    -  '{
          if (const exps_type* args = n->arguments_get())
          {
            ostr_ << "(";
            ostr_ << libport::separate(*args, ", ");
            ostr_ << ")";
          }
        }'
    -  '{
          if (rConstExp duration = n->duration_get())
          {
            ostr_ << " ~ ";
            operator()(duration.get());
          }
        }'

# Local Variables:
# mode: yaml
# End:
