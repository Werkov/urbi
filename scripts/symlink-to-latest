#! /usr/bin/perl

# symlink-to-latest PACKAGE
# e.g.
# symlink-to-latest foo/urbi-sdk-2.0
# symlink-to-latest foo/urbi-sdk-2.0.3

## Install a symlink to the latest minor version.  I.e.
##
## urbi-sdk-2.0   -> urbi-sdk-2.0.x
## urbi-sdk-2.0.2 -> urbi-sdk-2.0.x.
##
## or even
##
## urbi-sdk/2.0   -> urbi-sdk/2.0.x
## urbi-sdk/2.0.2 -> urbi-sdk/2.0.x.
##
## Do that based on the versions that are available on the server, so
## that if we happen to install the documentation of 2.0.2 another
## time after 2.0.3's documentation, 2.0.x still properly points to
## 2.0.3, which is the latest.

sub verbose (@)
{
  for my $line (@_)
  {
    print STDERR "$0: $line\n";
  }
}

use File::Basename;

$minor = $ARGV[0];
verbose "argument: $minor";

$minor .= ".0" if $minor =~ m{^(?:.*[\-/])?\d+\.\d+$};
$minor =~ s/\.\d+$//;
verbose "minor: $minor";

# Set patterns that did not match to devnull (when there is only 2.1,
# "2.1.[0-9]*" will fail).
($latest = qx{ls -dvr $minor $minor.[0-9]* 2>/dev/null}) =~ s/\n.*//gm;
# When installing symlinks, the destination is relative to the
# location of the source.
$latest = basename $latest;
verbose "latest: $latest";
$link = "$minor.x";

# Don't use -e: it returns false if a symlink exists, but points to a
# non-existing file.
if (-l $link)
{
  unlink $link
    or die "unlink $link: $!";
}
verbose "symlinking $link -> $latest";
symlink $latest, $link
  or die "symlink $latest, $link: $!";
