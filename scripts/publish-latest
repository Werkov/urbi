#! /bin/sh -e

stderr ()
{
  local i
  for i
  do
    echo >&2 "$0: $i"
  done
}

error ()
{
  local sta=$1
  shift
  stderr "$@"
  exit $sta
}

fatal ()
{
  error 1 "$@"
}

usage ()
{
  cat <<EOF
usage: $0 [OPTIONS...] [RELEASE...]

Call this script when a release is to be publish to the download
site.  Don't forget to tag it if it is a release.

RELEASE can be specified (e.g., \`2.0-rc-1'), otherwise it is computed
automatically from the latest time stamp.

The packages to publish are looked for in:
  from=$from
The packages will be publish in:
  to=$to

Options:
  -h, --help        display this message and exit successfully
  -u, --user NAME   use NAME to log on gate [$login]
EOF
  exit 0
}
getargs ()
{
  while test $# -ne 0;
  do
    case $1 in
      (-h|--help) usage;;
      (-u|--user) shift; login=$1;;
      (-*) fatal "invalid option: $1";;
      (*) latest=$1;;
    esac
    shift
  done
}

# From an scp-like location, return the user.
# foo@bar.baz.com:my/path -> foo
scp_user ()
{
  echo "$1" | sed -e 's/@.*//'
}

# From an scp-like location, return the host name.
# foo@bar.baz.com:my/path -> bar.baz.com
scp_host ()
{
  echo "$1" | sed -e 's/.*@//;s/:.*//'
}

# From a scp-like location, return the path.
# foo@bar.baz.com:my/path -> my/path
scp_dir ()
{
  echo "$1" | sed -e 's/.*://'
}

# From a scp-like location, return the connection-point.
# foo@bar.baz.com:my/path -> foo@bar.baz.com
scp_point ()
{
  echo "$1" | sed -e 's/:.*//'
}



# The (scp-like) directory that contains the tarballs.
from=build@bf-1:share/built/kernel-2.0/archives

# The (scp-like) location into which the per-architecture directories are.
to=downloads@www.gostai.com:gostai.com-downloads/urbi-sdk-2.0

oses="windows linux macos"

getargs "$@"

# Get the content of the directory containing the latest successful builds:
# urbi-sdk-2.0-beta3-linux-x86.tar.gz
# urbi-sdk-2.0-beta3-macos-x86.tar.gz
# urbi-sdk-2.0-beta3-linux-x86-gcc4-debug_dynamic.tar.gz
# urbi-sdk-2.0-beta2-498-g4f7f361-windows-x86.zip
# urbi-sdk-2.0-beta2-498-g4f7f361-linux-x86-gcc4-debug_dynamic.tar.gz
# urbi-sdk-2.0-beta2-498-g4f7f361-linux-x86.tar.gz
# urbi-sdk-2.0-beta2-498-g4f7f361-macos-x86.tar.gz
all=$(ssh $(scp_point "$from") \
        "cd $(scp_dir "$from") && \
           ls -1t *linux*.gz *macos-*.gz *windows*.exe *windows*.zip")

# Make sure that we have the same version for the three architectures.
test -n "$latest" ||
  latest=$(echo "$all" |
      perl -n -e 'if (m/((:?kernel-2.0|urbi-(?:runtime|sdk))
                        -(?:beta|rc-)\d
                        (?:-\d+-g[\da-f]{7})?)
                        -(?:linux|macos|windows)
                        -(ARM|ppc|x86)
                        (?:-gcc4-debug_dynamic|vcxx200\d)?/x)
                  { print "$1\n"; exit 0; }')

test -n "$latest" ||
  fatal "cannot find latest version from:" $all

for os in $oses
do
  pack=$(echo "$all" | grep -e "$latest-$os" | grep -v 'debug' || true)
  test -n "$pack"||
    fatal "$latest does not exist for $os"
done

for os in $oses
do
  for pack in $(echo "$all" | grep -e "$latest-$os" | grep -v 'debug')
  do
    echo " --------------- $pack ---------------- "
    # For some reason, "scp A B" does not work, so
    # "scp A localhost && scp localhost B".
    cmd="scp \"$from/$pack\" /tmp/$pack &&
     scp /tmp/$pack $to/$os/$pack &&
     ssh $(scp_point "$to") 'chmod 640 $(scp_dir "$to")/$os/$pack'"
    stderr "$cmd"
    eval "$cmd"
  done
done
