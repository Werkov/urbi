#! /bin/sh
#

set -x
set -e

stderr ()
{
  local i
  for i
  do
    echo >&2 "$0: $i"
  done
}

error ()
{
  local status="$1"
  shift
  stderr "$@"
  exit $status
}

fatal ()
{
  error 1 "$@"
}

## ----------- ##
## Variables.  ##
## ----------- ##

: ${TMPDIR=/tmp}

case $# in
  (10);;
  (*) fatal "not enough arguments: $#, expecting 10";;
esac

PROJECT='@PACKAGE_TARNAME@'
PACKAGE_VERSION='@PACKAGE_VERSION@'
URBI_HOST_COMP='@URBI_HOST_COMP@'
URBI_HOST_CPU='@URBI_HOST_CPU@'
URBI_HOST_OS='@URBI_HOST_OS@'
abs_top_builddir='@abs_top_builddir@'
abs_top_srcdir='@abs_top_srcdir@'
buildprefix='@prefix@'
host='@host@'
COMPILATION_MODE_DEBUG='@COMPILATION_MODE_DEBUG@'
if $COMPILATION_MODE_DEBUG; then
  COMPILATION_MODE_RELEASE=false
else
  COMPILATION_MODE_RELEASE=true
fi

srcdir=$2
builddir=$3
DESTDIR=$4
# Directories/tarballs left in this directory (updir) will be
# published by the buildfarm's package script.
updir=$5
ARCH=$6       # ARM|ppc|x86|x86_64.
OS=$7         # linux|macos|windows.
COMP=$8       # ex. gcc4, vcxx2005.
MODE=$9       # [release|debug]_[static|dynamic].
prefix=${10}
# Set release_mode depending on whether we are building a release version
# or a development version.
case $MODE in
  (release*)    release_mode=true;;
  (*)           release_mode=false;;
esac

check_equal ()
{
  local lhs
  local rhs
  eval "lhs=\$$1"
  eval "rhs=\$$2"
  if test "$lhs" != "$rhs"; then
    stderr "*******************"                \
           "$1 != $2"                           \
           "($lhs != $rhs)"                     \
           "proceeding with $1 = $rhs"
    eval "$1=\$$2"
  fi
}

# tree_copy SOURCE DEST
# ---------------------
# Copy a file-system tree from SOURCE to DEST.  Preserve rights etc.
# DEST is cleared first.
tree_copy ()
{
  local source=$1
  local dest=$2
  rm -rf "$dest"
  mkdir -p "$dest"
  tar -C "$source" -cf - . | tar -C "$dest" -xpBf -
}

check_equal ARCH         URBI_HOST_CPU
check_equal COMP         URBI_HOST_COMP
# check_equal OS           URBI_HOST_OS
check_equal builddir     abs_top_builddir
check_equal prefix       buildprefix
check_equal release_mode COMPILATION_MODE_RELEASE
check_equal srcdir       abs_top_srcdir

# OS and URBI_HOST_OS.
#
# OS might be different from URBI_HOST_OS.  For instance
# URBI_HOST_OS=linux, but OS=linux-bleeding-edge.  If we drop the
# bleeding-edge part, we will make bleeding-edge tarballs not labeled
# as such, so we might ship bleeding-edge tarballs instead of the old
# Debian etch.
#
# Don't accept - in the OS.
OS=$(echo "$OS" | sed -e 's/-/_/g')
# bleeding-edge actually means Ubuntu Lucid.
OS=$(echo "$OS" | sed -e 's/bleeding_edge/lucid/g')
# and actually, the debug package is made on lucid too.
if $COMPILATION_MODE_DEBUG; then
  COMPILATION_MODE_RELEASE=false
else
  COMPILATION_MODE_RELEASE=true
fi

srcdir=$2
builddir=$3
DESTDIR=$4
# Directories/tarballs left in this directory (updir) will be
# published by the buildfarm's package script.
updir=$5
ARCH=$6       # ARM|ppc|x86|x86_64.
OS=$7         # linux|macos|windows.
COMP=$8       # ex. gcc4, vcxx2005.
MODE=$9       # [release|debug]_[static|dynamic].
prefix=${10}
# Set release_mode depending on whether we are building a release version
# or a development version.
case $MODE in
  (release*)    release_mode=true;;
  (*)           release_mode=false;;
esac

check_equal ()
{
  local lhs
  local rhs
  eval "lhs=\$$1"
  eval "rhs=\$$2"
  if test "$lhs" != "$rhs"; then
    stderr "*******************"                \
           "$1 != $2"                           \
           "($lhs != $rhs)"                     \
           "proceeding with $1 = $rhs"
    eval "$1=\$$2"
  fi
}

# tree_copy SOURCE DEST
# ---------------------
# Copy a file-system tree from SOURCE to DEST.  Preserve rights etc.
# DEST is cleared first.
tree_copy ()
{
  local source=$1
  local dest=$2
  rm -rf "$dest"
  mkdir -p "$dest"
  tar -C "$source" -cf - . | tar -C "$dest" -xpBf -
}

check_equal ARCH         URBI_HOST_CPU
check_equal COMP         URBI_HOST_COMP
# check_equal OS           URBI_HOST_OS
check_equal builddir     abs_top_builddir
check_equal prefix       buildprefix
check_equal release_mode COMPILATION_MODE_RELEASE
check_equal srcdir       abs_top_srcdir

# OS and URBI_HOST_OS.
#
# OS might be different from URBI_HOST_OS.  For instance
# URBI_HOST_OS=linux, but OS=linux-bleeding-edge.  If we drop the
# bleeding-edge part, we will make bleeding-edge tarballs not labeled
# as such, so we might ship bleeding-edge tarballs instead of the old
# Debian etch.
#
# Don't accept - in the OS.
OS=$(echo "$OS" | sed -e 's/-/_/g')
# bleeding-edge actually means Ubuntu Lucid.
OS=$(echo "$OS" | sed -e 's/bleeding_edge/lucid/g')
# and actually, the debug package is made on lucid too.
case $OS:$COMPILATION_MODE_DEBUG in
  (linux:true) OS="${OS}_lucid";;
esac
if test "$OS" = "$URBI_HOST_OS"; then
  stderr "OS = URBI_HOST_OS = $OS"
else
  stderr "OS = $OS" "URBI_HOST_OS = $URBI_HOST_OS" \
         "proceeding with $OS"
  URBI_HOST_OS=$OS
fi


# Determine the version from the latest component of the tag. This will
# ease ordering.
version=$(cd "$srcdir" && git describe | sed -e "s,^preview/,,;s,/,-,g")
# If we are in release mode, do not tell it, the final users won't care.
# Otherwise, add "-debug".
configuration=$version-$URBI_HOST_OS-$URBI_HOST_CPU-$URBI_HOST_COMP
$release_mode || configuration=$configuration-$MODE

# The SDK package.
urbi_sdk=$PROJECT-$configuration
# The doc only package.
urbi_doc=${PROJECT%-sdk}-doc-$version
# The SDK package, without the doc.
urbi_sdk_no_doc=$urbi_sdk-no-doc
# The runtime package, i.e., without doc etc.
urbi_runtime=$(echo "$urbi_sdk" | sed -e 's/urbi-sdk/urbi-runtime/')

# Primary target.
name=$urbi_sdk

# 1. Documentation.
#
# If the documentation is compiled in this package, extract it as a
# separate directory.
#
# If the doc is not compiled in, then if a doc package is available,
# inline its contents in this package.  Otherwise make a package
# without the doc, but with a name that states it.
docsrc="$DESTDIR$prefix/share/doc/urbi-sdk"
if test -f "$docsrc/urbi-sdk.pdf"; then
  stderr "Documentation is compiled, shipping"
  tree_copy "$docsrc" "$updir/$urbi_doc"
else
  stderr "Documentation is NOT compiled, looking for it in $archivedir"
  if test -f "$archivedir/$urbi_doc.tar.bz2"; then
    stderr "Documentation found, installing"
    rm -rf "$docsrc"
    tar -C "$(dirname $docsrc)" -xf "$archivedir/$urbi_doc.tar.bz2"
    mv "$(dirname $docsrc)/$urbi_doc" "$docsrc"
    # So remove the one without doc if there is one.
    rm -f "$archivedir/$urbi_sdk_no_doc".*
  else
    # We couldn't find the doc, and it's not our job to compile it.
    # So, instead of blocking the generation of packages, generate
    # packages without the doc, but make it clear in the tarball name.
    stderr "Documentation NOT found"
    name=$urbi_sdk_no_doc
  fi
fi

# 2. Prebuilt-Urbi SDK.
#
# Create a fresh directory in which we put the subdirectories of the
# $install directory.
tree_copy "$DESTDIR$prefix" "$updir/$name"

# 3. Description.
#
# Extract the file that describes the contents of the package.
cp "$docsrc/COMPONENTS.txt" "$updir/$urbi_sdk.txt"

# 4. Prebuilt-Urbi Runtime.
#
# Create a run-time version of the package.
packagedir="$updir/$urbi_runtime"
tree_copy "$DESTDIR$prefix" "$packagedir"
# Keep only the bin, lib, and share/urbi directories.  Don't forget
# bin is lib on Windows.  Leave LICENSE.txt since it is used by
# Lobby.license.
(cd "$packagedir" &&
    rm -rf README.txt include libexec share/doc)

# 5. Source tarball.
tarname=$PROJECT-$version.tar.bz2
if test -f $abs_top_builddir/$tarname; then
  cp -v $abs_top_builddir/$tarname $updir/$tarname.tmp
  mv $updir/$tarname.tmp $updir/$tarname
fi
