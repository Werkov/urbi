#! /bin/sh
#

set -x
set -e

stderr ()
{
  local i
  for i
  do
    echo >&2 "$0: $i"
  done
}

error ()
{
  local status=$1
  shift
  stderr "$@"
  exit $status
}

# If some of those need to be chosen by configure, add an entry
# there and add the "@" form.
: ${CP=cp}
: ${FIND=find}
: ${GIT=git}
: ${MKDIR_P="mkdir -p"}
: ${MV=mv}
: ${RM="rm -f"}
: ${SED="sed"}
: ${TAR=tar}

: ${TMPDIR=/tmp}

case $# in
  (10);;
  (*) error 1 "not enough arguments: $#, expecting 10";;
esac

# Those would best be set through configure (except "updir"
# which sets the destination).

# Baby does not want to change the $1 passed to this script.  Let him
# play with the poo poo in his diapers while we work :)
PROJECT='@PACKAGE_TARNAME@'
srcdir=$2
builddir=$3
DESTDIR=$4
updir=$5
ARCH=$6       # ex. x86
OS=$7         # ex. linux
COMP=$8       # ex. gcc4
MODE=$9       # [release|debug]_[static|dynamic]
prefix=${10}

# Set release_mode depending on whether we are building a release version
# or a development version.
case $MODE in
  (release_dynamic) release_mode=true;;
  (*)               release_mode=false;;
esac

# Determine the version from the latest component of the tag. This will
# ease ordering.
version=$(cd "$srcdir" && $GIT describe | $SED -e "s,^preview/,,;s,/,-,g")
# If we are in release mode, do not tell it, the final users won't care
if $release_mode; then
  name="$PROJECT-$version-$OS-$ARCH-$COMP"
else
  name="$PROJECT-$version-$OS-$ARCH-$COMP-$MODE"
fi
packagedir="$updir/$name"

# Create a fresh directory in which we put the subdirectories of the
# $install directory.
$RM -r "$packagedir"
$MKDIR_P "$packagedir"
(cd "$DESTDIR$prefix" && $TAR cf - .) | (cd "$packagedir" && $TAR xpBf -)

# Build a MANIFEST with the list of files to install into the final
# destination.
MANIFEST="$TMPDIR/MANIFEST.tmp.$$"
(cd "$packagedir" && $FIND . -type f -print | $SED -e "s,^./,,") > "$MANIFEST"
$MV "$MANIFEST" "$packagedir/MANIFEST"

# Copy the instructions at the top-level
for i in {LICENSE,README,RELEASE-NOTES,REPORTING-BUGS}.txt
do
  case $OS in
    (windows)
      $CP "$srcdir/doc/$i" "$packagedir/doc/$i"
      unix2dos "$packagedir/doc/$i";;
    (*)
      (cd "$packagedir" && ln -s "share/doc/urbi-sdk/$i");;
  esac
done

# Fix libtool usage of +=.
targetline='eval "$1=\\"\\\$\$1 $2\\""'
$FIND $packagedir -name libtool -exec sh -c  " sed -r -e 's/^.*eval.*\+=.*$/$targetline/' {} > {}.new && mv {}.new {}" ';'

# Remove -nostdlib and explicit stdlib from libtool
# The resulting libtool may not work, but it is not working without patch anyway...
$FIND $packagedir -name libtool -exec sh -c  " sed -e 's/^predep_objects=.*/predep_objects=/' -e 's/postdep_objects=.*/postdep_objects=/' -e 's/-nostdlib//g'  {} > {}.new && mv {}.new {}" ';'

# Remove cccache from the param.mk. No perl, no sed -i.
$FIND $packagedir '(' -name param.mk -or -name libtool ')' -exec sh -c  " sed -e 's/ccache //' {} > {}.new && mv {}.new {}" ';'


#restore +x on libtool
$FIND $packagedir -name libtool -exec chmod u+x '{}' ';'

#set more permissive access rights
chmod a+rX -R $packagedir

# When building a release for non-Windows platforms, strip the binaries
# and the libraries.
if $release_mode && [ "$OS" != windows ]; then
  (cd "$packagedir"
   # Do not show errors -- we know that we have shell scripts there.
   $FIND bin -type f -print | xargs strip 2> /dev/null || true
   $FIND . -type f -name '*.so.*' -print | xargs strip || true
   $FIND . -type f -name '*.a' -print | xargs strip || true)
fi

# On Windows, copy the .bat file
case $OS in
  (windows) unix2dos "$builddir/scripts/urbi.bat" "$packagedir";;
esac
