#! /bin/sh
#

set -x
set -e

stderr ()
{
  local i
  for i
  do
    echo >&2 "$0: $i"
  done
}

error ()
{
  local status=$1
  shift
  stderr "$@"
  exit $status
}

# If some of those need to be chosen by configure, add an entry
# there and add the "@" form.
: ${CP=cp}
: ${FIND=find}
: ${GIT=git}
: ${MKDIR_P="mkdir -p"}
: ${MV=mv}
: ${RM="rm -f"}
: ${SED="sed"}
: ${TAR=tar}

: ${TMPDIR=/tmp}

case $# in
  (10);;
  (*) error 1 "not enough arguments: $#, expecting 10";;
esac

# Those would best be set through configure (except "updir"
# which sets the destination).

# Baby does not want to change the $1 passed to this script.  Let him
# play with the poo poo in his diapers while we work :)
PROJECT='@PACKAGE_TARNAME@'
srcdir=$2
builddir=$3
DESTDIR=$4
updir=$5
ARCH=$6       # ex. x86
OS=$7         # ex. linux
COMP=$8       # ex. gcc4
MODE=$9       # [release|debug]_[static|dynamic]
prefix=${10}

# Set release_mode depending on whether we are building a release version
# or a development version.
case $MODE in
  (release_dynamic) release_mode=true;;
  (*)               release_mode=false;;
esac

# Determine the version from the latest component of the tag. This will
# ease ordering.
version=$(cd "$srcdir" && $GIT describe | $SED -e "s,^preview/,,;s,/,-,g")
# If we are in release mode, do not tell it, the final users won't care
if $release_mode; then
  name="$PROJECT-$version-$OS-$ARCH-$COMP"
else
  name="$PROJECT-$version-$OS-$ARCH-$COMP-$MODE"
fi
packagedir="$updir/$name"

# Create a fresh directory in which we put the subdirectories of the
# $install directory.
$RM -r "$packagedir"
$MKDIR_P "$packagedir"
(cd "$DESTDIR$prefix" && $TAR cf - .) | (cd "$packagedir" && $TAR xpBf -)

# Build a MANIFEST with the list of files to install into the final
# destination.
MANIFEST="$TMPDIR/MANIFEST.tmp.$$"
(cd "$packagedir" && $FIND . -type f -print | $SED -e "s,^./,,") > "$MANIFEST"
$MV "$MANIFEST" "$packagedir/MANIFEST"

# Copy the instructions at the top-level.
here=$(pwd)
cd $packagedir
for i in share/doc/urbi-sdk/*.txt
do
  case $OS in
    (windows)
      unix2dos "$i"
      $CP "$i" .
      ;;
    (*)
      ln -s "$i"
      ;;
  esac
done
cd $here

# 1. Fix libtool usage of +=.
# 2. Remove -nostdlib and explicit stdlib from libtool The resulting
# libtool may not work, but it is not working without patch anyway...
$FIND $packagedir -name libtool |
  xargs perl -pi                                                        \
       -e 's/^\s*eval "\$1\+=\\\$2"$/eval "\$1=\\\$\$1\\" \$2\\""/;'    \
       -e 's/^predep_objects=.*/#- $&/;'                                \
       -e 's/postdep_objects=.*/#- $&/;'                                \
       -e 's/-nostdlib//g;'

# Remove ccache  and -Werror from the param.mk and libtool.
$FIND $packagedir '(' -name param.mk -or -name libtool ')' |
  xargs perl -pi -e 's/ccache //;' -e 's/-Werror//;'

# Restore +x on libtool.
$FIND $packagedir -name libtool -exec chmod u+x '{}' ';'

# Set more permissive access rights.
chmod -R a+rX $packagedir

case $OS in
  (windows)
    # On Windows, copy the .bat file.
    $CP "$builddir/scripts/urbi.bat" "$packagedir"
    unix2dos "$packagedir/urbi.bat"
    ;;
  (*)
    # When building a release for non-Windows platforms, strip the
    # binaries and the libraries.
    if $release_mode; then
      here=$(pwd)
      cd "$packagedir"
      # Do not show errors -- we know that we have shell scripts there.
      $FIND bin -type f |
        xargs strip 2>/dev/null || true
      $FIND . -type f '(' -name '*.so.*' -o -name '*.a' ')' |
        xargs strip || true
      cd $here
    fi
    ;;
esac
