#! /bin/sh
#

set -x
set -e

stderr ()
{
  local i
  for i
  do
    echo >&2 "$0: $i"
  done
}

complain ()
{
  stderr "$@"
  errors=$((errors + 1))
}

error ()
{
  local status="$1"
  shift
  stderr "$@"
  exit $status
}

fatal ()
{
  error 1 "$@"
}

# If some of those need to be chosen by configure, add an entry
# there and add the "@" form.
: ${CP=cp}
: ${FIND=find}
: ${GIT=git}
: ${MKDIR_P="mkdir -p"}
: ${MV=mv}
: ${RM="rm -f"}
: ${SED="sed"}
: ${TAR=tar}

: ${TMPDIR=/tmp}

case $# in
  (10);;
  (*) fatal "not enough arguments: $#, expecting 10";;
esac

# Those would best be set through configure (except "updir"
# which sets the destination).

# Baby does not want to change the $1 passed to this script.  Let him
# play with the poo poo in his diapers while we work :)
PROJECT='@PACKAGE_TARNAME@'
srcdir=$2
builddir=$3
DESTDIR=$4
updir=$5
ARCH=$6       # ARM|x86|ppc
OS=$7         # linux|windows|macos
COMP=$8       # ex. gcc4
MODE=$9       # [release|debug]_[static|dynamic]
prefix=${10}

# Set release_mode depending on whether we are building a release version
# or a development version.
case $MODE in
  (release*)    release_mode=true;;
  (*)           release_mode=false;;
esac

# Determine the version from the latest component of the tag. This will
# ease ordering.
version=$(cd "$srcdir" && $GIT describe | $SED -e "s,^preview/,,;s,/,-,g")
# If we are in release mode, do not tell it, the final users won't care
if $release_mode; then
  name="$PROJECT-$version-$OS-$ARCH-$COMP"
else
  name="$PROJECT-$version-$OS-$ARCH-$COMP-$MODE"
fi
packagedir="$updir/$name"

# Create a fresh directory in which we put the subdirectories of the
# $install directory.
$RM -r "$packagedir"
$MKDIR_P "$packagedir"
(cd "$DESTDIR$prefix" && $TAR cf - .) | (cd "$packagedir" && $TAR xpBf -)

# Host and build machines.
build=$($SED -ne '/^build = /{s///;p;q;}' $builddir/Makefile)
host=$( $SED -ne '/^host = /{s///;p;q;}' $builddir/Makefile)
stderr "build=$build" "host=$host"

# Install the boost headers.
# First we must figure out where they are. If they were found in a standard
# include directory, no variable will tell us that.
# So go the configure way and ask the compiler.
BOOST_FIND_FILE="utils/find-boost.ii"
make -C  $builddir/sdk-remote/src "$BOOST_FIND_FILE"
incline=$(perl -n \
            -e 'if (/^#.*"(.*).foreach.hpp"/)
                {
                  print "$1\n";
                  exit 0;
                }' "$builddir/sdk-remote/src/$BOOST_FIND_FILE"
)
case $build:$host in
  (*cygwin:*) incline=$(cygpath  -u "$incline");;
  (*:*mingw32) incline=$(winepath -u "$incline");;
esac
# Ensure we got it right.
if test ! -f  $incline/version.hpp; then
  fatal "failed to find boost include directory, got '$incline'"
fi

$CP -pRP $incline $packagedir/include


# Build a MANIFEST with the list of files to install into the final
# destination.
MANIFEST="$TMPDIR/MANIFEST.tmp.$$"
(cd "$packagedir" && $FIND . -type f -print | $SED -e "s,^./,,") > "$MANIFEST"
$MV "$MANIFEST" "$packagedir/MANIFEST"

# Copy the instructions at the top-level.
here=$(pwd)
cd $packagedir
for i in share/doc/urbi-sdk/*.txt
do
  case $OS in
    (windows)
      unix2dos "$i"
      $CP "$i" .
      ;;
    (*)
      ln -s "$i"
      ;;
  esac
done
cd $here

# 1. Fix libtool usage of +=.
# 2. Remove -nostdlib and explicit stdlib from libtool The resulting
# libtool may not work, but it is not working without patch anyway...
$FIND $packagedir -name libtool |
  xargs perl -pi                                                        \
       -e 's/^\s*eval "\$1\+=\\\$2"$/eval "\$1=\\\$\$1\\" \$2\\""/;'    \
       -e 's/^predep_objects=.*/#- $&/;'                                \
       -e 's/postdep_objects=.*/#- $&/;'                                \
       -e 's/-nostdlib//g;'

# Remove ccache and -Werror from the param.mk and libtool.
# Remove also hidden visibility as it prevents linking uobjects using
# boost symbols inside libport.
$FIND $packagedir '(' -name param.mk -or -name libtool ')' |
  xargs perl -pi \
        -e 's/ccache //;'                       \
        -e 's/g(cc|\+\+)(?:-[\d.]+)/g$1/;'      \
        -e 's/-Werror//;'                       \
        -e 's/-fvisibility=hidden//;'           \
        -e 's/-fvisibility-inlines-hidden//;'

# Restore +x on libtool.
$FIND $packagedir -name libtool -exec chmod u+x '{}' ';'

# Set more permissive access rights.
chmod -R a+rX $packagedir

case $OS in
  (windows)
    # On Windows, copy the .bat file.
    $CP "$builddir/scripts/urbi.bat" "$packagedir"
    unix2dos "$packagedir/urbi.bat"
    ;;
  (*)
    # When building a release for non-Windows platforms, strip the
    # binaries and the libraries.
    if $release_mode; then
      here=$(pwd)
      cd "$packagedir"
      # Do not show errors -- we know that we have shell scripts there.
      $FIND bin -type f |
        xargs strip 2>/dev/null || true
      $FIND . -type f '(' -name '*.so.*'        \
                       -o -name '*.so'          \
                       -o -name '*.dylib'       \
                       -o -name '*.a'           \
                       ')' |
        xargs strip || true
      cd $here
    fi
    ;;
esac

# Check that we don't depend on boost.  Or rather, check that we don't
# have invalid locations.
case $OS in
  (linux)
    $(dirname $0)/check-lib-deps  \
      $($FIND . -type f '(' -name '*.so.*' -o -name '*.so')
    ;;
  (macos)
    for i in $($FIND . -type f '(' -name '*.dylib' ')')
    do
      if otool -L $i | grep -q -i boost; then
        complain "$i depends on Boost" $(otool -L $i | grep -q -i boost)
      fi
    done
    ;;
esac

if test $errors -ne 0; then
  fatal "there were $errors errors."
fi
