#! /usr/bin/perl -w

use Cwd;            # realpath
use English;        # $OSNAME
use File::Basename;
use File::Find ();
use IO::File;
use strict;

=head1 NAME

  check-lib-deps - handle shared-lib dependencies

=head1 SYNOPSIS

  check-lib-deps [OPTIONS...] DIR...

=head1 DESCRIPTION

Traverse all the DIR... and relocate, when possible, shared-library
dependencies.  It works in two steps: first all the dependencies of
executables and shared libs are gathered.  Second, dependencies that
are met inside the DESTDIR itself are made relative instead of
absolute.  As a last step, absolute dependencies that remain are
checked for validity.

Exit with failure if invalid dependencies remain.

For interesting input on this topic, see:

  RPATH/RUNPATH issue, equivalent to -headerpad on OSX
    http://sourceware.org/ml/binutils/2008-01/msg00021.html

=head1 OPTIONS

General options:

=over 4

=item B<-h>, B<--help>

Display this message and exit.

=item B<-d>, B<--destdir>=I<destdir>

Specify the installation destination directory.  Anything found under
this directory is considered to be part of it.  Anything else is a
foreign dependency.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

=head1 FUNCTIONS

=over 4

=cut

# The dependencies that are inside our package.  A simple set (i.e.,
# the value is always 1).  The keys are *without* destdir.  So use
# &installname before to check existence inside %argv.
my %argv;

# The list of files to check.
my @checked;

# The place the installation was made.
my $destdir;

# Accepted resolved libraries.
my %loc;

# Number of errors.
my $nerrors = 0;

# Verbosity level.
my $verbose = 1;

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  map { print STDERR "$0: " . "  " x $level . "$_\n" } @message
    if $level <= $verbose;
}

# Return the list of paths we depend upon.
sub dependencies ($)
{
  my ($lib) = @_;
  verbose 3, "dependencies($lib)";
  my @res;
  if ($OSNAME eq 'darwin')
    {
      my $deps = new IO::File("otool -L $lib|")
        or die "$0: cannot read otool -L $lib: $!";
      while (my $line = $deps->getline)
        {
          chomp $line;
          if ($line =~ /^\t(.*?)\s+\(.*\)$/)
            {
              # On OS X, a library appears to depend on itself.
              push @res, $1
                unless $1 eq installname($lib);
            }
          else
            {
              verbose 2, "ignoring $line";
            }
        }
    }
  else
    {
      my $ldd = new IO::File("ldd $lib|")
        or die "$0: cannot read ldd $lib: $!";
      while (my $line = $ldd->getline)
        {
          chomp $line;
          if ($line =~ /^\t(.*?)\s+=>\s(.*?)\s\(.*\)$/
              || $line =~ /^\t(.*?)\s+=>\s(not found)$/)
            {
              my ($dep, $loc) = ($1, $2);
              push @res, $loc
                if $loc;
            }
        }
    }
  verbose 2, "$lib depends on", map { "  $_" } @res;
  @res;
}


sub xsystem (@)
{
  my (@args) = @_;

  verbose 2, "Running: @args";
  system(@args) == 0
    or die "$0: system @args failed: $?";
  if ($? == -1)
    {
      die "$0: failed to execute: $!\n";
    }
  elsif ($? & 127)
    {
      die sprintf ("$0: child died with signal %d, %s coredump\n",
                   ($? & 127),  ($? & 128) ? 'with' : 'without');
    }
  elsif ($? >> 8)
    {
      die sprintf "$0: child exited with value %d\n", $? >> 8;
    }
}

=item C<installname($file)>

Return the name in the install tree.

Make it absolute, and cut the $DESTDIR.  We use realpath instead of
rel2abs, because the latter does not work when converting a $ORIGIN
dependencies to an absolute path: it keeps all the "../.."  bits which
make it uselessly hard for us to check whether a given dependency is
within our package or not.

=cut

sub installname ($)
{
  my ($file) = @_;
  my $res = Cwd::realpath($file);
  $res =~ s/$destdir//;
  $res;
}

=item C<relocate($lib)>

Turn absolute dependencies within the package into relative rpaths.

=cut

sub relocate ($)
{
  my ($lib) = @_;
  my $dir = dirname(installname($lib));
  verbose 3, "relocate($lib) @ $dir";

  # On OS X, look for all the dependencies that are inside our
  # DESTDIR, and make then relative.  It works at the level of each
  # library.
  if ($OSNAME eq 'darwin')
    {
      for my $dep (grep {exists $argv{$_}} dependencies($lib))
        {
          my $rel = File::Spec->abs2rel($dep, $dir);
          xsystem("install_name_tool",
                  "-change", $dep, "\@loader_path/$rel",
                  $lib);
        }
    }

  # On GNU/Linux, change the rpaths.  I.e., when we depend on an rpath
  # which inside the package, make it relative.  It works at the level
  # of directories, not libraries.  We use chrpath for two things: to
  # get the list of current RPATH, and to change them.
  elsif ($OSNAME eq 'linux')
    {
      my $rpath = qx(chrpath -l $lib);
      if ($?)
        {
          warn "$0: chrpath -l $lib failed: $?";
        }
      else
        {
          chomp $rpath;
          $rpath =~ s/.*RPATH=//;
          my @rpath;
          for my $dep (split (":", $rpath))
            {
              # FIXME: hardcoded!!!
              my $rel =
                ($dep =~ m(gostai)
                 ? File::Spec->catdir('$ORIGIN',
                                      File::Spec->abs2rel($dep, $dir))
                 : $dep);
              verbose 3, "$dep => $rel"
                if $dep ne $rel;
              push @rpath, $rel;
            }
          my $newrpath = join (":", @rpath);
          xsystem("chrpath", "-r", $newrpath, $lib)
            if $newrpath ne $rpath;
        }
    }
}

sub check($)
{
  my ($lib) = @_;
  verbose 3, "check($lib)";

  my @valid =
    # On OS X, the relative rpath dependencies are reported
    # with a relative path starting with @loader_path.
    $OSNAME eq 'darwin' ? qw(@loader_path/ /usr/lib/ /opt/local/lib/)
    # On GNU/Linux, the related rpath dependencies are resolved and
    # made absolute.  Accept them only if they are inside our package.
    : $OSNAME eq 'linux' ? qw($destdir /lib/ /usr/lib/gcc/ /usr/lib/libstdc++)
    : ();

  my $re = "^(?:" . join("|", map (quotemeta, @valid)) . ")";
  for my $loc (dependencies($lib))
    {
      if ($loc =~ m($re))
        {
          $loc{$loc} = 1;
        }
      else
        {
          print STDERR "$0: error: $lib depends on $loc\n";
          ++$nerrors;
        }
    }
}

=item C<help>

Generate the B<--help> message.  Generates the full man page when
C<$verbose>.

=cut

sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Relocate shlib deps when possible, check remaing deps",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "d|destdir=s"   => \$destdir,
    "h|help"        => sub { help ($verbose) },
    "q|quiet"       => sub { --$verbose },
    "v|verbose"     => sub { ++$verbose },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;

  die "$0: passing --destdir is mandatory\n"
    unless defined $destdir;

  # DESTDIR must not end with slashes.
  $destdir =~ s,/+$,,g;
}

sub wanted
{
  # We check the shared lib dependencies on binaries and on shared
  # libraries.
  my $re =
    (
     $^O eq 'darwin'
     ? qr{\.(dylib|so)\z}s # Our UObjects are *.so.
     : qr{\.so(\..*)?\z}s
    );
  if (-f $_
      && (-x $_ || /$re/))
    {
      # We are not interested in plain files.
      my $res = `file $_`;
      push @checked, $File::Find::name
        if $res !~ /shell script|ASCII English text/;
    }
}

######################################################################

## ------ ##
## Main.  ##
## ------ ##

getopt;
File::Find::find({wanted => \&wanted}, @ARGV);
map {$argv{installname($_)} = 1} @checked;
verbose 2, "Shipped deps:", map { "  $_" } sort keys %argv;
map
  {
    my $lib = $_;
    relocate($lib);
    check($lib);
  }
  @checked;

verbose 1, "Accepted dependencies:", map { "  $_" } sort keys %loc;
verbose 1, "There were $nerrors errors";
exit !$nerrors;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
