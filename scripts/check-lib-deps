#! /usr/bin/perl -w

use Cwd;            # realpath
use English;        # $OSNAME
use File::Basename;
use File::Find ();
use IO::File;
use strict;

=head1 NAME

  check-lib-deps - handle shared-lib dependencies

=head1 SYNOPSIS

  check-lib-deps [OPTIONS...] DIR...

=head1 DESCRIPTION

Traverse all the DIR... and relocate, when possible, shared-library
dependencies.  It works in two steps: first all the dependencies of
executables and shared libs are gathered.  Second, dependencies that
are met inside the DESTDIR itself are made relative instead of
absolute.  As a last step, absolute dependencies that remain are
checked for validity.

Exit with failure if invalid dependencies remain.

For interesting input on this topic, see:

  RPATH/RUNPATH issue, equivalent to -headerpad on OSX
    http://sourceware.org/ml/binutils/2008-01/msg00021.html

To change the RPATH, we use either patchelf or chrpath.  The former is
preferred, as it has no limitations on the size of the new rpath,
while the latter requires that the new rpath is no longer than the
original one.

=head1 OPTIONS

General options:

=over 4

=item B<-h>, B<--help>

Display this message and exit.

=item B<-d>, B<--destdir>=I<destdir>

Specify the installation destination directory.  Anything found under
this directory is considered to be part of it.  Anything else is a
foreign dependency.

=item B<-p>, B<--prefix>=I<prefix>

Prefix into which the package is installed.  This is used under
GNU/Linux to change the RPATH.  Any RPATH component that is prefixed
by C<$prefix> will be made relative.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

=head1 FUNCTIONS

=over 4

=cut

# The dependencies that are inside our package.  A simple set (i.e.,
# the value is always 1).  The keys are *without* destdir.  So use
# &installname before to check existence inside %argv.
my %argv;

# The list of files to check.
my @checked;

# The tool to get and set the rpath.  Patchelf is preferred, it does
# not have any limitations on the size of the new rpath.
my $chrpath;

# The place the installation was made.
my $destdir;

# Accepted resolved libraries.
my %loc;

# The prefix for the log messages.
my $me = basename($0);

# Number of errors.
my $nerrors = 0;

# The --prefix given to configure.
my $prefix;

# Verbosity level.
my $verbose = 1;

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  map { print STDERR "$me: " . "  " x $level . "$_\n" } @message
    if $level <= $verbose;
}

=item C<prefix($prefix, $string)>

Whether C<$prefix> is a prefix of C<$string>.

=cut

sub prefix($$)
{
  my ($lhs, $rhs) = @_;
  my $sub = substr ($rhs, 0, length($lhs));
  $sub eq $lhs ? 1 : 0;
}


# Return the list of paths we depend upon.
sub dependencies ($)
{
  my ($lib) = @_;
  verbose 3, "dependencies($lib)";
  my @res;
  if ($OSNAME eq 'darwin')
    {
      my $deps = new IO::File("otool -L $lib|")
        or die "$me: cannot read otool -L $lib: $!\n";
      while (my $line = $deps->getline)
        {
          chomp $line;
          if ($line eq "$lib:")
            {
              # Ignore silently.
            }
          elsif ($line =~ /^\t(.*?)\s+\(.*\)$/)
            {
              # On OS X, a library appears to depend on itself.
              push @res, $1
                unless $1 eq installname($lib);
            }
          else
            {
              verbose 2, "ignoring the following otool output line:", $line;
            }
        }
    }
  else
    {
      my $ldd = new IO::File("ldd $lib|")
        or die "$me: cannot read ldd $lib: $!\n";
      while (my $line = $ldd->getline)
        {
          chomp $line;
          if ($line =~ /^\t(.*?)\s+=>\s(.*?)\s\(.*\)$/
              || $line =~ /^\t(.*?)\s+=>\s(not found)$/)
            {
              my ($dep, $loc) = ($1, $2);
              push @res, $loc
                if $loc;
            }
          else
            {
              verbose 2, "ignoring the following ldd output line:", $line;
            }
        }
    }
  verbose 2, "$lib depends on", map { "  $_" } @res;
  @res;
}


sub xsystem (@)
{
  my (@args) = @_;

  verbose 2, "running: @args";
  system(@args) == 0
    or die "$me: system @args failed: $?\n";
  if ($? == -1)
    {
      die "$me: failed to execute: $!\n";
    }
  elsif ($? & 127)
    {
      die sprintf ("$me: child died with signal %d, %s coredump\n",
                   ($? & 127),  ($? & 128) ? 'with' : 'without');
    }
  elsif ($? >> 8)
    {
      die sprintf "$me: child exited with value %d\n", $? >> 8;
    }
}

=item C<installname($file)>

Return the name in the install tree.

Make it absolute, and cut the $DESTDIR.  We use realpath instead of
rel2abs, because the latter does not work when converting a $ORIGIN
dependencies to an absolute path: it keeps all the "../.."  bits which
make it uselessly hard for us to check whether a given dependency is
within our package or not.

=cut

sub installname ($)
{
  my ($file) = @_;
  my $res = Cwd::realpath($file);
  $res =~ s/^$destdir//;
  $res;
}


=item C<rpath_tool()>

Return the name of the tool to use to change the rpath.  Return undef
if we don't need it (e.g., on OS X).

=cut

sub rpath_tool()
{
  if ($OSNAME eq 'darwin')
  {
    return undef;
  }
  elsif ($OSNAME eq 'linux')
  {
    my @tools = qw(patchelf chrpath);
    for my $tool (@tools)
    {
      if (system($tool, '--version') == 0)
      {
        return $tool;
      }
    }
    die "$me: cannot find tool to change rpath: @tools\n";
  }
}


=item C<rpath_get($lib)>

Return the RPATH of $lib as a list of directories.

=cut

sub rpath_get($)
{
  my ($lib) = @_;
  my $res = '';
  if ($chrpath eq 'chrpath')
  {
    $res = qx($chrpath -l $lib);
    $res =~ s/.*RPATH=//;
  }
  elsif ($chrpath eq 'patchelf')
  {
    $res = qx($chrpath --print-rpath $lib);
  }
  else
  {
    die "$me: unknown chrpath: $chrpath\n";
  }

  if ($?)
  {
    warn "$me: $chrpath failed on $lib: $?";
    $res = '';
  }
  chomp $res;
  return wantarray ? split (":", $res) : $res;
}

=item C<rpath_set($lib, @rpath)>

Set the RPATH of C<$lib> to C<@rpath>, if needed.

=cut

sub rpath_set($@)
{
  my ($lib, @rpath) = @_;
  my $oldrpath = rpath_get($lib);
  my $newrpath = join(':', @rpath);
  if ($newrpath && $newrpath ne $oldrpath)
  {
    if ($chrpath eq 'chrpath')
    {
      xsystem($chrpath, "-r", $newrpath, $lib)
    }
    elsif ($chrpath eq 'patchelf')
    {
      xsystem($chrpath, "--set-rpath", $newrpath, $lib)
    }
    else
    {
      die "$me: unknown chrpath: $chrpath\n";
    }
  }
}


=item C<relocate($lib)>

Turn absolute dependencies within the package into relative rpaths.

=cut

sub relocate ($)
{
  my ($lib) = @_;
  my $dir = dirname(installname($lib));
  verbose 3, "relocate($lib) @ $dir";

  # On OS X, look for all the dependencies that are inside our
  # DESTDIR, and make then relative.  It works at the level of each
  # library.
  if ($OSNAME eq 'darwin')
    {
      for my $dep (grep {exists $argv{$_}} dependencies($lib))
        {
          my $rel = File::Spec->abs2rel($dep, $dir);
          xsystem("install_name_tool",
                  "-change", $dep, "\@loader_path/$rel",
                  $lib);
        }
    }

  # On GNU/Linux, change the rpaths.  I.e., when we depend on an rpath
  # which inside the package, make it relative.  It works at the level
  # of directories, not libraries.  We use chrpath for two things: to
  # get the list of current RPATH, and to change them.
  elsif ($OSNAME eq 'linux')
    {
      my @rpath;
      for my $dep (rpath_get($lib))
        {
          my $rel =
            (prefix($prefix, $dep)
             ? File::Spec->catdir('$ORIGIN',
                                  File::Spec->abs2rel($dep, $dir))
             : $dep);
          verbose 3, "$dep => $rel"
            if $dep ne $rel;
          push @rpath, $rel;
        }
      rpath_set($lib, @rpath);
    }
}

sub check($)
{
  my ($lib) = @_;
  verbose 3, "check($lib)";

  my @valid =
    # On OS X, the relative rpath dependencies are reported
    # with a relative path starting with @loader_path.
    $OSNAME eq 'darwin' ? qw(@loader_path/ /usr/lib/ /opt/local/lib/)
    # On GNU/Linux, the related rpath dependencies are resolved and
    # made absolute.  Accept them only if they are inside our package.
    : $OSNAME eq 'linux' ? ($destdir,
                            qw(/lib/ /usr/lib/gcc/ /usr/lib/libstdc++
	/usr/lib/libSM.so
	/usr/lib/libICE.so
	/usr/lib/libX11.so
	/usr/lib/libXext.so
	/usr/lib/libxcb.so
	/usr/lib/libXau.so
	/usr/lib/libXdmcp.so
	))
    : ();

  my $re = "^(?:" . join("|", map (quotemeta, @valid)) . ")";
  for my $loc (dependencies($lib))
    {
      # If this is really a path (e.g., not using @loader_path), get
      # rid of symlinks.
      $loc = Cwd::realpath($loc)
        if -f $loc;
      if ($loc =~ m($re))
        {
          $loc{$loc} = 1;
        }
      else
        {
          print STDERR "$me: error: $lib depends on $loc\n";
          ++$nerrors;
        }
    }
}

=item C<help>

Generate the B<--help> message.  Generates the full man page when
C<$verbose>.

=cut

sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Relocate shlib deps when possible, check remaing deps",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "d|destdir=s"   => \$destdir,
    "h|help"        => sub { help ($verbose) },
    "p|prefix=s"    => \$prefix,
    "q|quiet"       => sub { --$verbose },
    "v|verbose"     => sub { ++$verbose },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;

  die "$me: passing --destdir is mandatory\n"
    unless defined $destdir;

  die "$me: passing --prefix is mandatory\n"
    unless defined $prefix;

  # DESTDIR must not end with slashes.
  $destdir =~ s,/+$,,g;

  # Since we use the realpath everywhere else, use it here too.
  # For instance on OS X, /tmp is actually a symlink to private/tmp.
  $destdir = Cwd::realpath($destdir);
}

sub wanted
{
  # We check the shared lib dependencies on binaries and on shared
  # libraries.
  my $re =
    (
     $^O eq 'darwin'
     ? qr{\.(dylib|so)\z}s # Our UObjects are *.so.
     : qr{\.so(\..*)?\z}s
    );
  if (-f $_
      && (-x $_ || /$re/))
    {
      # We are not interested in plain files.
      my $res = `file $_`;
      push @checked, $File::Find::name
        if $res !~ /shell script|ASCII English text|libtool library file/;
    }
}

######################################################################

## ------ ##
## Main.  ##
## ------ ##

getopt;

$chrpath = rpath_tool;
verbose 3, "using chrpath = " . ($chrpath || "undef");

File::Find::find({wanted => \&wanted}, @ARGV);
map {$argv{installname($_)} = 1} @checked;
verbose 2, "Shipped deps:", map { "  $_" } sort keys %argv;
map
  {
    my $lib = $_;
    relocate($lib);
    check($lib);
  }
  @checked;

verbose 1, "Accepted dependencies:", map { "  $_" } sort keys %loc;
verbose 1, "There were $nerrors errors";
exit !!$nerrors;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
