#! /usr/bin/perl -w

use Cwd;            # realpath
use File::Basename;
use File::Find ();
use IO::File;
use strict;

sub host_os($);
sub dependency_foreign($);
sub dependency_inner($);
sub dependency_system($);

=head1 NAME

  check-lib-deps - handle shared-lib dependencies

=head1 SYNOPSIS

  check-lib-deps [OPTIONS...] DIR|FILE...

=head1 DESCRIPTION

Traverse all the DIR and FILE... to gather the set of binaries and
dynamic libraries, and handle there dependencies.

Goes into three steps:

=over 4

=item complete

Collect all the dependencies that are not part of the package, and
install them into the package tree at C<$libdir>.  This is performed
only if C<--libdir> was provided.

All the libraries installed for completion will also be traversed to
apply these three steps.

=item relocate

Transform every internal (i.e., provided by the package) absolute (in
the sense of absolute path) dependency, into a relative dependency.

=item check

Every foreign dependency (i.e., not provided by the package, and not
accepted as system dependencies) is an error.

=back

Exit with failure if invalid dependencies remain.

For interesting input on this topic, see:

  RPATH/RUNPATH issue, equivalent to -headerpad on OSX
    http://sourceware.org/ml/binutils/2008-01/msg00021.html

To change the RPATH, we use either patchelf or chrpath.  The former is
preferred, as it has no limitations on the size of the new rpath,
while the latter requires that the new rpath is no longer than the
original one.

=head1 OPTIONS

General options:

=over 4

=item B<-h>, B<--help>

Display this message and exit.

=item B<-d>, B<--destdir>=I<destdir>

Specify the installation destination directory.  Anything found under
this directory is considered to be part of it.  Anything else is a
foreign dependency.

=item B<-l>, B<--libdir>=I<libdir>

Specify that missing dependencies should be installed in
C<$destdir$libdir>.  If C<$libdir> is not specified, nothing is
installed.

=item B<-L>, B<--libpath>=I<dir>

When completing for missing foreign dependencies, add the I<dir> to
the list of library directory.  Needed only on Windows, on the other
architectures we know how to find these libraries.

=item B<-o>, B<--host-os>=I<host-os>

Specify the host operating system type, i.e., the type of the machine
the program will run on.  Expected values are:

=over 4

=item mac

Mac OS X.  Use C<otool> and C<install_name_tool>.

=item linux

GNU/Linux.  Use C<ldd> and C<patchelf> if possible, otherwise
C<chrpath>.

=item windows

MS Windows.  Use C<cygcheck.exe>.  The support is very incomplete, it
just does not work yet.

=back

=item B<-p>, B<--prefix>=I<prefix>

Prefix into which the package is installed.  This is used under
GNU/Linux to change the RPATH.  Any RPATH component that is prefixed
by C<$prefix> will be made relative.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

=head1 FUNCTIONS

=over 4

=cut

# The dependencies that are inside our package.  A simple set (i.e.,
# the value is always 1).  The keys are *without* destdir.  So use
# &installname before to check existence inside %argv.
my %argv;

# The list of files to check.
my @checked;

# The tool to get and set the rpath.  Patchelf is preferred, it does
# not have any limitations on the size of the new rpath.
my $chrpath;

# The place the installation was made.
my $destdir;

# The host operating system.
my $host_os = host_os($^O);

# The set of libraries installed in libdir for completion.
my %installed;

# The directory in $destdir where missing dependencies should be
# installed.  Typically C<$prefix/lib>.
my $libdir;

# Where to look for foreign libraries for package completion.
my @libpath;

# Accepted resolved libraries.
my %loc;

# The prefix for the log messages.
my $me = basename($0);

# Number of errors.
my $nerrors = 0;

# The --prefix given to configure.
my $prefix;

# Foreign, reject libraries as keys, list of dependent as values.
my %rejected;

# Verbosity level.
my $verbose = 1;

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  map { print STDERR "$me: " . "  " x $level . "$_\n" } @message
    if $level <= $verbose;
}

=item C<host_os($host_os)>

Check thet C<$host_os> is valid, and return its canonicalized name a
la Perl: darwin, linux, windows.

=cut

sub host_os($)
{
  my ($host_os) = @_;
  my %host_os =
    (
     darwin  => 'darwin',
     linux   => 'linux',
     mac     => 'darwin',
     macos   => 'darwin',
     windows => 'windows',
    );
  $host_os = lc $host_os;
  die "$me: invalid host OS: $host_os\n"
    unless exists $host_os{$host_os};
  $host_os{$host_os};
}


=item C<prefix($prefix, $string)>

Whether C<$prefix> is a prefix of C<$string>.

=cut

sub prefix($$)
{
  my ($lhs, $rhs) = @_;
  my $sub = substr ($rhs, 0, length($lhs));
  $sub eq $lhs ? 1 : 0;
}


=item C<unique(@list)>

Return C<@list> removing duplicates.

=cut

sub unique (@)
{
  my (@list) = @_;
  my %seen;
  my @res;
  for my $item (@list)
  {
    if (! exists $seen{$item})
    {
      $seen{$item} = 1;
      push @res, $item;
    }
  }
  @res;
}


=item C<same_file($path1, $path1)>

Whether C<$path1> and C<$path2> point to the same file.  We do not
work on path names because there are too many ways to name a single
file, in particular when winepath goes into the scene.

=cut

sub same_file ($$)
{
  my ($path1, $path2) = @_;
  my ($dev1, $ino1) = stat ($path1);
  my ($dev2, $ino2) = stat ($path2);
  $dev1 == $dev2 && $ino1 == $ino2;
}


=item C<repath_unix($path)>

Normalize the C<$path> to a Unix name.

=cut

sub repath_unix ($)
{
  my ($path) = @_;
  my $res = `winepath -u '$path'`;
  chomp $res;
  $res = Cwd::realpath ($res);
  $res;
}


=item C<dependencies($lib)>

Return the list of paths we depend upon.  C<$lib> can actually be an
executable or a shared library.

=cut

sub dependencies
{
  my ($lib, $lpath) = @_;
  $lpath = ""
    unless defined $lpath;
  verbose 3, "dependencies($lib)";
  my @res;
  if ($host_os eq 'darwin')
    {
      my $deps = new IO::File("otool -L $lib|")
        or die "$me: cannot read otool -L $lib: $!\n";
      while (my $line = $deps->getline)
        {
          chomp $line;
          if ($line eq "$lib:")
            {
              # Ignore silently.
            }
          elsif ($line =~ /^\t(.*?)\s+\(.*\)$/)
            {
              # On OS X, a library appears to depend on itself.
              push @res, $1
                unless $1 eq installname($lib);
            }
          else
            {
              verbose 2, "ignoring the following otool output line:", $line;
            }
        }
    }
  elsif ($host_os eq 'linux')
    {
     my $ldd = new IO::File("LD_LIBRARY_PATH=$lpath ldd $lib|")
        or die "$me: cannot read ldd $lib: $!\n";
      while (my $line = $ldd->getline)
        {
          chomp $line;
          if ($line =~ /^\t(.*?)\s+=>\s(.*?)\s\(.*\)$/
              # Yes, we push "not found" as a dependency.  These are
              # inner libraries that ldd does not find (we don't have
              # the LD_LIBRARY_PATH to find it).
              || $line =~ /^\t(.*?)\s+=>\s(not found)$/)
            {
              my ($dep, $loc) = ($1, $2);
              push @res, $loc
                if $loc;
            }
          else
            {
              verbose 2, "ignoring the following ldd output line:", $line;
            }
        }
    }
  elsif ($host_os eq 'windows')
    {
      my $dir = dirname ($lib);
      my $base = basename ($lib);
      my $ldd = new IO::File("cd $dir && cygcheck.exe ./$base 2>&1 |")
        or die "$me: cannot read 'cd $dir && cygcheck.exe ./$base': $!\n";
      while (my $line = $ldd->getline)
        {
          chomp $line;
          $line =~ s/^\s+//;
          $line =~ s/\s+$//;
          if ($line =~ /^cygcheck: track_down: could not find (.*\.dll)/)
            {
              push @res, $1;
            }
          elsif ($line =~ /(.*\.dll)$/)
            {
              my $loc = installname (repath_unix $1);
              push @res, $loc
                unless $lib eq $loc;
            }
          elsif ($line)
            {
              verbose 2, "ignoring the following cycheck output line:", $line;
            }
        }
    }

  # If this is really a path (e.g., not using @loader_path), get
  # rid of symlinks.
  map
    {
      $_ = Cwd::realpath($_)
        if -f $_;
    } @res;
  @res = unique (@res);
  @res = sort (@res);
  verbose (4, "$lib depends on",
           map { "  $_ (" . dependency_type($_) . ")" } @res);
  @res;
}


sub xsystem (@)
{
  my (@args) = @_;

  verbose 2, "running: @args";
  system(@args) == 0
    or die "$me: system @args failed: $?\n";
  if ($? == -1)
    {
      die "$me: failed to execute: $!\n";
    }
  elsif ($? & 127)
    {
      die sprintf ("$me: child died with signal %d, %s coredump\n",
                   ($? & 127),  ($? & 128) ? 'with' : 'without');
    }
  elsif ($? >> 8)
    {
      die sprintf "$me: child exited with value %d\n", $? >> 8;
    }
}

=item C<installname($file)>

Return the name in the install tree.

Make it absolute, and cut the $DESTDIR.  We use realpath instead of
rel2abs, because the latter does not work when converting a $ORIGIN
dependencies to an absolute path: it keeps all the "../.."  bits which
make it uselessly hard for us to check whether a given dependency is
within our package or not.

=cut

sub installname ($)
{
  my ($file) = @_;
  my $res = Cwd::realpath($file);
  $res =~ s/^$destdir//;
  $res;
}


=item C<rpath_tool()>

Return the name of the tool to use to change the rpath.  Return undef
if we don't need it (e.g., on OS X).

=cut

sub rpath_tool()
{
  if ($host_os eq 'darwin')
  {
    return undef;
  }
  elsif ($host_os eq 'linux')
  {
    my @tools = qw(patchelf chrpath);
    for my $tool (@tools)
    {
      if (system($tool, '--version') == 0)
      {
        return $tool;
      }
    }
    die "$me: cannot find tool to change rpath: @tools\n";
  }
}


=item C<rpath_get($lib)>

Return the RPATH of $lib as a list of directories.

=cut

sub rpath_get($)
{
  my ($lib) = @_;
  my $res = '';
  if ($chrpath eq 'chrpath')
  {
    $res = qx($chrpath -l $lib);
    $res =~ s/.*RPATH=//;
  }
  elsif ($chrpath eq 'patchelf')
  {
    $res = qx($chrpath --print-rpath $lib);
  }
  else
  {
    die "$me: unknown chrpath: $chrpath\n";
  }

  if ($?)
  {
    warn "$me: $chrpath failed on $lib: $?";
    $res = '';
  }
  chomp $res;
  return wantarray ? split (":", $res) : $res;
}

=item C<rpath_set($lib, @rpath)>

Set the RPATH of C<$lib> to C<@rpath>, if needed.

=cut

sub rpath_set($@)
{
  my ($lib, @rpath) = @_;
  my $oldrpath = rpath_get($lib);
  my $newrpath = join(':', @rpath);
  if ($newrpath ne $oldrpath)
  {
    if ($chrpath eq 'chrpath')
    {
      xsystem($chrpath, "-r", $newrpath, $lib)
    }
    elsif ($chrpath eq 'patchelf')
    {
      xsystem($chrpath, "--set-rpath", $newrpath, $lib)
    }
    else
    {
      die "$me: unknown chrpath: $chrpath\n";
    }
  }
}

=item C<relocate($lib)>

Turn absolute dependencies within the package into relative rpaths.

=cut

sub relocate ($)
{
  my ($lib) = @_;
  my $dir = dirname(installname($lib));
  verbose 3, "relocate($lib) @ $dir";

  # On OS X, look for all the dependencies that are inside our
  # DESTDIR, and make then relative.  It works at the level of each
  # library.
  if ($host_os eq 'darwin')
  {
    # This is not necessary, but it produces a cleaner otool -L
    # output.  It also helps our check-step (the library no longer has
    # a name outside of the package).
    xsystem("install_name_tool",
            "-id", '@loader_path/' . basename ($lib),
            $lib);
    # Handle installed dependencies.
    for my $dep (grep {exists $installed{$_}} dependencies($lib))
    {
      my $new = File::Spec->catfile($libdir, basename $dep);
      my $rel = File::Spec->abs2rel($new, $dir);
      xsystem("install_name_tool",
              "-change", $dep, "\@loader_path/$rel",
              $lib);
    }
    # Handle inner dependencies.
    for my $dep (grep {exists $argv{$_}} dependencies($lib))
    {
      my $rel = File::Spec->abs2rel($dep, $dir);
      xsystem("install_name_tool",
              "-change", $dep, "\@loader_path/$rel",
              $lib);
    }
  }

  # On GNU/Linux, change the rpaths.  I.e., when we depend on an rpath
  # which inside the package, make it relative.  It works at the level
  # of directories, not libraries.  We use chrpath for two things: to
  # get the list of current RPATH, and to change them.
  elsif ($host_os eq 'linux')
  {
    my @rpath;
    for my $dep (rpath_get($lib))
      {
        my $rel =
          (directory_inner($dep)
           ? File::Spec->catdir('$ORIGIN',
                                File::Spec->abs2rel($dep, $dir))
           : $dep);
        verbose 3, "$dep => $rel"
          if $dep ne $rel;
        push @rpath, $rel;
      }
    # If there are dependencies to installed libraries, include this
    # libdir in the RPATH.
    if (grep {exists $installed{$_}} dependencies($lib, join (':', @libpath)))
    {
      my $rel = File::Spec->catdir('$ORIGIN',
                                   File::Spec->abs2rel($libdir, $dir));
      verbose 3, "installing $rel in RPATH";
      push @rpath, $rel;
    }
    @rpath = unique @rpath;
    rpath_set($lib, @rpath);
  }
}

=item C<dependency_foreign($lib)>

Whether C<$lib> is a foreign dependence, i.e., neither system nor
inner.

=cut

sub dependency_foreign($)
{
  my ($lib) = @_;
  ! dependency_inner ($lib) && ! dependency_system ($lib);
}

=item C<dependency_inner($lib)>

Whether C<$lib> is an inner dependence, i.e., it is (already) shipped.

=cut

sub dependency_inner($)
{
  my ($lib) = @_;

  my $res = exists $argv{$lib};

  # On GNU/Linux, the related rpath dependencies are resolved and
  # made absolute.  Accept them only if they are inside our package.
  $res ||= exists $argv{installname $lib}
    if $host_os eq 'linux';

  # Under Windows, since we don't have a means to tell cygcheck.exe
  # how to extend its LD_LIBRARY_PATH, it will complete that, for
  # instance, we have a dependency on libuobject.dll (without the full
  # path).  So in this case, just check that we do ship a file that
  # has this name.
  $res ||= scalar (grep { basename ($_) eq $lib } keys %argv)
    if $host_os eq 'windows';

  $res;
}

=item C<dependency_system($lib)>

Whether C<$lib> is a system dependence, i.e., it is expected to be on
the host system: it does not need to be shipped.

=cut

sub dependency_system($)
{
  my ($lib) = @_;

  # Recognize a system library.
  my $system_libs =
    # On OS X, the relative rpath dependencies are reported
    # with a relative path starting with @loader_path.
    $host_os eq 'darwin'
    ? qr(
          /opt/local/lib/libICE\.
        | /opt/local/lib/libSM\.
        | /opt/local/lib/libX11\.
        | /opt/local/lib/libXau\.
        | /opt/local/lib/libXdmcp\.
        | /opt/local/lib/libXext\.
        | /usr/lib/
        | \@loader_path/
        )x
    : $host_os eq 'linux'
    ? qr(
          /lib/
        | /usr/lib/gcc/
        | /usr/lib/libICE\.so
        | /usr/lib/libSM\.so
        | /usr/lib/libX11\.so
        | /usr/lib/libXau\.so
        | /usr/lib/libXdmcp\.so
        | /usr/lib/libXext\.so
        | /usr/lib/libstdc\+\+
        | /usr/lib/libxcb\.so
        )x
    # On Windows,
    : $host_os eq 'windows'
    ? qr(
          .*/windows/system32/
        | msvcp90.dll
        | msvcr90.dll
	| msvcp90d.dll
	| msvcr90d.dll
        | msvcp80.dll
        | msvcr80.dll
        | msvcp80d.dll
        | msvcr80d.dll
        )ix
    : ();

  $lib =~ qr{^(?:$system_libs)}o;
}


=item C<dependency_type($lib)>

Return the type of C<$lib> among C<inner>, C<foreign>, and C<system>.

=cut

sub dependency_type($)
{
  my ($lib) = @_;
  # Designed on purpose to catch errors such as multiple-type
  # dependencies.
  my @res;
  push @res, "foreign"
    if dependency_foreign ($lib);
  push @res, "inner"
    if dependency_inner ($lib);
  push @res, "system"
    if dependency_system ($lib);
  my $res = join '-', @res;
  verbose 6, "$lib: $res dependency";
  $res;
}


=item C<dependencies_foreign($lib)>

The list of dependencies of C<$lib> that are not part of this package,
and are not accepted.

=cut

sub dependencies_foreign
{
  my ($lib, $lpath) = @_;
  my @res;

  for my $loc (dependencies($lib, $lpath))
    {
      my $type = dependency_type($loc);
      if ($type eq 'system')
      {
        # System library.
        $loc{$loc} = 1;
      }
      elsif ($type eq 'foreign')
      {
        # Foreign library.
        push @res, $loc;
      }
    }
  return @res;
}

=item C<directory_inner($dir)>

Whether C<$dir> is an inner directory, i.e., a directory inside our
package.

We used to simply check that C<$prefix> is a prefix of C<$dir>,
unfortunately if C<$prefix> is C</>, any (absolute) directory is
"inner".  So rather, see if this place is a directory of one of our
shipped libraries.

=cut

sub directory_inner($)
{
  my ($dir) = @_;
  my %inner_dirs;
  map { $inner_dirs{dirname $_} = 1; } keys %argv;
  return exists $inner_dirs{$dir};
}

=item C<install($from, $to)>

Copy the file C<$from> as the file C<$to>.  Create parent directories
if needed.

Preserve permissions.  This avoids spurious warnings from ldd that
does not like that shared objects are not executable.

=cut

sub install($$)
{
  my ($from, $to) = @_;
  verbose 3, "copy $from $to";
  my $dir = dirname($to);
  if (! -d $dir)
  {
    use File::Path qw(mkpath);
    mkpath $dir
      or die "$me: cannot mkpath $dir: $!\n";
  }
  use File::Copy;
  File::Copy::copy $from, $to
    or die "$me: copy $from $to failed: $!\n";

  my $mode = (stat($from))[2] & 0777;
  chmod $mode, $to
    or die "$me: cannot chmod $to failed: $!\n";
}

=item C<complete($lib)>

Install the foreign dependencies of C<$lib> in C<$destdir$libdir>, if
C<$libdir> is defined.

=cut

sub complete ($)
{
  my ($lib) = @_;
  verbose 3, "complete($lib) @ $libdir";
  my $dir = "$destdir$libdir";
  my $lpath = join(':', @libpath);
  for my $loc (dependencies_foreign($lib, $lpath))
  {
    # On Linux we keep "not found" as the sign that the library
    # is... not found.  This matters for &check.
    next
      if $loc eq 'not found';

    # Where it will be installed.
    my $new = File::Spec->catfile($dir, basename $loc);
    # Maybe find it.  Store the result in $loc.
    if ($host_os eq 'windows')
    {
      for my $d (@libpath)
      {
        if (-f "$d/$loc")
        {
          $loc = "$d/$loc";
          last;
        }
      }
      next
        unless -f $loc;
    }
    install $loc, $new;
    $installed{$loc} = 1;
    push @checked, $new;
    $argv{installname($new)} = 1;
  }
}

=item C<check($lib)>

Make sure that C<$lib> depends on no foreign library.

=cut

sub check ($)
{
  my ($lib) = @_;
  verbose 3, "check($lib)";
  for my $loc (dependencies_foreign($lib))
  {
    print STDERR "$me: error: $lib depends on $loc\n";
    push @{$rejected{$loc}}, $lib;
    ++$nerrors;
  }
}

=item C<help>

Generate the B<--help> message.  Generates the full man page when
C<$verbose>.

=cut

sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Relocate shlib deps when possible, check remaing deps",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "d|destdir=s"   => \$destdir,
    "h|help"        => sub { help ($verbose) },
    "l|libdir=s"    => \$libdir,
    "L|libpath=s"   => \@libpath,
    "o|host-os=s"   => sub { $host_os = host_os ($_[1]) },
    "p|prefix=s"    => \$prefix,
    "q|quiet"       => sub { --$verbose },
    "v|verbose"     => sub { ++$verbose },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;

  die "$me: passing --destdir is mandatory\n"
    unless defined $destdir;

  # DESTDIR must not end with slashes.
  $destdir =~ s,/+$,,g;

  die "$me: destdir cannot be empty\n"
    unless $destdir;

  # Since we use the realpath everywhere else, use it here too.
  # For instance on OS X, /tmp is actually a symlink to private/tmp.
  $destdir = Cwd::realpath($destdir);

  die "$me: passing --prefix is mandatory\n"
    unless defined $prefix;

  verbose (4,
           "destdir = $destdir",
           "host-os = $host_os",
           "libdir = $libdir",
           "libpath = @libpath",
           "prefix = $prefix",
    );
}

sub wanted
{
  # We check the shared lib dependencies on binaries and on shared
  # libraries.
  my $wanted;
  if ($host_os eq 'windows')
    {
      $wanted = m{\.(dll|exe)\z}s;
    }
  else
    {
      my $re =
      (
       $host_os   eq 'darwin'  ? qr{\.(dylib|so)\z}s # Our UObjects are *.so.
       : $host_os eq 'linux'   ? qr{\.so(\..*)?\z}s
       :                         qr{}s
      );
      $wanted = (-f $_
                 && (-x $_ || /$re/)
                 && `file $_` !~ /shell script|ASCII|libtool library file/)
    }

  push @checked, $File::Find::name
    if $wanted;
}

######################################################################

## ------ ##
## Main.  ##
## ------ ##

getopt;

$chrpath = rpath_tool;
verbose 4, "using chrpath = " . ($chrpath || "undef");

# Gather.
File::Find::find({wanted => \&wanted}, @ARGV);
map {$argv{installname($_)} = 1} @checked;

verbose 2, "Shipped deps:", map { "  $_" } sort keys %argv;

# For each library, relocate it, and make sure there are no forbidden
# dependencies.
while (@checked)
{
  my $lib = shift @checked;
  complete($lib)
    if defined $libdir;
  relocate($lib);
  check($lib);
}

verbose 2, "Shipped deps:", map { "  $_" } sort keys %argv;
verbose 1, "System dependencies:", map { "  $_" } sort keys %loc;
verbose (1, "Rejected dependencies:",
         map { ("  $_:", map { "    $_ " } @{$rejected{$_}}) }
         (sort keys %rejected));
verbose 1, "There were $nerrors errors";
exit !!$nerrors;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
