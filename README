        					-*- outline -*-

This file is meant for people who want to *build* the Kernel.  It is
not for people who simply want to install a pre-built Urbi SDK.

Outline:
  * requirements
    Software you need.
  * checkouts
    How to pull Urbi SDK for the repository.
  * bootstrap
    How to set up the Autotools and the generated sources.
  * configuration
    How to run the GNU Build System (./configure && make).
  * test suites
    Various make checks.
  * FAQ
    Common errors you are likely to find.

* requirements
To bootstrap this package from its repository, and then to compile it,
the following tools are needed.

** Autoconf 2.63 or later
** Automake 1.10.2 or later
Note that if you have to install automake by hand (as opposed by "with
your distro's system), you have to tell its aclocal that it should
also look at the files from the system's aclocal.  If
/usr/local/bin/aclocal is the one you just installed, and
/usr/bin/aclocal is the system's one, them run something like this:

  dirlist=$(/usr/local/bin/aclocal --print-ac-dir)/dirlist
  sudo mkdir -p $(dirname $dirlist)
  sudo /usr/bin/aclocal --print-ac-dir >>$dirlist

package: autoconf automake

** bc
Needed by the test suite.
package: bc

** Boost 1.37 or later
Don't try to build it yourself, ask your distro's management to
install it.
package: boost-1.39
windows: http://www.boostpro.com/download

** Ccache
Not a requirement, but it's better to have it.
package: ccache

** Cvs
This surprising requirement comes from the system Bison uses to fetch
the current version of the message translations.
package: cvs

** Flex 2.5.35 or later
Beware that 2.5.33 has bugs than prevents this package from building
correctly.
package: flex

** G++ 4.0 or later
GCC 4.2 or better is a better option.

** Git 1.6 or later
Beware that older version behave poorly with submodules.
package: git-core

** Gettext 1.17
Required to bootstrap Bison.  In particular it provides autopoint.
package: gettext

** GNU sha1sum
We need the GNU version of sha1sum.  On Mac Ports it is part of the
coreutils package.
package: coreutils

** Help2man
Needed by Bison.
package: help2man

** Libtool 2.2 or later
Actually it should no longer be needed, as we embed all the file we
need in libport.

** PDFLaTeX
TeX Live is the most common distro nowadays.
deb: texlive-base texlive-latex-extra
MacPorts: texlive texlive_texmf-full

** Python
You need xml/sax, which seems to be part only of Python 2.6.  Using
python_select can be useful to state that you want to use Python 2.6
by default (sudo python_select python26).
package: python26
MacPorts: python_select
deb:   python-xml

** py-docutils
This is not a requirement, but it's better to have it.  Used by the
test suite.  Unfortunately the name of the package varies between
distros.  It provides "rst2html".
MacPorts: py26-docutils

** yaml for Python
The AST is generated from a description written in YAML.  Our (Python)
tools need to read these files to generate the AST classes.  See
http://pyyaml.org/wiki/PyYAML.

MacPorts: py26-yaml
deb:   python-yaml

** socat
Needed by the test suite.
package: socat

** Valgrind
Not needed, but if present, used by the test suite.
package: valgrind

** xsltproc
This is not a requirement, but it's better to have it.

* checkout
We heavily use Git submodules, i.e., we subscribe to other Git
repositories, which themselves may depend on other submodules.
Unfortunately Git's support for recursive submodules is not nice.  We
have scripts in common (named git-my-*, also available as git my-*)
that make this easier.  Since they call each other, set your PATH to
go into common/git.

  git clone git@core.gostai.com:kernel.git
  cd kernel
  git checkout -b 2.0 --track origin/2.0
  git my-update

* bootstrap
Run

  ./bootstrap

* configuration
You should really compile in another directory than the one containing
the sources.

  mkdir _build
  cd _build
  ../configure OPTIONS...

** configuration options
See ../configure --help for detailed information.  Unless you want to
do funky stuff, you probably need no option.

  --enable-host=URBI-HOST
  --enable-env=URBI-ENV
  --with-boost=path

To use ccache, pass

  CC='ccache gcc' CXX='ccache g++'

as options to configure:

  ../configure CC='ccache gcc' CXX='ccache g++' ...

** building for Windows.

We support two builds: using Wine on top of Unix, and using Cygwin on
top of Windows.

Both builds use our wrappers around MSVC's cl.exe and link.exe.  It
is still unclear whether it was a good or a bad idea, but the wrappers
use the same names.  Yet libtool will also need to use the genuine
link.exe.  So to set up Libtool properly, you will need to pass the
following as argument to configure:

  AR=lib.exe                                                    \
  CC='ccache cl.exe'                                            \
  CC_FOR_BUILD=gcc                                              \
  CXX='ccache cl.exe'                                           \
  LD=link.exe                                                   \
  DUMPBIN='/cygdrive/c/vcxx8/VC/bin/link.exe -dump -symbols'    \
  RANLIB=:                                                      \
  host_alias=mingw32                                            \
  --host=mingw32

where:
  - lib.exe, cl.exe, link.exe are the wrappers
  - /cygdrive/c/vcxx8/VC/bin/link.exe is the genuine MSVC tool.

Since we are cross-compiling, we also need to specify CC_FOR_BUILD so
that config.guess can properly guess the type of the build machine.

** building for Windows using cygwin

We use our cl.exe wrappers, which is something that Libtool cannot
know.  So we need to tell it that we are on Windows with Cygwin, and
pretend we use GCC, so we pretend we run mingw.

The following options have been used with success to compile Urbi SDK
with Visual C++ 2005.  Adjust to your own case (in particular the
location of Boost).

Note that `cl.exe'

 ../configure                                                   \
  -C                                                            \
  --prefix=/usr/local/gostai                                    \
  --enable-compilation-mode=debug                               \
  --enable-shared                                               \
  --disable-static                                              \
  --enable-dependency-tracking                                  \
  --with-boost=/cygdrive/c/gt-win32-2/d/boost_1_39              \
  AR=lib.exe                                                    \
  CC='ccache cl.exe'                                            \
  CC_FOR_BUILD=gcc                                              \
  CXX='ccache cl.exe'                                           \
  LD=link.exe                                                   \
  DUMPBIN='/cygdrive/c/vcxx8/VC/bin/link.exe -dump -symbols'    \
  RANLIB=:                                                      \
  host_alias=mingw32                                            \
  --host=mingw32

For some reason, the building of libuobject.dll will fail.  You need
to remove the reference to "libltld.la" from the libtool invocation.
This will be simplified later.

* compilation
Should be straightforward.

  make -j3  (or more, distcc is your friend).

* test suites
There are several test suites that will be run if you run "make check"
(-j4 works on most machines).  To rerun only the tests that failed,
use "make recheck".

** Lazy test suites
The test suites are declared as "lazy", i.e., unless its dependencies
changed, a successful test will be run only once --- failing tests do
not "cache" their results.  Because spelling out the dependencies is
painful, we rely on a few timestamps:

- libraries.stamp
  updated when any of our libraries is updated (libport, libuobject
  etc.)

- executables.stamp
  updated when an executable is updated (urbi-launch etc.).
  depends on libraries.stamp.

- urbi.stamp
  when Urbi sources (share/urbi/*.u) are updated.

- all.stamp
  updated when any of the three aforementioned time stamps is.

These time stamps are updated *only* when "make" is run in the
top-level.  Therefore, the following sequence is *wrong*:

    make check -C tests     # All passes.
    emacs share/urbi/foo.u
    make check -C tests     # All passes again.

because the timestamps were not given a chance to notice that some
Urbi source changed, so Make did not notice the tests really needed to
be rerun and *the tests were not run*.

You may either just update the time stamps:

    make check -C tests     # All passes.
    emacs share/urbi/foo.u
    make stamps             # Update the timestamps.
    make check -C tests     # All passes again.

or completely disable the test suite lazyness:

   make check -C tests LAZY_TEST_SUITE=

** Partial test suite runs
You can run each test suite individually by hand as follows:

*** sdk-remote/libport/test-suite.log: make check -C sdk-remote/libport
Tests libport.

*** sdk-remote/src/tests/test-suite.log: make check -C sdk-remote/src/tests
Checks liburbi, and some of the executables we ship.  Requires the
kernel to be compiled in order to be able to test some of the uobjects.

*** tests/test-suite.log: make check -C tests
Tests the kernel and uobectfs.  Partial runs can be invoked:

      make check -C tests TESTS='2.x/echo.chk'

wildcards are supported:

      make check -C tests TESTS='2.x/*'

To check remote uobjects tests:

      make check -C tests TESTS='uob/remote/*'

*** doc/tests/test-suite.log: make check -C doc
The snippets of code displayed in the documentation are transformed
into test files.

* FAQ
** AM_LANGINFO_CODESET

If at bootstrap you have something like:

  configure:12176: error: possibly undefined macro: AM_LANGINFO_CODESET
   If this token and others are legitimate, please use m4_pattern_allow.
   See the Autoconf documentation.
  configure:12246: error: possibly undefined macro: gl_GLIBC21

it probably means your Automake installation is incomplete.  See the
Automake item in the bootstrap section above.

** git: fatal: Needed a single revision
You may experience something like this:

  $ git submodule update --init
  fatal: Needed a single revision
  Unable to find current revision in submodule path 'gnulib'

this is the sign that the initial checkout of `gnulib' went completely
wrong (I don't know what makes this happen).  Chances are that the
directory exists, but is empty.  Git does not seem to be able to
overcome this situation, so:

  $ rm -rf gnulib
  $ git submodule update --init

et voila.
