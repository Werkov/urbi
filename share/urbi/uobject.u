/* Urbi side of 2.0 UObject plugin/remote implementation.
*/
/// FIXME: implement in C++ to get the period passed on command line.
var Object.getPeriod = 20ms;

/// Returns true if argument is defined. Argument can be of the form a.b.c.
function Global.isdef
{
  var base = call.sender |
  var first = true |
  for| (var c: call.argString(0).split([".", " "], nil, false, false))
  {
    if (base.hasSlot(c))
    {
      if (!first && !base.slotNames.has(c))
        return false |
      var s = base.getSlot(c).acceptVoid |
      base = s.apply([s]).acceptVoid |
      first = false
    }
      else
      return false |
  } |
  return true
};

class Global.UObject
{
  var minimumInterval = Object.getPeriod;
  var updateTask = 0;
  var timerTask = 0;
  var updateInterval = 0;

  function update()
  {
    "update not defined".print
  };

  function init()
  {
    updateTask = Tag.new;
  };

  /// Set a timer to call update at specified interval.
  function setUpdate(interval)
  {
    if (0 < interval && interval < minimumInterval)
      interval = minimumInterval;
    // Stop current update task.
    updateTask.stop;
    updateInterval = interval;
    if (0 < interval)
      updateTask: detach({loop{ update; sleep(updateInterval)}})
  };
  /// Set a timer to call \b func every \b interval milliseconds.
  function setTimer(interval, func)
  {
    if (interval < minimumInterval)
      interval = minimumInterval;
    if (!ownsSlot("timerTask"))
      timerTask = [];
    var tag = Tag.new;
    tag: detach({loop{ func(); sleep(interval)}}) |
    timerTask += [tag]
  };
  /// Call hub update function \b for hub \b hubname
  function setHubUpdate(hubname, interval, func)
  {
    if (0 < interval && interval < minimumInterval)
      interval = minimumInterval;
    // Ensure only one instance is running using a tag in slot hub<hubname>.
    var slotName = "hub"+hubname;
    if (!hasSlot(slotName))
      setSlot(slotName, Tag.new);
    getSlot(slotName).stop;
    if (0 < interval)
      getSlot(slotName):
        detach({loop{ func(); sleep(interval)}})
  };
};

/*
 * UVar provides access and change notification on a slot.
 * instanciate with 'UVar.new(containerObject, slotName);
 * call notifyChange(someFunc) to have someFunc called (with no argument)
 * right after a new value is written, call notifyAccess(someFunc) to have
 * someFunc called just before a value is read. The contained value is stored
 * in the 'val' slot of the UVar.
 */
do (getSlot("UVar"))
{

  function init(parent, name)
  {
    parent.setSlot(name, this)|
    parent.setProperty(name, "updateHook", getSlot("update_bounce"))|
    var this.newPropertyHook = getSlot("newPropertyHook_")|
    var slotName = name + "_quote_n"|
    // If the slot was containing a float, it already has a *_quote_n
    // slot, which is not the right one.
    if (parent.hasSlot(slotName))
      parent.removeSlot(slotName) |
    parent.setSlot(slotName, function ()
      {
        var min = parent.getSlot(name).getProperty("val", "rangemin")|
        var max = parent.getSlot(name).getProperty("val", "rangemax")|
        {var r = parent.getSlot(name) | return (r() - min) / (max-min)}
      })|
    parent.setProperty(slotName, "updateHook", function(slot, value)
      {
        var min = parent.getSlot(name).getProperty("val", "rangemin")|
        var max = parent.getSlot(name).getProperty("val", "rangemax")|
        parent.updateSlot(name, min + (max - min) * value)
      })|
    if (!parent.hasSlot("__has_uvar"))
    {
      var parent_getprop = parent.getSlot("getProperty")|
      parent.getProperty = function(varname, propname)
      {
        if (parent.getSlot(varname).isA(UVar))
          parent.getSlot(varname).getProperty("val", propname).acceptVoid
        else
          parent_getprop.apply([parent, varname, propname])
      }|
      var parent.__has_uvar = true
    }|
    {}
  };

  /// Global number of notifyaccess
  var nAccess = 0;
  var nAccessTag = Tag.new;
  function newPropertyHook_(parent, name, prop, value)
  {
   parent.getSlot(name).setProperty("val", prop, value)|
   parent.removeProperty(name, prop)
  };
  var __clone = getSlot("clone");
  clone = function()
  {
    var uv = __clone;
    do (uv)
    {
      var change = [] |
      var changeOwned = [] |
      var access = [] |
      var owned = false |
      var val |
      var valsensor = 0 |
      var isUVar = 1
    }
  };

  function notifyChange(f)
  {
    change += [f] |
    if (change.size == 1)
      detach(loopCheck) |
    void
  };
  function notifyChangeOwned(f)
  {
    changeOwned += [f] |
    void
  };
  function notifyAccess(f)
  {
    //beware of the CoW
    getSlot("UVar").nAccess++ |
    access += [f] |
    if (access.size == 1)
      detach(loopCheck) |
    void
  };
  void
};

// Can't be in a class or do block.
// Force reevaluation of all at exprs when at least one notifyaccess is present.
// FIXME: find a way to stop when callbacks are removed.
at (getSlot("UVar").nAccess > 0)
  getSlot("UVar").nAccessTag: every(getPeriod) {}
onleave
  getSlot("UVar").nAccessTag.stop;

var Global.uobjects = Object.clone;
Global.uobjects.uobject_init();


// UObject remote API.

/*------------------.
| Global.external.  |
`------------------*/

class Global.'external'
{
  var MODULE_TAG = "__ExternalMessage__";
  var UEM_EVALFUNCTION = 0;
  var UEM_ASSIGNVALUE  = 1;
  var UEM_EMITEVENT    = 2;
  var UEM_ENDEVENT     = 3;
  var UEM_NEW          = 4;
  var UEM_DELETE       = 5;


  /* external object <objname>: Set clone to send a UEM_NEW message.
  The remote upon reception of the UEM_NEW message 'instantiate <objname>
  with name <newname>' will instantiate the UObject, and send:
  - var <newname>.load, which will fail (<newname> does not exist)
  - class <newname>{} (which will go in the lobby)
  - external object <newname>
  - external var/func <newname>.xxx from whatever

  So in external.object we move the instance from lobby to Global.uobjects and
  recreate <newname>.load, and in our custom cloner, we:
  - send the NEW message passing a uid as <newname>
  - wait until uobjects.<newname>.init is set
  -  return the instance, which is also left in uobjects.<newname> because the
  remote will use it using this name.
  */
  function 'object'(objname)
  {
    if (uobjects.ownsSlot(objname))
      return|
    // The remote sent the code 'class <objname> {};' just before
    // calling this function, but we want objname in uobjects, not
    // lobby.
    if (uobjects not in Global.protos)
      Global.addProto(uobjects)|
    uobjects.setSlot(objname, lobby.getSlot(objname));
    lobby.removeSlot(objname)|
    ("external object "+objname).print|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function cloner()
    {
      var u = fresh;
      var msg = ['external'.UEM_NEW, u, objname];
      chan << msg;
      // Wait until the remote defines u.init.
      waituntil(Global.uobjects.hasSlot(u)
                && Global.uobjects.getSlot(u).ownsSlot("init"));
      var ret = Global.uobjects.getSlot(u);
      ret.protos = [this];
      ret
    }|
    uobjects.getSlot(objname).setSlot("clone", cloner)|
    //Ensure load is bound. K1 uobj tries to do it before binding the object.
    'var'(objname, "load", "dummy0")|
    void
  };

  /// Notify the remote when <objname>.<varname> is modified.
  function 'var'(objname, varname, fr)
  {
    ("external var call "+varname).print|
    var fullname = objname + "." + varname|

    if (!uobjects.hasSlot(objname))
    {
      if (varname == "load")
        return|
      ("Error: external var called for "+objname+"."+varname).print
    }|
    // Ignore duplicate binds of same var.
    var lid = lobby.uid|
    if (lid not in slotNames)
      setSlot(lid, [])|
    if (fullname in getSlot(lid))
      return|
    getSlot(lid).insertBack(fullname)|
    var obj = uobjects.getSlot(objname)|
    // Setup a hook, notify the remote when a change occurrs.
    if (!obj.ownsSlot(varname))
      UVar.new(obj, varname)
    else if (obj.getSlot(varname).isVoid
        || !obj.getSlot(varname).hasSlot("isUVar"))
    {
      // The slot allready exists, but is not an uvar.
      var v = obj.getSlot(varname).acceptVoid|
      obj.removeSlot(varname)|
      UVar.new(obj, varname) |
      if (!v.isVoid())
        obj.updateSlot(varname, v)
    }|
    // Create a 'notifyChange' function that generates the UObject
    // message and sends it through the remote connection.
    var uob = uobjects.getSlot(objname)|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function f()
    {
      var v = uob.getSlot(varname).val.acceptVoid |
      if (!v.isNil && !v.isVoid)
        chan << ['external'.UEM_ASSIGNVALUE,
                 fullname,
                 v]
    }|
    uobjects.getSlot(objname).getSlot(varname).notifyChange(f)|
    void
  };

  // Bind a function call to the remote side.
  // Write to the slot a function that will generate an uobject call message,
  // send it to the remote side, and wait for the result.
  function 'function'(nargs, objname, fname, fr)
  {
    ("external function call "+fname).print |
    var functionName = objname + "." + fname|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function f
    {
      var args = call.evalArgs;
      var u = fresh;
      var msg = [ 'external'.UEM_EVALFUNCTION,
                  functionName + "__" + args.size.asString,
                  "Global.uobjects." + u ] + args;
      chan << msg;
      waituntil(Global.uobjects.hasSlot(u));
      var res = Global.uobjects.getSlot(u).acceptVoid;
      Global.uobjects.removeSlot(u);
      res.unacceptVoid
    }|
    Global.uobjects.getSlot(objname).setSlot(fname, f)|
    void
  };

  function 'event'(nargs, objname, ename, fr)
  {
    // FIXME: implement when k2 will support events.
  };
};
