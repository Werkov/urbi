/* Urbi side of 2.0 UObject plugin/remote implementation.
*/
/// FIXME: implement in C++ to get the period passed on command line.
var Object.getPeriod = 20ms;

// We cannot use the "class Global.UObject: Finalizable" syntax here,
// because of specific constraints of Finalizable.
var Global.UObject = Finalizable.new;
do (Global.UObject)
{
  var type = "UObject";

  var minimumInterval = Object.getPeriod;
  var updateTask = 0;
  var timerTask = 0;
  var updateInterval = 0;
  // map lobby.uid+ event_name=>1 to know if event is allready registered
  var remoteEventMap;
  function update()
  {
    "update not defined".print
  };

  // Override new to throw an exception in init returned
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    var ret = res.callMessage(call)|
    if (ret != 0)
      throw Exception.new("%s construction failed: init returned %s."
                          % [__uobjectName, ret])|
    res
  };

  function init()
  {
    0
  };
  function uobject_init()
  {
    // COW
    updateTask = Tag.new;
    remoteEventMap = Dictionary.new;
    var this.handle = WeakPointer.new;
    timerTask = [];
  };

  function destroy()
  {
    for( var t: timerTask)
      t.stop |
    updateTask.stop |
    var name = __uobjectName |
    var remote = hasLocalSlot("isRemote") |
    var lob = lobby; // will find this.lobby if we are a remote uobject
    uobjects.removeSlot(__uobjectName);
    // Deregister all callbacks
    handle = nil;
    // Remove reference loops induced by closures.
    for (var f: localSlotNames)
    {
      if (getSlot(f).isA(UVar))
      {
        removeProperty(f + "_quote_n", "updateHook");
      }
    };
    for (var f: localSlotNames.remove("__uobjectName").remove("finalize"))
      removeSlot(f) ;
    // Destroy C++ UObject instance
    if (!remote)
    {
      finalize;
      // Reparent to loose all UObject methods including finalize
      setProtos([Finalizable]);
    }
    else
    {
      if (lob.connected)
      {
         var chan = Channel.new('external'.MODULE_TAG)|
         var chan.lobby = lob|
         chan << ['external'.UEM_DELETE, name];
      }
    }
  };
  var bounceSetUpdate = Event.new;
  at(bounceSetUpdate?(var obj))
  {
    if (0 < obj.updateInterval)
      obj.updateTask: detach(obj.periodicCall(obj.updateInterval,
                                          obj.getSlot("update"),
                                      "update", [obj]));
  };
  /// Set a timer to call update at specified interval in seconds.
  function setUpdate(interval)
  {
    if (0 < interval && interval < minimumInterval)
      interval = minimumInterval;
    // Stop current update task.
    updateTask.stop|
    updateInterval = interval|
    bounceSetUpdate!(this)
  };

  /// Set a timer to call \b func every \b interval milliseconds.
  function setTimer(interval, func)
  {
    if (interval < minimumInterval)
      interval = minimumInterval;
    if (!hasLocalSlot("timerTask"))
      timerTask = [];
    var tag = Tag.new;
    tag: detach({loop{ func(); sleep(interval)}}) |
    timerTask += [tag]
  };

  /// Call hub update function \b for hub \b hubname
  function setHubUpdate(hubname, interval, func)
  {
    if (0 < interval && interval < minimumInterval)
      interval = minimumInterval;
    // Ensure only one instance is running using a tag in slot hub<hubname>.
    var slotName = "hub"+hubname;
    if (!hasSlot(slotName))
      setSlot(slotName, Tag.new);
    getSlot(slotName).stop;
    if (0 < interval)
      getSlot(slotName):
        detach({loop{ func(); sleep(interval)}})
  };
};

/*
 * UVar provides access and change notification on a slot.
 * instanciate with 'UVar.new(containerObject, slotName);
 * call notifyChange(someFunc) to have someFunc called (with no argument)
 * right after a new value is written, call notifyAccess(someFunc) to have
 * someFunc called just before a value is read. The contained value is stored
 * in the 'val' slot of the UVar.
 */
do (getSlot("UVar"))
{

  function init(parent, name)
  {
    parent.setSlot(name, this)|
    parent.setProperty(name, "updateHook", getSlot("update_bounce"))|
    var this.newPropertyHook = getSlot("newPropertyHook_")|
    var slotName = name + "_quote_n"|
    // If the slot was containing a float, it already has a *_quote_n
    // slot, which is not the right one.
    if (parent.hasSlot(slotName))
      parent.removeSlot(slotName) |
    parent.setSlot(slotName, function ()
      {
        var min = parent.getSlot(name).getProperty("val", "rangemin")|
        var max = parent.getSlot(name).getProperty("val", "rangemax")|
        {var r = parent.getSlot(name) | return (r() - min) / (max-min)}
      })|
    parent.setProperty(slotName, "updateHook", function(slot, value)
      {
        var min = parent.getSlot(name).getProperty("val", "rangemin")|
        var max = parent.getSlot(name).getProperty("val", "rangemax")|
        parent.updateSlot(name, min + (max - min) * value)
      })|
    if (not parent.hasLocalSlot("__has_uvar"))
    {
      var parent_getprop = parent.getSlot("getProperty")|
      parent.getProperty = function(varname, propname)
      {
        if (getSlot(varname).isA(UVar))
          getSlot(varname).getProperty("val", propname).acceptVoid
        else
          parent_getprop.apply([this, varname, propname])
      }|
      var parent.__has_uvar = true
    }|
    {}
  };

  /// Global number of notifyaccess
  var nAccess = 0;
  var nAccessTag = Tag.new;
  var onHasNotifyAccess = Event.new;
  function newPropertyHook_(parent, name, prop, value)
  {
   parent.getSlot(name).setProperty("val", prop, value)|
   parent.removeProperty(name, prop)
  };
  var __clone = getSlot("clone");

  removeSlot("clone");
  const var clone = function()
  {
    var uv = __clone;
    do (uv)
    {
      var change = WeakDictionary.new |
      var changeOwned = WeakDictionary.new |
      var access = WeakDictionary.new |
      var owned = false |
      var val |
      var valsensor = 0 |
      var isUVar = 1
    }
  };

  function notifyChange(handle, f)
  {
    change[handle] = f |
    if (change.asList.size == 1)
      detach(loopCheck) |
    void
  };
  function notifyChangeOwned(handle, f)
  {
    changeOwned[handle] = f |
    void
  };
  function notifyAccess(handle, f)
  {
    //beware of the CoW
    getSlot("UVar").nAccess++ |
    access[handle] = f |
    if (access.asList.size == 1)
      detach(loopCheck) |
    if (getSlot("UVar").nAccess == 1)
      onHasNotifyAccess! |
    void
  };
  void
};

/** BypassValue is UValue container which does only cast the content into
 *  an Urbi Object on request.
 */
do (UValue)
{
  var transparent = true;
  function asString()
  {
    if (transparent)
      extract.asString
    else
      id
  };
  function asToplevelPrintable()
  {
     if (transparent)
      extract.asToplevelPrintable
    else
      id.asToplevelPrintable
  };
  var asPrintable = getSlot("asToplevelPrintable");
};

// Can't be in a class or do block.
// Force reevaluation of all at exprs when at least one notifyaccess is present.
// FIXME: find a way to stop when callbacks are removed.
at (getSlot("UVar").onHasNotifyAccess?)
  getSlot("UVar").nAccessTag: loop { sleep(getPeriod)};


class Global.uobjects {};
var Global.uobjects_handle = WeakPointer.new;

// UObjects can use evaluate at initialization-time.
UVar.new(Global,"evaluate");
Global.getSlot("evaluate").notifyChange(uobjects_handle, function()
{
  eval(evaluate)
})|;

Global.uobjects.uobject_init();

Global.addProto(uobjects);

// UObject remote API.

/*------------------.
| Global.external.  |
`------------------*/

class Global.'external'
{
  var MODULE_TAG = "__ExternalMessage__";
  var UEM_EVALFUNCTION = 0;
  var UEM_ASSIGNVALUE  = 1;
  var UEM_EMITEVENT    = 2;
  var UEM_ENDEVENT     = 3;
  var UEM_NEW          = 4;
  var UEM_DELETE       = 5;


  /* external object <objname>: Set clone to send a UEM_NEW message.
  The remote upon reception of the UEM_NEW message 'instantiate <objname>
  with name <newname>' will instantiate the UObject, and send:
  - var <newname>.load, which will fail (<newname> does not exist)
  - class <newname>{} (which will go in the lobby)
  - external object <newname>
  - external var/func <newname>.xxx from whatever

  So in external.object we move the instance from lobby to Global.uobjects and
  recreate <newname>.load, and in our custom cloner, we:
  - send the NEW message passing a uid as <newname>
  - wait until uobjects.<newname>.init is set
  -  return the instance, which is also left in uobjects.<newname> because the
  remote will use it using this name.
  */
  function 'object'(objname)
  {
    nonInterruptible |
    if (uobjects.hasLocalSlot(objname))
      return|
    // The remote sent the code 'class <objname> {};' just before
    // calling this function, but we want objname in uobjects, not
    // lobby.
    if (uobjects not in Global.protos)
      Global.addProto(uobjects)|
    uobjects.setSlot(objname, UObject.new) |
    uobjects.getSlot(objname).setSlot("__uobjectName", objname) |
    uobjects.getSlot(objname).setSlot("isRemote", true) |
    uobjects.getSlot(objname).uobject_init |
    if (!lobby.hasLocalSlot(objname))
    {
      wall("ERROR: lobby has no slot " + objname)
    }|
    for| (var s: lobby.getSlot(objname).localSlotNames)
      uobjects.getSlot(objname).setSlot(s, lobby.getSlot(objname).getSlot(s)) |
    lobby.removeSlot(objname)|
    uobjects.getSlot(objname).setSlot("lobby", lobby) |
    uobjects.getSlot(objname).init() |
    ("external object "+objname).print|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function cloner()
    {
      var u = fresh;
      chan << ['external'.UEM_NEW, u, objname];
      // Wait until the remote defines u.init.
      // FIXME: Use waituntil once it is efficient.
      while(!(Global.uobjects.hasSlot(u)
              && Global.uobjects.getSlot(u).hasLocalSlot("init")))
        sleep(getPeriod) |
      var ret = Global.uobjects.getSlot(u);
      ret.protos = [this];
      ret
    }|
    uobjects.getSlot(objname).setSlot("clone", cloner)|
    //Ensure load is bound. K1 uobj tries to do it before binding the object.
    'var'(objname, "load", "dummy0")|
    void
  };

  /// Notify the remote when <objname>.<varname> is modified.
  function 'var'(objname, varname, fr)
  {
    ("external var call "+varname).print|
    var fullname = objname + "." + varname|

    if (!uobjects.hasSlot(objname))
    {
      if (varname == "load")
        return|
      ("Error: external var called for "+objname+"."+varname).print
    }|
    if (!lobby.hasSlot("handle"))
    {
      var lobby.handle = WeakPointer.new
    }|
    // Ignore duplicate binds of same var.
    var lid = lobby.uid|
    if (!hasLocalSlot(lid))
      setSlot(lid, [])|
    if (fullname in getSlot(lid))
      return|
    getSlot(lid).insertBack(fullname)|
    var obj = uobjects.getSlot(objname)|
    // Setup a hook, notify the remote when a change occurrs.
    if (!obj.hasLocalSlot(varname))
      UVar.new(obj, varname)
    else if (obj.getSlot(varname).isVoid
        || !obj.getSlot(varname).hasSlot("isUVar"))
    {
      // The slot allready exists, but is not an uvar.
      var v = obj.getSlot(varname).acceptVoid|
      obj.removeSlot(varname)|
      UVar.new(obj, varname) |
      if (!v.isVoid())
        obj.updateSlot(varname, v)
    }|
    // Create a 'notifyChange' function that generates the UObject
    // message and sends it through the remote connection.
    var uob = uobjects.getSlot(objname)|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function f()
    {
      var v = uob.getSlot(varname).val.acceptVoid |
      if (!v.isNil && !v.isVoid)
        chan << ['external'.UEM_ASSIGNVALUE,
                 fullname,
                 v]
    }|
    uobjects.getSlot(objname).getSlot(varname).notifyChange(lobby.handle, f)|
    void
  };

  // Bind a function call to the remote side.
  // Write to the slot a function that will generate an uobject call message,
  // send it to the remote side, and wait for the result.
  function 'function'(nargs, objname, fname, fr)
  {
    ("external function call "+fname).print |
    var functionName = objname + "." + fname|
    var chan = Channel.new(MODULE_TAG)|
    var chan.lobby = lobby|
    function f
    {
      var args = call.evalArgs;
      var u = fresh;
      chan << [ 'external'.UEM_EVALFUNCTION,
                functionName + "__" + args.size.asString,
                "Global.uobjects." + u ] + args;
      // FIXME: Use waituntil once it is efficient.
      while (!Global.uobjects.hasSlot(u))
        sleep(getPeriod) |
      var res = Global.uobjects.getSlot(u).acceptVoid;
      Global.uobjects.removeSlot(u);
      res.unacceptVoid
    }|
    Global.uobjects.getSlot(objname).setSlot(fname, f)|
    void
  };
  function eventBounce(starting, evname, args)
  {
    Channel.new(MODULE_TAG) << [
       {if (starting) UEM_EMITEVENT else UEM_ENDEVENT},
       evname] + args
  };
  function 'event'(nargs, objname, ename, fr)
  {
    // FIXME: No way to catch an event with payload without generating the 'at'
    // code.
    var obj = uobjects.getSlot(objname)|
    var fullname = objname+"."+ename+"__" + nargs.asString |
    var key = lobby.uid + fullname |
    if (obj.remoteEventMap.has(key))
      return |
    obj.remoteEventMap[key] = 1 |
    if (not uobjects.getSlot(objname).hasLocalSlot(ename))
      uobjects.getSlot(objname).setSlot(ename, Event.new) |
    var args = nargs.seq.map(function(x) { "p%s" %[x]}).join(", ") |
    var varargs = nargs.seq.map(function(x) { "var p%s" %[x]}).join(", ")|
    var code =
      ("at (uobjects.%s.%s?(%s)) 'external'.eventBounce(true, \"%s\",[%s])"
      + "onleave 'external'.eventBounce(false, \"%s\",[%s])")
    % [objname, ename, varargs, fullname, args, fullname, args]|
    eval(code)
  };
  at (Lobby.onDisconnect?(var l))
  {
    // Remove all the remote uobjects created by this lobby.
    for (var o: uobjects.localSlotNames)
    {
      if (uobjects.getSlot(o).hasSlot("lobby")
	&& uobjects.getSlot(o).lobby === l)
      {
        // Destroy will remove the object from uobjects
        uobjects.getSlot(o).destroy
      }
    }
  };
};
