## ----- ##
## List. ##
## ----- ##

do List
{
  copySlot("nth", "[]");
  copySlot("setNth", "[]=");

  // Whether e is in the list.
  function has(e)
  {
    for| (var i: self)
      if (i == e)
	return true |
    return false
  };

  // FIXME: We need to use a single convention for physical-equality
  // related functions. The first on used was prefix 'mem', as in
  // memSameAs, from Caml. We should either rename this method as
  // memHas, or choose another convention.
  function hasSame(e)
  {
    for| (var i: self)
      if (i === e)
        return true |
    return false
  };

  function sameAs(other)
  {
    if (size != other.size)
      return false|
    var l = self|
    var r = other|
    while (!l.empty && !r.empty)
    {
      if (l.head != r.head)
        return false|
      l = l.tail|
      r = r.tail|
    }|
    return true|
  };

  function '<' (other)
  {
    var l = self|
    var r = other|
    while (!l.empty && !r.empty)
    {
      if (l.head < r.head)
        return true|
      if (l.head > r.head)
        return false|
      l = l.tail|
      r = r.tail|
    }|
    return l.empty|
  };

  // Same contents except occurrences of e.
  // Not in place.
  function remove(e)
  {
    var res = self - [e] |
    clear |
    for| (var i: res)
      push_back (i) |
    res
  };

  // Subtract a list from self.
  function '-' (rhs)
  {
    var res = [] |
    for| (var i: self)
      if (i not in rhs)
	res.push_back(i) |
    return res
  };

  function empty
  {
    return size == 0
  };

  # The Lisp-like name.
  copySlot ("front", "head");
  copySlot ("push_back", "<<");

  function insert(e)
  {
    echo ("List.insert is deprecated, please use List.push_back") |
    push_back(e)
  };

  # Concatenate the string representation of the members, separated by \a sep
  function join(sep)
  {
    if (empty)
      ""
    else
      foldl_head(function (a, b) { a.asString + sep + b.asString })
  };

  # We might want separate Range objects, with a literal syntax (a..b, a:b, ...)
  function range
  {
    var fr = 0;
    var to = size;
    if (call.argsCount >= 3) // FIXME: throw when > 2
    {
      fr = call.argAt(1);
      to = call.argAt(2);
    }
    else
      to = call.argAt(1);
    var res = [];
    for (var i = fr; i < to; i++)
      res << nth(i);
    res;
  };

  # Build a list containing \a size times \a value
  function init(size, value)
  {
    // if (size < 0) throw;
    size.times(closure (i) { self << value })
  };

  ## ------------------------ ##
  ## Functional programming.  ##
  ## ------------------------ ##

  # Build a new list containing the result of \a f applied to all elements
  function map (f)
  {
    var res = [] |
    for| (var i: self) res.push_back (f (i)) |
    res
  };

  function foldl(action, value)
  {
    var res = value|
    for (var l = self; !l.empty; l = l.tail)
      res = action(res, l.head)|
    res
  };

  function foldl_head(action)
  {
    tail.foldl(action, head)
  };

  # Check whether at least one element verifies the \a f predicate
  function any (f)
  {
    for| (var i: self)
      if (f (i))
        return true |
    false
  };

  # Check whether all elements verifies the \a f predicate
  function all (f)
  {
    for| (var i: self)
      if (!f (i))
        return false |
    true
  };

  function filter()
  {
    var res = [] |
    for| (var elt: self)
      if (predicate(elt))
        res << elt |
    return res
  };

  function asString ()
  {
    if (self === List)
      return "<List>" |
    var res = "" |
    if (size)
    {
      res = front.acceptVoid.asPrintable |
      for| (var elt: tail)
        res += ", " + elt.acceptVoid.asPrintable |
    } |
    "[" + res + "]"
  };

  # Pattern matching
  function matchAgainst(handler, pattern)
  {
    if (!pattern.isA(List) || pattern.size != size)
      return false |
    # FIXME: do this with a crossed map
    var i = 0 |
    for (var e : self)
    {
      if (!handler.matchPattern(pattern.nth(i), e))
        return false |
      i++ |
    } |
    return true |
  }
};
