/*-------.
| List.  |
`-------*/

do (List)
{
  protos.insertBack(Global.RangeIterable);

  // Whether e is in the list.
  function has(e)
  {
    any (function (i) { i == e })
  };

  // FIXME: We need to use a single convention for physical-equality
  // related functions. The first on used was prefix 'mem', as in
  // memSameAs, from Caml. We should either rename this method as
  // memHas, or choose another convention.
  function hasSame(e)
  {
    any (function (i) { i === e })
  };

  function keys()
  {
    size.asList
  };

  function '=='(other)
  {
    if (size != other.size)
      return false|
    var l = this|
    var r = other|
    while (!l.empty && !r.empty)
    {
      if (l.head != r.head)
        return false|
      l = l.tail|
      r = r.tail|
    }|
    return true
  };

  function '<' (other)
  {
    var l = this|
    var r = other|
    while (!l.empty && !r.empty)
    {
      if (l.head < r.head)
        return true|
      if (l.head > r.head)
        return false|
      l = l.tail|
      r = r.tail|
    }|
    l.empty && !r.empty
  };

  // Same contents except occurrences of e.
  // Not in place.
  function remove(e)
  {
    var res = this - [e] |
    clear |
    for| (var i: res)
      insertBack (i) |
    res
  };

  // Subtract a list from this.
  function '-' (rhs)
  {
    var res = [] |
    for| (var i: this)
      if (i not in rhs)
	res.insertBack(i) |
    res
  };

  // Add head, symmetric of tail
  copySlot ("front", "head");
  copySlot ("insertBack", "<<");

  // Concatenate the string representation of the members, separated by \a sep
  function join(sep = "", prefix = "", suffix = "")
  {
    sep.join(this, prefix, suffix)
  };

  // We might want separate Range objects, with a literal syntax
  // (a..b, a:b, ...).
  function range(var from, var to = nil)
  {
    if (to.isNil)
    {
      to = from |
      from = 0  |
    }|
    var res = []|
    for| (var i = from; i < to; i++)
      res << this[i] |
    res
  };

  /// Whether the members of this are members of that.
  function subset(var that)
  {
    all(function (var m) { m in that })
  };


  /*-------------------------.
  | Functional programming.  |
  `-------------------------*/

  // Build a new list containing the result of \a f applied to all elements
  function map(f)
  {
    var res = [] |
    for| (var i: this)
      res.insertBack(f(i)) |
    res
  };

  function foldl(action, value)
  {
    var res = value|
    for (var l = this; !l.empty; l = l.tail)
      res = action(res, l.head)|
    res
  };

  function foldl_head(action)
  {
    tail.foldl(action, head)
  };

  // Whether at least one element verifies the \a f predicate.
  function any (f)
  {
    for| (var i: this)
      if (f (i))
        return true |
    false
  };

  // Whether all the elements verify the \a f predicate.
  function all(f)
  {
    for| (var i: this)
      if (!f (i))
        return false |
    true
  };

  // The list of elements verifying the \a f predicate.
  function filter(f)
  {
    var res = [] |
    for| (var elt: this)
      if (f(elt))
        res << elt |
    res
  };

  // Pattern matching.
  function matchAgainst(handler, pattern)
  {
    if (!pattern.isA(List) || pattern.size != size)
      return false |
    // FIXME: do this with a crossed map
    var i = 0 |
    for| (var e : this)
    {
      if (!handler.matchPattern(pattern[i], e))
        return false |
      i++ |
    } |
    return true
  };

  function min(var comp = function (a, b) { a < b })
  {
    if (empty)
      throw Exception.new("list cannot be empty") |
    var res = head|
    for| (var elt in tail)
      if (comp(elt, res))
        res = elt |
    res
  };

  function max(var comp = function (a, b) { a < b })
  {
    min(function (a, b) {!comp(a, b)})
  };
};
