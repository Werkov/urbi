## ------- ##
## Float.  ##
## ------- ##

do Float
{
  addProto(Comparable);
  addProto(Orderable);

  function init(x) { self.set(x) };

  function sqr() { self * self };

  function '~='(x) { (self - x).abs <= epsilontilde };
  function '%='(x) { (1.0 - self / x).abs <= epsilonpercent };
  # FIXME: =~= cannot be correctly implemented without properties.
  function '=~='(x) { (self - x) <= self.delta + x.delta };
  function sgn() { if (self < 0) -1 else if (self > 0) 1 else 0 };

  // Create a list 0..(self - 1).
  function seq()
  {
    var result = [] |
    for| (var i = 0; i < self; i++)
      result.push_back(i.clone) |
    result
  };

  function '\'n'()
  {
    (self - self.rangemin) / (self.rangemax - self.rangemin)
  };

  function getNormHook() {
    function(n, value) {
      var rmin = self.rangemin|
      var rmax = self.rangemax|
      value = value*(rmax-rmin) + rmin|
      var value.rangemin = rmin|
      var value.rangemax = rmax|
      value.setProperty("'n", "updateHook",
	Float.getNormHook.inject("parent",parent).inject("name", name) )|
      parent.changeSlot(name, value)|
    }
  };

  function propertyHook(parent, name, prop, value)
  {
    function override_if(predicate, value)
    {
      function hook(slot, val)
      {
        if (predicate(val))
          return value |
        return val |
      };
      if (!parent.hasProperty(name, "updateHook"))
        parent.setProperty(name, "updateHook", getSlot("UpdateHookStack").new);
      parent.getProperty(name, "updateHook").slotNames.print;
      parent.getProperty(name, "updateHook").addHook(hook);
    };

    # FIXME: this doesn't scale to several propertyHooks ...
    switch (prop)
    {
      case "rangemin":
        override_if(closure (v) { v < value }, value);
      case "rangemax":
        override_if(closure (v) { v > value }, value);
    };
  };

  # Repeat \a action \a self times.
  function times (action)
  {
    for| (var i = 0; i < self; i++)
      action(i)
  };
};


