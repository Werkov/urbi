## ------- ##
## Float.  ##
## ------- ##

do Float
{
  addProto(Comparable);
  addProto(Orderable);

  function init(x) { self.set(x) };

  function sqr() { self * self };

  function '+='(x) { self.set (self + x) };
  function '-='(x) { self.set (self - x) };
  function '*='(x) { self.set (self * x) };
  function '/='(x) { self.set (self / x) };

  // One would like to write
  //
  // function '++' () { var res = self.clone | self += 1 | res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-proto.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  function '++'() { var res = 0 | res.set(self) | self += 1 | res };
  function '--'() { var res = 0 | res.set(self) | self -= 1 | res };
  function '~='(x) { (self - x).abs <= epsilontilde };
  function '%='(x) { (1.0 - self / x).abs <= epsilonpercent };
  # FIXME: =~= cannot be correctly implemented without properties.
  function '=~='(x) { (self - x) <= self.delta + x.delta };
  function sgn() { if (self < 0) -1 else if (self > 0) 1 else 0 };

  function '!'() { self == 0 };

  // Create a list 0..(self - 1).
  function seq()
  {
    var result = [] |
    for| (var i = 0; i < self; i++)
      result.push_back(i.clone) |
    result
  };

  function propertyHook(parent, name, prop, value)
  {
    var modifiers = ["speed"]|
    if (!modifiers.has(prop))
      return|
    parent.setProperty(name, "updateHook",
    function (name, value) {
      var mod = (||)|
      if (parent.hasProperty(name, "speed"))
        _setSlot(mod, "speed", parent.getProperty(name, "speed"))|
      var g = TrajectoryGenerator.new(getSlot(name), value, mod)|
      var t = Tag.new|
      t: every(100) { # FIXME: Don't use an arbitrary period.
	if (g.isOver)
          t.stop|
	changeSlot(name, g.get(getSlot(name)))
      }|
    }.capture("parent"));
  }
};


