## ------- ##
## Float.  ##
## ------- ##

do Float
{
  addProto(Comparable);
  addProto(Orderable);

  function init(x) { self.set(x) };

  function sqr() { self * self };

  function '+='(x) { self.set (self + x) };
  function '-='(x) { self.set (self - x) };
  function '*='(x) { self.set (self * x) };
  function '/='(x) { self.set (self / x) };

  // One would like to write
  //
  // function '++' () { var res = self.clone; self += 1; res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-proto.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  function '++'() { var res = 0 | res.set(self) | self += 1 | res };
  function '--'() { var res = 0 | res.set(self) | self -= 1 | res };
  function '~='(x) { (self - x).abs <= epsilontilde };
  function '%='(x) { (1.0 - self / x).abs <= epsilonpercent };
  # FIXME: =~= cannot be correctly implemented without properties.
  function '=~='(x) { (self - x) <= self.delta + x.delta };
  function sgn() { if (self < 0) -1 else if (self > 0) 1 else 0 };

  function '!'() { self == 0 };

  // Create a list 0..(self - 1).
  function seq()
  {
    var result = [] |
    for| (var i = 0; i < self; i++)
      result.push_back(i.clone) |
    result
  };
};


