do (Object)
{
  // Syntactic sugar for setProtos.
  protos->updateHook = function(slot, value) { setProtos(value); };

  // Cannot use "from" which is a k1 reserved word.
  function copySlot(frm, to)
  {
    setSlot(to, getSlot(frm))
  };

  function cloneSlot(frm, to)
  {
    setSlot(to, getSlot(frm).clone)
  };

  // Some sort of k1 compatibility.
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  // Change the whole set of parents.
  function setProtos(ps)
  {
    // Beware that we may be losing the ancestry on Object, which has
    // access to "addProto".
    var add = Object.getSlot("addProto") |
    protos.clear() |
    for| (var p: ps.reverse)
      add.apply([this, p]) |
  };

  function '!==' (rhs)
  {
    !(this === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };

  /*--------------.
  | Conversions.  |
  `--------------*/

  function as(type)
  {
    getSlot("as" + type.type).apply([this])
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };

  function format (f = FormatInfo)
  {
    asPrintable.format(f)
  };

  function asPrintable ()
  {
    asString
  };

  function asToplevelPrintable ()
  {
    asPrintable
  };


  /*--------.
  | Slots.  |
  `--------*/
  function ownsSlot(s)
  {
    warn("`o.ownsSlot(s)' is deprecated, use `o.hasLocalSlot(s)'") |
    hasLocalSlot(s)
  };

  function slotNames()
  {
    warn("the semantics of `slotNames' is about to change from"
         " `localSlotNames' to `allSlotNames', consistently with"
         " `hasLocalSlot'/`hasSlot'.  In the meanwhile please use"
         "  either `localSlotNames' or `allSlotNames'") |
    localSlotNames
  };

  function isProto()
  {
    hasLocalSlot("type")
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  function bounce_named (fn)
  {
    function (x)
    {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };

  // Tasks.
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };

  function inspect (var deep = false)
  {
    function '<' (l, r) { l.toLower < r.toLower };
    echo("Inspecting " + this);
    echo("** Prototypes:");
    for (var p: protos)
      echo("  " + p);
    var slots =
      {
        if (deep)
        {
          echo("** All Slots:");
          allSlotNames;
        }
          else
        {
          echo("** Local Slots:");
          localSlotNames;
        }
      };
    for (var s: slots.sort ('<'))
    {
      var o = locateSlot(s);
      echo("  " + o + "." + s + " : " + o.getSlot(s).type);
      var ps = o.properties(s);
      if (!ps.empty)
        {
          echo("    Properties:");
          for (var p: ps.keys.sort('<'))
            echo("     " + p + " : " + ps[p].type + " = " + ps[p]);
        }
    };
  };
};
