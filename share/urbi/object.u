do (Object)
{
  // Syntactic sugar for setProtos.
  protos->updateHook = function(slot, value) { setProtos(value); };

  function 'class'(var name, var protos = [])
  {
    var res = Object.clone |
    if (protos)
      res.setProtos(protos) |
    var res.'$type' = name |
    res.setSlot("as" + name, function () { this })|
    res
  };

  function cloneSlot(from, to)
  {
    setSlot(to, getSlot(from).clone)
  };

  function copySlot(from, to)
  {
    setSlot(to, getSlot(from))
  };

  // Change the whole set of parents.
  function setProtos(ps)
  {
    // Beware that we may be losing the ancestry on Object, which has
    // access to "addProto".
    var add = Object.getSlot("addProto") |
    protos.clear() |
    for| (var p: ps.reverse)
      add.apply([this, p]) |
  };

  function '!==' (rhs)
  {
    !(this === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };

  /*--------------.
  | Conversions.  |
  `--------------*/

  function as(type)
  {
    getSlot("as" + type.'$type').apply([this])
  };

  // To be overridden by subclasses.
  function asString()
  {
    '$id'
  };

  function format(f = FormatInfo)
  {
    asString.format(f)
  };


  /*--------.
  | Slots.  |
  `--------*/
  function ownsSlot(s)
  {
    warn("`o.ownsSlot(s)' is deprecated, use `o.hasLocalSlot(s)'") |
    hasLocalSlot(s)
  };

  function slotNames()
  {
    warn("the semantics of `slotNames' is about to change from"
         " `localSlotNames' to `allSlotNames', consistently with"
         " `hasLocalSlot'/`hasSlot'.  In the meanwhile please use"
         "  either `localSlotNames' or `allSlotNames'") |
    localSlotNames
  };

  function isProto()
  {
    hasLocalSlot("$type")
  };

  // Gives type, + uid if relevant
  function '$id'()
  {
    var res = '$type' | 
    if (!isProto)
      res += "_" + uid |
    res
  };

  function bounce_named (fn)
  {
    function (x)
    {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };

  // Tasks.
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };

  function inspect (var deep = false)
  {
    function '<' (l, r) { l.toLower < r.toLower };
    echo("Inspecting " + this.asPrintable);
    echo("** Prototypes:");
    for (var p: protos)
      echo("  " + p.asPrintable);
    var slots =
      {
        if (deep)
        {
          echo("** All Slots:");
          allSlotNames;
        }
        else
        {
          echo("** Local Slots:");
          localSlotNames;
        }
      };
    for (var s: slots.sort ('<'))
    {
      var o = locateSlot(s);
      echo({
             if (!deep)
               "  "
             else if (o === this)
               "  this."
             else
               "  %s." % o.asPrintable
           }
           + "%s : %s"
              % [s, o.getSlot(s).'$type']);
      if (var ps = o.properties(s))
      {
        echo("    Properties:");
        for (var p: ps.keys.sort('<'))
          echo("     %s : %s = %s"
               % [p, ps[p].'$type', ps[p].asPrintable]);
      }
    };
  };
};
