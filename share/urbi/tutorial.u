class Global.tutorial
{
  # Don't use the topLevel channel, since it quotes the \n and so on.
  class tuto : Channel
  {
    init("tuto");
    quote = false;
    var line = "-" * 76 + "\n";
    # A special "<<" that puts the result between lines.
    function '<<' (s)
    {
      lobby.write("\n" + line + s + "\n" + line)
    };
  };
  var  debug = Channel.new("debug");
  debug.enabled = false;
  class entry
  {
    var tuto = Global.tutorial.tuto;
    var debug = Global.tutorial.debug;
    var tag;
    var entry;
    function init2
    {
      var self.name = call.argAt(1);
      var self.text = call.argAt(2);
      var self.onEnter = call.args.nth(3);
      var self.onLeave = call.args.nth(4);
      var self.condition = call.args.nth(5);
      tutorial.entries.back.push_back(self);
    };
    function enter()
    {
      tuto << text;
      tag = Tag.new;
      onEnter.eval;
      debug << ("setting condition for " + name );
      tag:detach({
		 debug << ("waiting condition for " + name );
		 waituntil(condition.eval);
		 debug << ("switching to next from " + name );
		 tutorial.next2;
		 debug << ("terminating " + name );
      });
    };
    function leave()
    {
      onLeave.eval;
    };
  };

  var content = Dictionary.new;
  var entries = [[]];
  var sectionNames = [];
  var sectionIdByName = Dictionary.new;
  var sectionDescs = [];
  var current = -1;
  var currentSection = 0;
  function next2()
  {
    debug << "next ";
    if (0 <= current)
      entries.nth(currentSection).nth(current).leave;
    current++;
    if (entries.nth(currentSection).size <= current)
    {
      currentSection++;
      current = 0;
      //cerr << "switching section "+currentSection.asString +" para "+current;
      if (entries.size <= currentSection)
      {
	tuto << "The tutorial is over";
	current = -1;
	currentSection = 0;
	return;
      }
      else
      {
	tuto << "Starting next tutorial section: "
	 + sectionDescs.nth(currentSection-1);
      }
    };
    debug << "entering section "+currentSection.asString +" para "+current;
    entries.nth(currentSection).nth(current).enter;
  };

  function next()
  {
    if (current >= 0)
      entries.nth(currentSection).nth(current).tag.stop;
    next2
  };

  function help()
  {
    tuto <<
      "Tutorial commands:\n"+
      "  next;       : jump to the next paragraph\n"+
      "  sections;   : list tutorial sections\n"+
      "  jump(\"s\");  : jump to section 's'";
  };

  function sections()
  {
    var s = "Tutorial sections:\n";
    for (var i=0; i<sectionNames.size; i++)
    {
      s +=  "  " + sectionNames.nth(i)+": "+sectionDescs.nth(i)+"\n";
    };
    tuto << s;
  };
  function jump(sectionName)
  {
    if (!sectionIdByName.has(sectionName))
    {
      tuto << ("Unknown tutorial section "+sectionName);
      return
    }
    else
    {
      if (current >=0)
	entries.nth(currentSection).nth(current).leave;
      current = 0;
      currentSection = sectionIdByName.get(sectionName) + 1;
      entries.nth(currentSection).nth(current).enter;
    };
  };

  function startSection(name, desc)
  {
    var i = sectionNames.size;
    sectionIdByName.set(name, i);
    sectionNames.push_back(name);
    sectionDescs.push_back(desc);
    entries.push_back([]);
  };

  startSection("presentation", "an overview of the kernel");
  entry.new.init2("intro",
"Welcome to the very first Urbi kernel 2 Technical preview!
Urbi v2 is a programming language which:
  - is object oriented and prototype based
  - is dynamically scoped
  - has primitives for parallelism
  - has advanced control-flow primitives (tags)
This simple tutorial will assist you in the discovery of its main features.
At any time, you can type 'next;' to jump to the the next tutorial entry.",{},{},false);
  // init cant take a call message with tech-preview version of k2
   entry.new.init2("object",
	       "Everything in urbi is an object. An object is defined by its list of parents and its list of slots (key->object pairs). The top of the hierarchy is called Object. The syntax for creating a new slot is 'var anObject.aSlot = avalue. To go on, create a slot named 'foo' in 'Object'.", {}, {}, Object.slotNames.has("foo"));
   entry.new.init2("object2", "Now add a slot bar to Object.foo",
		     {
		       if (!Object.slotNames.has("foo"))
			 var Object.foo = 1;
		     }, {}, {Object.foo.slotNames.has("bar")});
   startSection("More advanced stuffs", "Stuffs that are more complicated");
   entry.new.init2("stuffs", "This is a placeholder.", {}, {}, false);
   entry.new.init2("end", "this marks the end of the urbi tutorial!", {},{},
		     false);
   entry.new.init2("pastend", "I told you it was over!", {}, tutorial.current--, false);
};

//Inheriting Tutorial rather? COW will screw everything up

//FIXME: replace by the code below when implicit closures will work
function Global.next() { tutorial.next};
function Global.sections() { tutorial.sections};
function Global.jump(s) { tutorial.jump(s)};
/*
for (var s: ["next", "sections", "jump"])
  Global.setSlot(s, function() {tutorial.getSlot(s).apply([tutorial]);});
*/
Global.help = function() {tutorial.help};

next;
