class Global.Tutorial {};

do Global.Tutorial
{

  // Don't use the topLevel channel, since it quotes the \n and so on.
  class channel : Channel
  {
    init("tutorial");
    quote = false;
    var line = "-" * 76 + "\n";
    // A special "<<" that puts the result between lines.
    function '<<' (s)
    {
      lobby.write("\n" + line + s + "\n" + line)
    };
  };

  var  debug = Channel.new("debug");
  debug.enabled = false;

  class Entry
  {
    var channel = Global.Tutorial.channel;
    var debug = Global.Tutorial.debug;
    var tag;
    var entry;

    // init(name of the section, explanation text,
    //       code to run when entering,
    //       code to run when leaving (either via "next" or automatically,
    //             typically used to ensure some conditions expected by
    //             the following sections),
    //       condition to fulfill to pass automatically to the next section).
    function init
    {
      var this.name = call.argAt(1);
      var this.text = call.argAt(2);
      var this.onEnter = call.args.nth(3);
      var this.onLeave = call.args.nth(4);
      var this.condition = call.args.nth(5);
      Tutorial.entries.back.push_back(this);
    };

    function enter()
    {
      channel << text;
      tag = Tag.new;
      onEnter.eval;
      debug << ("setting condition for " + name );
      tag:detach({
		 debug << ("waiting condition for " + name );
		 waituntil(condition.eval);
		 debug << ("switching to next from " + name );
		 Tutorial.doNext;
		 debug << ("terminating " + name );
      });
    };

    function leave()
    {
      onLeave.eval;
    };
  };

  var content = Dictionary.new;
  var entries = [[]];
  var sectionNames = [];
  var sectionIdByName = Dictionary.new;
  var sectionDescs = [];
  var current = -1;
  var currentSection = 0;

  function doNext()
  {
    debug << "next ";
    if (current >= 0)
      entries.nth(currentSection).nth(current).leave;
    current++;
    if (current >= entries.nth(currentSection).size)
    {
      currentSection++;
      current = 0;

      if (entries.size <= currentSection)
      {
	channel << "The tutorial is over";
	current = -1;
	currentSection = 0;
	return;
      }
      else
      {
	channel << "Starting next tutorial section: "
	 + sectionDescs.nth(currentSection-1);
      }
    };
    debug << "entering section "+currentSection.asString +" para "+current;
    entries.nth(currentSection).nth(current).enter;
  };

  function next()
  {
    if (current >= 0)
      entries.nth(currentSection).nth(current).tag.stop;
    doNext
  };

  function help()
  {
    channel <<
      "Tutorial commands:\n"+
      "  next;       : jump to the next paragraph\n"+
      "  sections;   : list tutorial sections\n"+
      "  jump(\"s\");  : jump to section 's'";
  };

  function sections()
  {
    var s = "Tutorial sections:\n";
    for (var i=0; i<sectionNames.size; i++)
    {
      s +=  "  " + sectionNames.nth(i)+": "+sectionDescs.nth(i)+"\n";
    };
    channel << s;
  };

  function jump(sectionName)
  {
    if (sectionName not in sectionIdByName)
    {
      channel << ("Unknown tutorial section "+sectionName);
      return
    }
    else
    {
      if (current >=0)
	entries.nth(currentSection).nth(current).leave;
      current = 0;
      currentSection = sectionIdByName.get(sectionName) + 1;
      entries.nth(currentSection).nth(current).enter;
    };
  };

  function startSection(name, desc)
  {
    var i = sectionNames.size;
    sectionIdByName.set(name, i);
    sectionNames.push_back(name);
    sectionDescs.push_back(desc);
    entries.push_back([]);
  };

  startSection("presentation", "an overview of the kernel");

  Entry.new("intro",
"Welcome to the Urbi 2 Technical preview!

Urbi v2 is a programming language which:
  - is object oriented and prototype based
  - is dynamically scoped
  - has primitives for parallelism
  - has advanced control-flow primitives (tags)

This simple tutorial will assist you in the discovery of its main features.
At any time, you can type 'next;' to jump to the the next tutorial entry.",{},{},false);
  // init cant take a call message with tech-preview version of k2
   Entry.new("object",
"Everything in Urbi is an object.

An object is defined by its parents (a list of objects) and its
slots (or \"members\", or \"attributes\": a mapping from names to objects).

The top of the hierarchy is \"Object\".

To create a new slot, run

	var anObject.aSlot = avalue;

To go on, create a slot named 'foo' in 'Object'.", {}, {}, { "foo" in Object.slotNames} );
   Entry.new("object2", "Now add a slot bar to Object.foo",
		     {
		       if ("foo" not in Object.slotNames)
			 var Object.foo = 1;
		     }, {}, {"bar" in Object.foo.slotNames});
   startSection("More advanced stuffs", "Stuffs that are more complicated");
   Entry.new("woot", "trop fort", {}, {}, false);
   Entry.new("end", "this marks the end of the urbi tutorial!", {},{},
		     false);
   Entry.new("pastend", "I told you it was over!", {}, Tutorial.current--, false);
};

// Don't try to inherit Tutorial instead, COW will screw everything up

for (var s: ["next", "sections", "jump"])
  Global.setSlot(s, function() {Tutorial.getSlot(s).apply([Tutorial]);});

function Global.help() {Tutorial.help};

next;
