var errBacktrace = Regexp.new("^\\[[0-9]{8}:(error|warning)\\] \\!\\!\\!    called from")|;
var outClog = Regexp.new("^\\[[0-9]{8}:clog\\]");
var objAddr = Regexp.new("(_0x[0-9a-f]{1,12})([^0-9a-f]|$)");
var objAddr2 = Regexp.new("(uob_[0-9a-f]{1,12})([^0-9a-f]|$)");
var disconnecting = Regexp.new("\\*\\*\\* disconnecting Lobby_");

function Object.splitNewline(s)
{
  var res = []|
  var l = s.split("\r\n")|
  for( var i: l)
    res += i.split("\r")|
  l = []|
  for( var i: res)
    l += i.split("\n")|
  l
};

function splitChk(content)
{
  var reqs = [];
  var sin = [];
  var sout = [];
  var rOutput = Regexp.new("^\\[[0-9]{8}(:[a-zA-Z0-9_]+)?\\]");
  var rVarError = Regexp.new("!!! input.u:@([+-]?[0-9]+)?\\.[0-9]+(-@([+-]?[0-9]+))?");
  var rOutputCont = Regexp.new("^\\[:]");
  var rDirective = Regexp.new("^//#");
  var line = 1;
  for (var l: content)
  {
    if (rDirective.match(l))
    {
      reqs << l[3, 0].trim().split(" ");
      echo("Adding directive " + reqs[-1]);
    };
    // Leave directive go in the file
    if (errBacktrace.match(l))
    {
      sin << "";
      ++line;
    }
    else if (rOutput.match(l))
    {
      // Additional transformations
      if (rVarError.match(l))
      {
        var nLine = line-1;
        if (rVarError.matches[1])
          nLine -= System.eval(rVarError.matches[1]);
        l = l.replace("@" + rVarError.matches[1], nLine.asString());
        if (rVarError.matches[3])
        {
          nLine = line - 1 - System.eval(rVarError.matches[3]);
          l = l.replace("@" + rVarError.matches[3], nLine.asString());
        }
      };
      while (objAddr.match(l))
      {
        l = l.replace(objAddr.matches[1], "_0xADDR");
      };
      sout << ("[00000000" + l[9, 0]);
      sin << "";
      ++line;
    }
    else if (rOutputCont.match(l))
    {
      if (l.size == 3)
        sout << ""
      else
        sout << l[3, 0];
      sin << "";
      ++line;
    }
    else
    {
      sin << l;
      ++line;
    };
  };
  (reqs, sin, sout)
}|;

function fetchTestU(chkFile)
{
  var res = "";
  var levels = chkFile.split("/").size();
  var p = Path.new(chkFile).dirname;
  while (levels >= 0)
  {
    echo("Scanning " + Directory.current / p);
    try
    {
      var f = File.new(p / "test.u");
      echo("Adding " + (p / "test.u"));
      res += "//#line 1 \"" + (p/"test.u").asString() + "\"\n" + f.content.data;
    }
    catch(var e) {echo(e)};
    --levels;
    p = p.dirname;
  };
  res;
}|;

function startRemote(names)
{
  var map = ["all" => ["remall", "remall2"], "rtp"=>["URTP"]];
  var args = ["--remote"];
  args += names;
  args += ["--", "--host", "127.0.0.1", "--port", System.listenPort.asString()];
  var p = Process.new("sdk/bin/urbi-launch", args);
  p.runTo("remote.out");
  // find uobject name
  for(var name: names)
  {
    var base = name.split("/")[-1];
    var uobjs = [base];
    if (map.has(base))
      uobjs = map[base];
    for|(var uo: uobjs)
    {
      echo("waiting for " + uo);
      timeout(8s) waituntil(uobjects.hasLocalSlot(uo));
      echo("got it");
    };
  };
  p
}|;

function runTest(chkFile)
{
  var processes = [];
  // Tests are run in build dir
  System.setenv("URBI_SHARE", (System.urbiRoot / "../../share").asString());
  var debug = Logger.new("test");
  debug.'<<' = function(x) { this.log(x)};
  //debug.level = Logger.level.Dump;
  var content = splitNewline(File.new("../tests/" + chkFile).content().data);
  (var reqs, var sin, var sout) = splitChk(content);
  var testu = fetchTestU("../tests/" + chkFile);
  debug << ("input: " + sin);
  debug << ("expected output: " + sout);
  debug << "Creating lobby...";

  var eout = [];

  // Process directives...
  for(var i: reqs)
  {
    switch(i[0])
    {
    case "plug":
      for(var m: i.tail())
        System.loadModule(m);
    case "uobject":
      if (chkFile.find("remote/") != -1)
      {
        processes << startRemote(i.tail());
      }
      else
      {
      for|(var m: i.tail())
        System.loadModule(m);
      };
    case "remote":
        processes << startRemote(i.tail());
    }
  };

  // override all output to redirect to us
  Lobby.write->constant = false;
  Lobby.send->constant = false;
  Lobby.wall->constant = false;
  var lw = Lobby.write;
  var ls = Lobby.send;
  var debugOut = System.getenv("TEE_TEST_OUTPUT");
  Lobby.write = function(s)
  {
    if (hasLocalSlot("remoteIP"))
      lw(s)
    else if (this == Lobby)
    {
      var write = lw|
      write(s)
    }
    else
    {
      if (debugOut)
        lw(s)|
      for|(var i: Object.splitNewline(s))
        eout << i |
      {}
    }
  };
  Lobby.send = function(msg, tag="":String)
  {
    if (hasLocalSlot("remoteIP"))
      ls(msg, tag)
    else if (this == Lobby)
    {
      var send = ls | // to get correct error message
      send(msg, tag)
    }
    else
    {
      if (tag)
        tag = ":" + tag|
      write("[00000000" + tag + "] " + msg.asString())|
      {}
    }
  };
  Lobby.wall = function(msg, tag="")
  {
    for| (var l in instances - [Lobby, systemLobby])
    l.echo(msg, tag);
  };
  Lobby.write->constant = true;
  Lobby.send->constant = true;
  Lobby.wall->constant = true;
  /* ALTERNATE HACK, but does not catch tests playing with systemLobby.
  // Override Lobby.create to redirect to us
  var lc = Lobby.create;
  Lobby.create->constant = false;
  Lobby.create = function()
  {
    var l = lc.apply([Lobby]);
    // Redirect its output to effOut
    l.write = function(s) { for|(var i: splitNewline(s)) eout << i | {}};
    l.send = function(msg, tag="":String)
    {
      if (tag)
        tag = ":" + tag|
      write("[00000000" + tag + "] " + msg.asString())|
      {}
    };
    l
  };
  Lobby.create->constant = true;
  */

   // Create a lobby for the test
  var l = Lobby.create();
  var ID = "_" + l.uid.asString();
  // Use a variable to detect end of test
  if (Object.test_finished.hasLocalSlot(ID))
    Object.test_finished.removeSlot(ID);
  debug << "Injecting test.u";
  l.receive(testu);
  debug << "Injecting input...";
  l.receive("//#line 1 \"input.u\"\n");
  l.receive(sin.join("\n"));
  l.receive("var Object.test_finished." + ID + "=1|;\n");
  debug << "Waiting for test to finish...";
  // In fast mode, time of timeout is inpacted too
  timeout(1h) waituntil(Object.test_finished.hasLocalSlot(ID));
  Lobby.write->constant = false;
  Lobby.send->constant = false;
  Lobby.write = lw;
  Lobby.send = ls;
  for(var p: processes)
  {

    write("REMOTE: " + p.status + "\n");
    p.kill();
    p.join();
    //write(p.stdout.content());
    //write(p.stderr.content());
    write("\nEND REMOTE\n");
  };
  if (!Object.test_finished.hasLocalSlot(ID))
  {
    write("EFFECTIVE:\n<< "  +eout.join("\n<< ") + "\n\n");
    throw "timeout";
  };
  debug << "Done";
  var effOut = eout;
  var rawEffOut = effOut;
  // Filter out stuff in effOut
  //   error backtrace
  effOut = effOut.filter(closure(x) { !errBacktrace.match(x)});
  //  log messages
  effOut = effOut.filter(closure(x) { !outClog.match(x)});
  //  lobby disconnect message (appear at random place)
  effOut = effOut.filter(closure(x) { !disconnecting.match(x)});
  var rExpecting = Regexp.new("unexpected.*(, expecting .*$)");
  effOut = effOut.map(closure(l) {
      while (objAddr.match(l))
        l = l.replace(objAddr.matches[1], "_0xADDR")|
      while (objAddr2.match(l))
        l = l.replace(objAddr2.matches[1], "uob_0xADDR")|
      if (rExpecting.match(l))
        l = l.replace(rExpecting.matches[1], "")|
      l
  });
  debug << ("Test output: " + effOut);

  // Compare expected and effective
  // Some additional changes may be required, go line by line
  var failed = effOut.size != sout.size;
  var line = 0;
  while (!failed && line < effOut.size)
  {
    var eff = effOut[line]|
    var exp = sout[line]|
    if (eff != exp)
    {
      // Additional checks
      // <TIMESTAMP>
      var m = exp.find("<TIMESTAMP>");
      if (m>=0)
      {
        var rDouble = Regexp.new("[-+0-9.]+"); // close enough
        if (eff.size > m)
        {
          if (rDouble.match(eff[m, 0]))
            eff = eff.replace(rDouble.matches[0], "<TIMESTAMP>")
        }
      };
      failed = (eff != exp)
    };
    ++line;
  };
  if (failed)
  {
    write("SOURCE:\n" + content.join("\n") + "\n\n");
    write("INPUT:\n" + sin.join("\n") + "\n");
    write("RAW EFFECTIVE:\n" + rawEffOut.join("\n<< ") + "\n\n");
    write("EXPECTED:\n>> " + sout.join("\n>> ") + "\n\n");
    write("EFFECTIVE:\n<< "  +effOut.join("\n<< ") + "\n\n");
    write("\n");
    if (System.getenv("DUMP_TEST_RESULT"))
    {
      OutputStream.new(File.create("/tmp/out.exp")) << sout.join("\n");
      OutputStream.new(File.create("/tmp/out.eff")) << effOut.join("\n");
    };
    debug << "FAIL"|
    false
  }
  else
    true
}|;

var Object.test_finished = Object.new()|;

function main()
{
  System.addSystemFile("urbi/run-test.u");
  var tok = 0;
  var tko = 0;
  var terr = 0;
  for (var test: System.arguments)
  {
    echo("running %s..." % test)|
    try
    {
      if (runTest(test))
        ++tok
      else
        ++tko
    }
    catch(var e)
    {
      ++terr;
      echo("Exception in test: " + e);
      e.backtrace().print();
    };
  };
  if (System.arguments.size > 1)
    write("TEST SUITE RESULT: %s / %s OK\n" % [ tok, System.arguments.size]);
  tok ==  System.arguments.size
}|;

if (!System.getenv("NO_MAIN"))
{
  var result = main();
  System._exit({ if (result) 0 else 1});
};
