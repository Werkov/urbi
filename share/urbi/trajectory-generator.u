class Global.TrajectoryGenerator
{
  function init(startValue, targetValue, args)
  {
    self.targetValue = targetValue|
    self.startTime = time|
    self.startValue = startValue |
    var content = Global._slotNames(args)|
    if (content.has("time"))
    {
      var self.get = getSlot("timeGet") |
      var self.duration = _getSlot(args, "time") |
      var self.adaptive = _getLazyLocalSlot(args, "adaptive", 0, false)
    }
    else if (content.has("accel"))
    {
      var self.get = getSlot("accelGet") |
      var self.accel = args.getSlot("accel") |
      var self.duration = sqrt ( 2 * (targetValue - startValue) / accel)
    }
    else if (content.has("speed"))
    {
      var self.adaptive = _getLazyLocalSlot(args, "adaptive", 0, false) |
      var self.speed = args.speed;
      var self.duration = abs(startValue - targetValue) * 1000 / speed |
      if (!adaptive)
      {
      var self.get = getSlot("timeGet")
      }
      else
      {
	var self.get = getSlot("adaptiveSpeedGet")
      }
    }
    else if (content.has("sin") || content.has("cos"))
    {
      var self.get = getSlot("sinGet");
      var self.phase = _getLazyLocalSlot(args, "phase", 0, false) |
      var self.ampli = _getLazyLocalSlot(args, "ampli", 0, false) |
      if (content.has("cos"))
      {
	var self.period =  args.cos |
	self.phase += pi/2
      }
      else
	var self.period = args.sin
    }
  };

  # Update slot \a name in \a owner accordingly to the trajectory.
  # Blocking until the trajectory is over.
  function run(owner, name)
  {
    var tag = Tag.new|
    tag:
    {
      every(100) # FIXME: Don't use an arbitrary period.
      {
	if (isOver)
          tag.stop|
	owner.changeSlot(name, get(owner.getSlot(name)))
      }|
      sleep(inf)
    }|
  };

  var startValue = 0;
  var startTime;
  var targetValue;
  var isOver = false;

  function timeGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };
  function sinGet(currentVal)
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };
  function accelGet(currentVal)
  {
    if (time - startTime > duration)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };
  function adaptiveSpeedGet(currentVal)
  {
     var nextVal = currentVal + speed * sgn(targetValue - currentVal);
     if ((currentVal < targetValue && targetValue < nextVal)
       || (nextVal < targetValue && targetValue < currentVal))
     {
       isOver = true |
       nextVal = targetValue
     } |
     nextVal
  };
};
