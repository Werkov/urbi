/*----------------------.
| TrajectoryGenerator.  |
`----------------------*/
class Global.TrajectoryGenerator
{
  // Initialization: Instantiate one of the sub classes.
  function init(getter, setter, targetValue, args)
  {
    var this.getter = getter |
    var this.setter = setter |
    var this.targetValue = targetValue|
    var this.startTime = time|
    // Sin does not need it, but it is simpler to call it anyway as it
    // allows to depend on startValue below.  And besides, it allows
    // to enforce a proper initial value for Sin too.
    getStartValue()|
    var adaptive = args.getWithDefault("adaptive", false);
    protos =
      [{
        if ("accel" in args)
          Accel
        else if ("cos" in args)
        {
          // Bounce to a sine.
          args["phase"] = args.getWithDefault("phase", 0) + pi/2 |
          args["sin"] = args["cos"] |
          Sin
        }
        else if ("sin" in args)
          Sin
        else if ("smooth" in args)
          Smooth
        else if ("speed" in args)
          if (adaptive) SpeedAdaptive else Speed
        else if ("time" in args)
          if (adaptive) TimeAdaptive else Time
      }] |
    init(args)
  };

  /// Stop adaptive trajectory if error is below this value.
  var delta = 2;

  /// Compute startValue.
  function getStartValue()
  {
    var this.startValue = getter() |
    switch (startValue.type)
    {
      case "Float":
        // Fine.

      case "Group":
        var v = startValue.members.head |
        while (v.type == "List")
          v = v.head |
        this.startValue = v

      default:
        this.startValue = 0|
        "Warning: setting dummy startValue".print
    }
  };

  // Update the variable according to the trajectory.
  // Use the functions getter/setter to read/update the variable.
  // Blocking until the trajectory is over.
  function run()
  {
    var tag = Tag.new|
    tag:
    {
      every(getPeriod)
      {
	if (isOver)
          tag.stop|
	setter(get(getter)) |
      }|
      sleep(inf)
    }|
  };

  var isOver = false;

  // Override system time to take shift induced by freeze into account.
  function time()
  {
    System.time - currentRunner.timeShift
  };

  function timeGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };

};

class TrajectoryGenerator.Accel : TrajectoryGenerator
{
  function init (args)
  {
    var this.accel = args["accel"] |
    var this.duration = sqrt ( 2 * (targetValue - this.startValue) / accel)
  };

  function get(currentVal)
  {
    if (time - startTime > duration)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };
};

class TrajectoryGenerator.Sin : TrajectoryGenerator
{
  function init (args)
  {
    var this.phase = args.getWithDefault("phase", 0) |
    var this.ampli = args.getWithDefault("ampli", 0) |
    var this.period = args["sin"]
  };

  function get (currentVal)
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };
};

class TrajectoryGenerator.Smooth : TrajectoryGenerator
{
  function init (args)
  {
    var this.duration = args["smooth"] |
  };

  function get(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue +
      (targetValue - startValue) * ( sin ( - pi / 2.0 + pi * stat) +1) / 2.0
  };
};

class TrajectoryGenerator.Speed : TrajectoryGenerator
{
  function init (args)
  {
    var this.speed = args["speed"] |
    var this.duration =
    {
      if (speed)
        abs(this.startValue - targetValue)  / speed
      else
        Float.inf
    }|
  };
  var this.get = getSlot("timeGet") |
};

class TrajectoryGenerator.SpeedAdaptive : TrajectoryGenerator
{
  function init (args)
  {
    var this.speed = args["speed"] |
    var this.duration =
    {
      if (speed)
        abs(this.startValue - targetValue)  / speed
      else
        Float.inf
    }|
  };

  function get(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var nextVal = currentVal
      + speed * sgn(targetValue - currentVal) * getPeriod |
    if ((currentVal < targetValue && targetValue < nextVal)
      || (nextVal < targetValue && targetValue < currentVal))
    {
      nextVal = targetValue
    } |
    nextVal
  };
};

class TrajectoryGenerator.Time : TrajectoryGenerator
{
  function init (args)
  {
     var this.duration = args["time"] |
  };

  var get = getSlot("timeGet")
};


class TrajectoryGenerator.TimeAdaptive : TrajectoryGenerator
{
  function init (args)
  {
    var this.duration = args["time"] |
  };

  function get(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var stat = getPeriod / ( startTime + duration - time) |
    if (stat > 1 || stat < 0)
      return targetValue |
    currentVal + stat *  (targetValue - currentVal)
  };
};

