/*----------------------.
| TrajectoryGenerator.  |
`----------------------*/
class Global.TrajectoryGenerator
{
  // Initialization: Instantiate one of the sub classes.
  function init(getter, setter, targetValue, args)
  {
    var this.getter = getter |
    var this.setter = setter |
    var this.targetValue = targetValue|
    var this.startTime = time|
    // Sin does not need it, but it is simpler to call it anyway as it
    // allows to depend on startValue below.  And besides, it allows
    // to enforce a proper initial value for Sin too.
    getStartValue()|
    var adaptive = args.getWithDefault("adaptive", false) |
    protos =
      [{
        if ("accel" in args)
          Accel
        else if ("cos" in args)
        {
          // Bounce to a sine.
          args["phase"] = args.getWithDefault("phase", 0) + pi/2 |
          args["sin"] = args["cos"] |
          Sin
        }
        else if ("sin" in args)
          Sin
        else if ("smooth" in args)
          Smooth
        else if ("speed" in args)
          if (adaptive)
            SpeedAdaptive
          else
            {
              // Speed is just Time, but with initial conditions
              // expressed in speed instead of duration.
              args["time"] = duration(args["speed"])|
              Time
            }
        else if ("time" in args)
          if (adaptive) TimeAdaptive else Time
      }] |
    init(args)
  };

  // Going from startValue to targetValue with given speed.
  function duration(speed)
  {
    if (speed)
      abs(startValue - targetValue)  / speed
    else
      Float.inf
  }|

  /// Compute startValue.
  function getStartValue()
  {
    var this.startValue = getter() |
    switch (startValue.type)
    {
      case "Float":
        // Fine.

      case "Group":
        var v = startValue.members.head |
        while (v.type == "List")
          v = v.head |
        this.startValue = v

      default:
        this.startValue = 0|
        "Warning: setting dummy startValue".print
    }
  };

  // Override system time to take shift induced by freeze into account.
  function time()
  {
    System.time - currentRunner.timeShift
  };


  var isOver = false;

  // Update the variable according to the trajectory.
  // Use the functions getter/setter to read/update the variable.
  // Blocking until the trajectory is over.
  function run()
  {
    var tag = Tag.new|
    tag:
    {
      every(getPeriod)
      {
	if (isOver)
          tag.stop|
	setter(nextValue) |
      }|
      sleep(inf)
    }|
  };

};



/*-------------------------------.
| TrajectoryGenerator.OpenLoop.  |
`-------------------------------*/

// The generators that derive from this trajectory generator do not
// need the current value to compute the new one.  Separating them
// allows to spare useless calls to the getter in trajectories that do
// not need them, which can be an huge saving in cases where reading
// the current value is expensive.
class TrajectoryGenerator.OpenLoop : TrajectoryGenerator
{
  function nextValue()
  {
    get
  };
};

class TrajectoryGenerator.Accel : TrajectoryGenerator.OpenLoop
{
  function init (args)
  {
    var this.accel = args["accel"] |
    var this.duration = sqrt ( 2 * (targetValue - this.startValue) / accel)
  };

  function get()
  {
    if (duration < time - startTime)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };
};

class TrajectoryGenerator.Sin : TrajectoryGenerator.OpenLoop
{
  function init (args)
  {
    var this.phase = args.getWithDefault("phase", 0) |
    var this.ampli = args.getWithDefault("ampli", 0) |
    var this.period = args["sin"]
  };

  function get()
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };
};

class TrajectoryGenerator.Smooth : TrajectoryGenerator.OpenLoop
{
  function init (args)
  {
    var this.duration = args["smooth"] |
  };

  function get()
  {
    var stat =  (time - startTime) / duration |
    if (1 < stat)
    {
      isOver = true|
      return targetValue
    } |
    startValue +
      (targetValue - startValue) * ( sin ( - pi / 2.0 + pi * stat) +1) / 2.0
  };
};

class TrajectoryGenerator.Time : TrajectoryGenerator.OpenLoop
{
  function init (args)
  {
     var this.duration = args["time"] |
  };

  function get()
  {
    var stat =  (time - startTime) / duration |
    if (1 < stat)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };

};


/*---------------------------------.
| TrajectoryGenerator.ClosedLoop.  |
`---------------------------------*/

// The generators that derive from this trajectory generator need the
// the current value to compute the new one.
class TrajectoryGenerator.ClosedLoop : TrajectoryGenerator
{
  /// Stop adaptive trajectory if error is below this value.
  var delta = 2;

  function nextValue()
  {
    get(getter)
  };

  function done(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
      isOver = true |
    return isOver
  };
};

class TrajectoryGenerator.SpeedAdaptive : TrajectoryGenerator.ClosedLoop
{
  function init (args)
  {
    var this.speed = args["speed"] |
    var this.duration = duration(speed)
  };

  function get(currentVal)
  {
    if (done(currentVal))
      return targetValue |
    var res = currentVal
      + speed * sgn(targetValue - currentVal) * getPeriod |
    if ((currentVal < targetValue && targetValue < res)
      || (res < targetValue && targetValue < currentVal))
    {
      res = targetValue
    } |
    res
  };
};

class TrajectoryGenerator.TimeAdaptive : TrajectoryGenerator.ClosedLoop
{
  function init (args)
  {
    var this.duration = args["time"] |
  };

  function get(currentVal)
  {
    if (done(currentVal))
      return targetValue |
    var stat = getPeriod / ( startTime + duration - time) |
    if (stat < 0 || 1 < stat)
      return targetValue |
    currentVal + stat *  (targetValue - currentVal)
  };
};
