/*----------------------.
| TrajectoryGenerator.  |
`----------------------*/
class Global.TrajectoryGenerator
{
  /// Stop adaptive trajectory if error is below this value.
  var delta = 2;
  function getStartValue()
  {
    var this.startValue = getter() |
    if (startValue.type == "Float")
      this.startValue = startValue
    else if (startValue.type == "Group")
    {
      var v = startValue.members.head |
      while (v.type == "List")
	v = v.head |
      this.startValue = v
    }
    else
    {
      this.startValue = 0|
      "Warning: setting dummy startValue".print
    }
  };

  // Initialization: Instantiate one of the sub classes.
  function init(getter, setter, targetValue, args)
  {
    var this.getter = getter |
    var this.setter = setter |
    this.targetValue = targetValue|
    this.startTime = time|
    protos =
      [{
        if ("accel" in args)
          Accel
        else if ("cos" in args)
          Sin
        else if ("sin" in args)
          Sin
        else if ("smooth" in args)
          Smooth
        else if ("speed" in args)
          Speed
        else if ("time" in args)
          Time
      }] |
    init(args)
  };

  // Update the variable according to the trajectory.
  // Use the functions getter/setter to read/update the variable.
  // Blocking until the trajectory is over.
  function run()
  {
    var tag = Tag.new|
    tag:
    {
      every(getPeriod)
      {
	if (isOver)
          tag.stop|
	setter(get(getter)) |
      }|
      sleep(inf)
    }|
  };

  var startValue = 0;
  var startTime;
  var targetValue;
  var isOver = false;

  // Override system time to take shift induced by freeze into account.
  function time()
  {
    System.time - currentRunner.timeShift
  };

  function timeGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };

};

class TrajectoryGenerator.Accel : TrajectoryGenerator
{
  function init (args)
  {
    getStartValue()|
    var this.accel = args["accel"] |
    var this.duration = sqrt ( 2 * (targetValue - this.startValue) / accel)
  };

  function get(currentVal)
  {
    if (time - startTime > duration)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };
};

class TrajectoryGenerator.Sin : TrajectoryGenerator
{
  function init (args)
  {
    var this.phase = (args.getWithDefault("phase", 0)
                      + { if ("cos" in args) pi/2 else 0 }) |
    var this.ampli = args.getWithDefault("ampli", 0) |
    var this.period = args[{if ("cos" in args) "cos" else "sin"}]
  };

  function get (currentVal)
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };
};

class TrajectoryGenerator.Smooth : TrajectoryGenerator
{
  function init (args)
  {
    getStartValue()|
    var this.duration = args["smooth"] |
  };

  function get(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue +
      (targetValue - startValue) * ( sin ( - pi / 2.0 + pi * stat) +1) / 2.0
  };
};

class TrajectoryGenerator.Speed : TrajectoryGenerator
{
  function init (args)
  {
    getStartValue()|
    var this.speed = args["speed"] |
    var this.duration =
    {
      if (speed)
        abs(this.startValue - targetValue)  / speed
      else
        Float.inf
    }|
    var this.get =
      getSlot({ if (args.getWithDefault("adaptive", 0))
                  "adaptiveSpeedGet"
                else
                  "timeGet"}) |
  };

  function adaptiveSpeedGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var nextVal = currentVal
      + speed * sgn(targetValue - currentVal) * getPeriod |
    if ((currentVal < targetValue && targetValue < nextVal)
      || (nextVal < targetValue && targetValue < currentVal))
    {
      nextVal = targetValue
    } |
    nextVal
  };
};

class TrajectoryGenerator.Time : TrajectoryGenerator
{
  function init (args)
  {
    getStartValue()|
    var this.get =
      getSlot({if (args.getWithDefault("adaptive", 0)) "timeAdaptiveGet"
               else "timeGet"}) |
    var this.duration = args["time"] |
  };

  function timeAdaptiveGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var stat = getPeriod / ( startTime + duration - time) |
    if (stat > 1 || stat < 0)
      return targetValue |
    currentVal + stat *  (targetValue - currentVal)
  };
};

