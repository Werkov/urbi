class Global.TrajectoryGenerator
{
  /// Stop adaptive trajectory if error is below this value.
  var delta = 2;
  function init(startValue, targetValue, args)
  {
    if (startValue.type == "Float")
      self.startValue = startValue
    else if (startValue.type == "Group")
    {
      var v = startValue.members.head |
      while (v.type == "List")
	v = v.head |
      self.startValue = v
    }
    else
    {
      self.startValue = 0|
      "Warning: setting dummy startValue".print
    }|
    self.targetValue = targetValue|
    self.startTime = time|
    var content = Global._slotNames(args)|
    if (content.has("time"))
    {
      var self.adaptive = _getLazyLocalSlot(args, "adaptive", 0, false) |
      if (self.adaptive)
	var self.get = getSlot("timeAdaptiveGet")
      else
	var self.get = getSlot("timeGet") |
      var self.duration = _getSlot(args, "time") |
    }
    else if (content.has("smooth"))
    {
      var self.adaptive = _getLazyLocalSlot(args, "adaptive", 0, false) |
      var self.get = getSlot("smoothGet") |
      var self.duration = _getSlot(args, "smooth") |
    }
    else if (content.has("accel"))
    {
      var self.get = getSlot("accelGet") |
      var self.accel = _getSlot(args, "accel") / 1000000 |
      var self.duration = sqrt ( 2 * (targetValue - self.startValue) / accel)
    }
    else if (content.has("speed"))
    {
      var self.adaptive = _getLazyLocalSlot(args, "adaptive", 0, false) |
      var self.speed = args.speed / 1000|
      var self.duration = abs(self.startValue - targetValue)  / speed |
      if (!adaptive)
      {
      var self.get = getSlot("timeGet")
      }
      else
      {
	var self.get = getSlot("adaptiveSpeedGet")
      }
    }
    else if (content.has("sin") || content.has("cos"))
    {
      var self.get = getSlot("sinGet");
      var self.phase = _getLazyLocalSlot(args, "phase", 0, false) |
      var self.ampli = _getLazyLocalSlot(args, "ampli", 0, false) |
      if (content.has("cos"))
      {
	var self.period =  args.cos |
	self.phase += pi/2
      }
      else
	var self.period = args.sin
    }
  };

  # Update slot \a name in \a owner accordingly to the trajectory.
  # Blocking until the trajectory is over.
  function run(owner, name)
  {
    var tag = Tag.new|
    tag:
    {
      every(getPeriod)
      {
	if (isOver)
          tag.stop|
	var newval = get(owner.getSlot(name)) |
	owner.updateSlot(name, newval) |
      }|
      sleep(inf)
    }|
  };

  var startValue = 0;
  var startTime;
  var targetValue;
  var isOver = false;

  function timeGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };
  function smoothGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue +
      (targetValue - startValue) * ( sin ( - pi / 2.0 + pi * stat) +1) / 2.0
  };
  function timeAdaptiveGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var stat = getPeriod / ( startTime + duration - time) |
    if (stat > 1 || stat < 0)
      return targetValue |
    currentVal + stat *  (targetValue - currentVal)
  };
  function sinGet(currentVal)
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };
  function accelGet(currentVal)
  {
    if (time - startTime > duration)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };
  function adaptiveSpeedGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var nextVal = currentVal
      + speed * sgn(targetValue - currentVal) * getPeriod |
    if ((currentVal < targetValue && targetValue < nextVal)
      || (nextVal < targetValue && targetValue < currentVal))
    {
      nextVal = targetValue
    } |
    nextVal
  };
};
