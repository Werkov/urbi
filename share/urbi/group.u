class Global.Group
{
  function init ()
  {
    var self.members = [];
  };

  function add(g)
  {
    members.push_back(g);
    self
  };

  copySlot("add", "<<");

  // Implements addgroup.  Cannot use "group" as an identifier,
  // reserved by k1.
  function addGroups(g)
  {
    members += g;
  };

  function remove(g)
  {
    members = members.remove(g);
  };

  // Implements delgroup.  Cannot use "group" as an identifier,
  // reserved by k1.
  function removeGroups(g)
  {
    members = self.members - g;
  };

  var protoName = "Group";
  function asString ()
  {
    if (self === Group)
      "<Group>"
    else
      "Group " + members.asString
  };

  // FIXME: This implementation always evaluates the
  // arguments. There's no other way to do it for now.
  function fallback
  {
    var res = Group.new|
    function action (m)
    {
      res << m.callMessage(call)
    }|
    getSlot("action").makeClosure|
    members.each(getSlot("action"))|
    res
  };

  copySlot("fallback", "updateSlot");
};
