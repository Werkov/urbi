class Global.Group
{
  function init
  {
    var self.members = call.evalArgs |
    self
  };

  # n-ary strict: add the arguments as group members.
  function add
  {
    # Fetch Object's updateSlot or we will trigger the fallback
    Object.getSlot("updateSlot").apply([self, "members", members + call.evalArgs])|
    self
  };

  copySlot("add", "<<");

  # n-ary strict: remove the arguments as group members.
  # Removing a non-member is ok.
  function remove
  {
    # Fetch Object's updateSlot or we will trigger the fallback
    Object.getSlot("updateSlot").apply([self, "members", members - call.evalArgs])|
    self
  };

  function asString ()
  {
    if (self === Group)
      "<" + protoName + ">"
    else
      protoName + " " + members.asString
  };

  // FIXME: This implementation always evaluates the
  // arguments. There's no other way to do it for now.
  function fallback
  {
    var results = [] |
    var outer_call = call |
    function action (m)
    {
      results.push_back(m.callMessage(outer_call).acceptVoid)
    } |
    members.each(action) |
    # If the resulting group contains only void, return void.
    if (results.all(methodToFunction("isVoid")))
      void
    else
      Group.getSlot("new").apply([Group] + results)
  };

  for (var s : ["getProperty", "hasProperty", "setProperty", "updateSlot"])
    copySlot("fallback", s);
};
