class Global.Group
{
  function init
  {
    var self.members = call.evalArgs |
    self
  };

  # n-ary strict: add the arguments as group members.
  function add
  {
    # Fetch Object's updateSlot or we will trigger the fallback
    Object.getSlot("updateSlot").apply([self, "members", members + call.evalArgs])|
    self
  };

  copySlot("add", "<<");

  # n-ary strict: remove the arguments as group members.
  # Removing a non-member is ok.
  function remove
  {
    # Fetch Object's updateSlot or we will trigger the fallback
    Object.getSlot("updateSlot").apply([self, "members", members - call.evalArgs])|
    self
  };

  function asString ()
  {
    if (self === Group)
      "<" + protoName + ">"
    else
      protoName + " " + members.asString
  };

  // FIXME: This implementation always evaluates the
  // arguments. There's no other way to do it for now.
  function fallback
  {
    var res = Group.new |
    function action (m)
    {
      res << m.callMessage(call)
    }|
    getSlot("action").makeClosure|
    members.each(getSlot("action"))|
    res
  };

  [
    "getProperty",
    "hasProperty",
    "setProperty",
    "updateSlot"
  ].each(function (name) {
    Group.copySlot("fallback", name);
  });
};
