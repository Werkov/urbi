class Global.Group
{
  function init
  {
    var self.members = call.evalArgs;
  };

  function add(g)
  {
    members.push_back(g);
    self
  };

  copySlot("add", "<<");

  // Implements addgroup.  Cannot use "group" as an identifier,
  // reserved by k1.
  function addMembers(g)
  {
    members += g;
  };

  function remove(g)
  {
    members = members.remove(g);
  };

  // Implements delgroup.  Cannot use "group" as an identifier,
  // reserved by k1.
  function removeMembers(g)
  {
    members = self.members - g;
  };

  var protoName = "Group";
  function asString ()
  {
    if (self === Group)
      "<" + protoName + ">"
    else
      protoName + " " + members.asString
  };

  // FIXME: This implementation always evaluates the
  // arguments. There's no other way to do it for now.
  function fallback
  {
    var res = Group.new|
    function action (m)
    {
      res << m.callMessage(call)
    }|
    getSlot("action").makeClosure|
    members.each(getSlot("action"))|
    res
  };

  [
    "getProperty",
    "hasProperty",
    "setProperty",
    "updateSlot"
  ].each(function (name) {
    Group.copySlot("fallback", name);
  });
};
