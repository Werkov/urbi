# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;
var Code.acceptVoid = 0;
var Primitive.acceptVoid = 0;


## --------- ##
## Constants ##
## --------- ##

class Global.Constants
{
  var pi     = 3.14159265358979323846264338327950288;
  var inf    = Float.inf;
  var nan    = Float.nan;
};


Global.addProto (Global.Constants);

## -------- ##
## Object.  ##
## -------- ##

do Object
{
  # Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    self.setSlot(to, self.getSlot(frm))
  };

  function cloneSlot (frm, to)
  {
    self.setSlot(to, self.getSlot(frm).clone)
  };

  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  function '==' (other)
  {
    sameAs(other)
  };

  function '===' (other)
  {
    memSameAs(other)
  };

  cloneSlot("setSlot", "setVoidSlot").acceptVoid = true;
  cloneSlot("updateSlot", "updateVoidSlot").acceptVoid = true;

  function hasSlot(name)
  {
    !locateSlot(name).isNil
  };

  function '!==' (rhs)
  {
    !(self === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    # The fresh child.
    var res = call.getSlot("target").clone |
    # Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };
};

## -------- ##
## Global.  ##
## -------- ##

do Global
{
  // Import the primitives.
  self.addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  // Assertion control
  var System.ndebug = 0;
  function System.assert {
    if (!System.ndebug)
      System.assert_ (call.evalArgAt (1), call.argString (1));
  };

  function noop () {};
};

## -------------- ##
## Call message.  ##
## -------------- ##

class Global.CallMessage
{
  function argString(i)
  {
    args.nth(i).string
  };

  function evalArgAt(i)
  {
    args.nth(i).eval
  };

  function argAt(i)
  {
    args.nth(i).value
  };

  function evalArgs()
  {
    args.tail.map(function (arg) { arg.eval })
  };

  function argsCount
  {
    args.size
  };
};

## ----- ##
## Lazy. ##
## ----- ##

load("urbi/lazy.u");

## ------ ##
## List.  ##
## ------ ##

load("urbi/list.u");

## ----------- ##
## Singleton.  ##
## ----------- ##

load("urbi/singleton.u");

## --------- ##
## Booleans. ##
## --------- ##

true.addProto(Singleton);
false.addProto(Singleton);
true.asString = "true";
false.asString = "false";

## ---- ##
## nil. ##
## ---- ##

do nil
{
  self.addProto(Singleton);
  function '==' (x) { x.isNil };
  var asString = "nil";
  // nil prints nothing in the toplevel
  var asToplevelPrintable = "";
};

do Object
{
  function Object.isNil ()
  {
    nil === self
  }
};

## ------------------------ ##
## Method function wrappers ##
## ------------------------ ##

do Global
{
  # Make a function f from a method m, so as f(a, b, c) is equivalent
  # to a.m(b, c)
  # FIXME: I'm not satisfied with the name, but can't find anything
  # better
  function methodToFunction(name)
  {
    function
    {
      var args = call.evalArgs|
      args.head.getSlot(name).apply(args)
    }
  };
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context.
do Object
{
  function detach
  {
    var outer_call = call |
    spawn (function () { outer_call.evalArgAt (1) })
  };

  function detach_linked
  {
    var outer_call = call |
    spawn (function () { outer_call.evalArgAt (1) }, true)
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1) |
      var deadline = shiftedTime |
      loop {
        detach (call.evalArgAt (2)) |
	deadline += delay |
        sleep (deadline - shiftedTime)
      }
    })
  };

  # at_ takes three expressions, a test and a code to execute each time the test
  # becomes true and a code to execute each time the test becomes false.
  function at_
  {
    registerAtJob(call.args.nth(1), call.args.nth(2), call.args.nth(3))
  };

  # whenever_ takes three expressions, a test and a code to execute each time the
  # test is true and a code to execute each time the test then becomes false.
  function whenever_
  {
    detach ({
      loop {
        waituntil (call.evalArgAt (1)) |
        loop {
          call.evalArgAt (2) |
          if (!call.evalArgAt (1))
            break
        };
        call.evalArgAt (3)
      }
    })
  };

  # waituntil takes an expression and waits until it becomes true.
  function waituntil {
    var t = currentRunner |
    t.setSideEffectFree (true) |
    while (!call.evalArgAt (1)) {
      t.waitForChanges
    } |
    t.setSideEffectFree (false)
  };

  # persist takes an expression and a delay, and returns an object
  # whose val slot evaluates to true if the expression has been
  # continously true for this delay and false otherwise.
  #
  # This function is used to implement
  #   at (condition ~ delay) action [onleave leaveaction]
  # as
  #   var u = persist (condition, delay);
  #   at (u.val) action [onleave leaveaction]
  #
  # The "persist" action will be controlled by the same tags as
  # the initial "at" block.
  function persist
  {
    var res = false |
    var tag = Tag.new("persist".fresh) |
    var delay = call.evalArgAt (2) |
    at_ (call.evalArgAt (1), detach({tag: { sleep (delay) | res = true }}),
         detach({ res = false | tag.stop })) |
    return function () { res }
  };
};

load("urbi/event.u");
load("urbi/channel.u");


## ------ ##
## void.  ##
## ------ ##

void.addProto(Singleton);
var void.asString = "void";
// void prints nothing in the toplevel
var void.asToplevelPrintable = "";
var void.isProto = 1;
var Object.isVoid = false;
var void.isVoid = true;

## ------------ ##
## Comparable.  ##
## ------------ ##

class Global.Comparable
{
  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
};
# Provide !=.
Object.addProto(Comparable);

## ----------- ##
## Orderable.  ##
## ----------- ##

class Global.Orderable
{
  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
};


## ------- ##
## Float.  ##
## ------- ##

load("urbi/float.u");

load("urbi/trajectory-generator.u");

## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## --------- ##
## Printing. ##
## --------- ##

do Object
{
  function isProto ()
  {
    locateSlot("protoName") === self
  };

  function type ()
  {
    if (isProto)
      "<" + protoName + ">"
    else
      protoName
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };

  function asPrintable ()
  {
    asString
  };

  function asToplevelPrintable ()
  {
    asPrintable
  };
};

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };
};

load("urbi/k1.u");

## ------------ ##
## Conversions. ##
## ------------ ##

do Object
{
  function as(type)
  {
    getSlot("as" + type.protoName).apply([self])
  }
};

## ----- ##
## Math. ##
## ----- ##

class Global.Math
{
  for fn in ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
             "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"]
  {
    Global.Math.setSlot (fn, bounce_named (fn))
  };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;
};
Global.addProto (Global.Math);


## -------- ##
## Groups.  ##
## -------- ##
load("urbi/group.u");

## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object
{
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  };
};

load("urbi/binary.u");

## ---------------------- ##
## Profiling operations.  ##
## ---------------------- ##

class Global.Profiling
{
  function timen {
    var niters = call.evalArgAt (2);
    var start_time = time;
    var start_cycle = cycle |
    { for (var i = 0; i < niters; i++)
        call.evalArgAt (1)
    } |
    var ncycles = cycle - start_cycle - 1;
    var expired = time - start_time;
    echo ("Profiling information");
    echo ("  Expression:       " + call.argString (1));
    echo ("  Iterations:       " + niters);
    echo ("  Cycles:           " + ncycles);
    echo ("  Total time:       " + expired + " ms");
    echo ("  Single iteration: " + expired / niters + " ms");
    echo ("                    " + ncycles / niters + " cycles");
  };
};
Global.addProto (Global.Profiling);

## ----------- ##
## Executable. ##
## ----------- ##

# This class is used as a flag to recognize all kind of executable code
class Global.Executable
{
  function voidVersion ()
  {
    var res = clone |
    res.acceptVoid = true |
    return res
  }
};

[Code, Primitive, Delegate].each(function (c) { c.addProto(Executable) });

## ------ ##
## Tuple. ##
## ------ ##

load("urbi/tuple.u");

## ----------- ##
## Dictionary. ##
## ----------- ##

load("urbi/dictionary.u");

## ----------- ##
## Properties. ##
## ----------- ##

do Object
{
  var properties = Dictionary.new;

  # Set the \a name property on slot \a slot to \a value
  function setProperty(slot, name, value)
  {
    if (locateSlot("properties") !== self)
      var self.properties = Dictionary.new|
    var slotProps|
    if (!properties.has(slot))
    {
      slotProps = Dictionary.new|
      properties.set(slot, slotProps)|
    }
    else
      slotProps = properties.get(slot)|
    slotProps.set(name, value)|
    if (!self.getSlot(slot).locateSlot("propertyHook").isNil)
      self.getSlot(slot).propertyHook(self, slot, name, value)|
    value
  };

  function getProperty(slot, name)
  {
    if (!hasProperty(slot, name))
      return void|
    properties.get(slot).get(name)
  };

  function hasProperty(slot, name)
  {
    # No '&&' yet.
    if (properties.has(slot))
      properties.get(slot).has(name)
    else
      return false
  };
};

## ------------------ ##
## Debugging helpers. ##
## ------------------ ##

load("urbi/debug.u");

## -------- ##
## UObject. ##
## -------- ##

"Initializing uobjects NOW";
load("urbi/uobject.u");

// This variable is used by initialization code to detect the end of urbi.u.
var Object.loaded = 1;

// Force a yield
sleep(10);

// Make the tutorial available.
load("urbi/help.u");
// Load URBI.INI outside initialization phase.
"Loading URBI.INI";
load("URBI.INI");

## ------------- ##
## Ready to go.  ##
## ------------- ##
# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
