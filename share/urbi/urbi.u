# FIXME: this code should be split in several files, once we have
# a "load" that works.

## -------- ##
## Object.  ##
## -------- ##

# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

{
  # Cannot use "copy", nor "from" which are k1 reserved words :) :) :)
  var Object.slotCopy = function (frm, to) {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self . setSlot(to, getSlot(frm))
  };
  Object.slotCopy ("addProto", "inherit");
  Object.slotCopy ("removeProto", "disinherit");
  
  Object.slotCopy ("sameAs", "==");
  void
};

## --------- ##
## Closure.  ##
## --------- ##

var Object.makeExplicitClosure = function (f, context)
{
  var nf = getSlot ("f").clone;
  getSlot ("nf").context = context;
  getSlot ("nf");
};

var Object.makeClosure = function
{
  makeExplicitClosure (call.evalArgAt (1), call.context);
};

var Object.makeClosedCode = function
{
  var f = function () { call.evalArgAt (1) };
  makeClosure (getSlot ("f"))
};

var Code.capture = function (varname, value)
{
  if (getSlot ("self").context.isNil)
    getSlot ("self").context = new Object;
  getSlot ("self").context.setSlot (varname, value);
  getSlot ("self")
};

var Code.captureVars = function
{
  var i = 1;
  for (; i < call.argsCount; i++)
  {
    getSlot("self").capture (call.argString (i), call.evalArgAt (i))
  };
  getSlot ("self")
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context. The task will be stopped when there is no
# more references onto the returned object.
var Object.detach = function
{
  var f = makeClosedCode (call.evalArgAt (1));
  new Task (getSlot ("f"))
};

# every_ takes two arguments, a delay and an expression.
var Object.every_ = function
{
  detach ({
    var delay = call.evalArgAt (1);
    var runners = [];
    loop {
      runners += [detach (call.evalArgAt (2))];
      sleep (delay);
    }
  })
};

# at_ takes two expressions, a test and a code to execute when the test
# becomes true
var Object.at_ = function
{
  var t = detach ({
    loop {
      if (call.evalArgAt (1)) {
        call.evalArgAt (2);
        break
      };
      t.waitForChanges
    }
  });
  t
};

## ----------------- ##
## VisibilityScope.  ##
## ----------------- ##

# Must be before the first 'do' or 'class'
# Do and class blocks are inheriting from VisibilityScope.
# VisibilityScope has special setSlot and updateSlot preventing to write to
# the locals. Only the target can be modified implicitly
# The slot __target is expected to be set to the target of the block.
{
  var Object.VisibilityScope = Object.clone;

  var VisibilityScope.updateSlot = function(x, y)
  {
    __target.updateSlot(x, getSlot("y"));
  };
  
  var VisibilityScope.setSlot = function(x, y)
  {
    __target.setSlot(x, getSlot("y"));
  };

  void
};

## ------- ##
## Scope.  ##
## ------- ##

class Object.Scope {
  var init = function () { self.makeScope (true) }
};

## --------- ##
## Constants ##
## --------- ##

class Object.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
  void;
};
Object.addProto (Constants);


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
class Object.Channel
{
  var init = function (x) { var self.name = x };
  var '<<' = function (x) { x.print (name); {} };
  void;
};

// Default channels.
do Object
{
  // Long names are k1 compatible.
  var output  = new Channel("output");
  var error   = new Channel("error");
  var warning = new Channel("warning");
  // Short names are user compatible.
  var cout  = output;
  var cerr  = error;

  var warn = function (msg) { echo (msg, "warning") };
  void;
};


## ------ ##
## void.  ##
## ------ ##
do void
{
  // void prints nothing.
  var print = function() {};
  // void is a singleton.
  var clone = function() { self; };
  void;
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  // nil is a singleton.
  var clone = function () { self };
  var isNil = true;
  var '=='  = function (x) { x.isNil };

  var Object.isNil = false;
  void;
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Object.Comparable
{
  var '!=' = function (rhs) { ! (self == rhs) };
  var '==' = function (rhs) { ! (self != rhs) };
  void;
};


## ----------- ##
## Orderable.  ##
## ----------- ##

class Object.Orderable
{
  var '<'  = function (rhs) { rhs > self };
  var '<=' = function (rhs) { self < rhs || self == rhs };
  var '>'  = function (rhs) { rhs < self };
  var '>=' = function (rhs) { self > rhs || self == rhs };
  void;
};


## ------- ##
## Float.  ##
## ------- ##

do Float
{
  self.addProto(Comparable);
  self.addProto(Orderable);

  var init = function (x) { self.set(x) };

  var sqr = function () { self * self };

  var '+=' = function (x) { self.set (self + x) };
  var '-=' = function (x) { self.set (self - x) };
  var '*=' = function (x) { self.set (self * x) };
  var '/=' = function (x) { self.set (self / x) };

  // One would like to write
  //
  // '++' = function () { var res = self.clone; self += 1; res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-proto.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  var '++' = function () { var res = 0; res.set(self); self += 1; res };
  var '--' = function () { var res = 0; res.set(self); self -= 1; res };
  var '~=' = function (x) { (self - x).abs <= epsilontilde };
  var '%=' = function (x) { (1.0 - self / x).abs <= epsilonpercent };
  # FIXME: =~= cannot be correctly implemented without properties.
  var '=~=' = function (x) { (self - x) <= self.delta + x.delta };
  var sgn = function () { if (self < 0) -1 else if (self > 0) 1 else 0 };

  var '!' = function () { self == 0; };

  var seq = function()
  {
    var result = [];
    for (var i = 1; i <= self; i++)
      result.insert(i.clone);
    result
  };

  void;
};



## ----- ##
## List. ##
## ----- ##

do List
{
  var has = function (e)
  {
    for i in self
    {
      if (i == e)
	return true;
    };
    return false;
  };

  # The Lisp-like name.
  slotCopy ("front", "head");

  void;
};

# k1 compatibility.
do Object
{
  var size = function(l)
  { 
    warn("`size(list)' is deprecated, use `list.size'");
    l.size
  };

  var seq = function(n)
  {
    warn("`seq(number)' is deprecated, use `number.seq'");
    n.seq()
  };

  void;
};


## ----- ##
## Math. ##
## ----- ##

class Object.Math
{
  # Standard functions.
  var abs    = function (x) { x.abs };
  var acos   = function (x) { x.acos };
  var asin   = function (x) { x.asin };
  var atan   = function (x) { x.atan };
  var cos    = function (x) { x.cos };
  var exp    = function (x) { x.exp };
  var log    = function (x) { x.log };
  var random = function (x) { x.random };
  var round  = function (x) { x.round };
  var sgn    = function (x) { x.sgn };
  var sin    = function (x) { x.sin };
  var sqr    = function (x) { x.sqr };
  var sqrt   = function (x) { x.sqrt };
  var tan    = function (x) { x.tan };
  var trunc  = function (x) { x.trunc };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;

  void;
};
Object.addProto (Math);



## -------- ##
## String.  ##
## -------- ##

# The connectives == and < are builtins.
# FIXME: I'd like to put the addProto in a do, but then it goes
# to the locals :(
String.addProto(Comparable);
String.addProto(Orderable);


## ------------------------ ##
## Functional programming.  ##
## ------------------------ ##

var Object.map = function (f, list)
{
  if (!list.size)
    []
  else
    [f (list.head)] + map (getSlot ("f"), list.tail)
};

var Object.any = function (f, list)
{
  if (!list.size)
    false
  else if (f (list.head))
    true
  else
    any (getSlot ("f"), list.tail)
};

var Object.all = function (f, list)
{
  if (!list.size)
    true
  else if (!f (list.head))
    false
  else
    all (getSlot ("f"), list.tail)
};

var Object.tasks = [];

var Object.eachBg = function (f, list)
{
  if (list.size)
  {
    Object.tasks += [detach (f (list.head))];
    eachBg (getSlot ("f"), list.tail)
  }
};

## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
