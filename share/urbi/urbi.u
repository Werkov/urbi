## -------- ##
## Object.  ##
## -------- ##

# Cannot use "copy", nor "from" which are k1 reserved words :) :) :)
Object.slotCopy = function (frm, to) {
  # This is annoying: one has to specify "self" here, otherwise the
  # setSlot goes to the locals_ :(
  self . setSlot(to, getSlot(frm))
};
Object.slotCopy ("addParent", "inherit");
Object.slotCopy ("removeParent", "disinherit");


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
class Lobby.Channel
{
  init = function (x) { self.name = x };
  <<   = function (x) { x.print (name); {} };
};


## ------- ##
## Float.  ##
## ------- ##

do Float
{
  init = function (x) { self.set(x) };

  sqr = function () { self * self };

  += = function (x) { self.set (self + x) };
  -= = function (x) { self.set (self - x) };
  *= = function (x) { self.set (self * x) };
  /= = function (x) { self.set (self / x) };

  // One would like to write
  //
  // ++ = function () { var res = self.clone; self += 1; res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-parent.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  ++ = function () { var res = 0; res.set(self); self += 1; res };
  -- = function () { var res = 0; res.set(self); self -= 1; res };
};

## ----- ##
## Math. ##
## ----- ##

class Lobby.Math
{
  abs    = function (x) { x.abs };
  acos   = function (x) { x.acos };
  asin   = function (x) { x.asin };
  atan   = function (x) { x.atan };
  cos    = function (x) { x.cos };
  exp    = function (x) { x.exp };
  log    = function (x) { x.log };
  random = function (x) { x.random };
  round  = function (x) { x.round };
  sgn    = function (x) { x.sgn };
  sin    = function (x) { x.sin };
  sqr    = function (x) { x.sqr };
  sqrt   = function (x) { x.sqrt };
  tan    = function (x) { x.tan };
  trunc  = function (x) { x.trunc };
};
Object inherits Math;

## -------- ##
## String.  ##
## -------- ##

# We do have ==, <, and != as builtins.
# FIXME: Introduce "Sortable", or whatever, which defines these
# operators, and derive from it.
do String
{
  <= = function (rhs) { self < rhs || self == rhs };
  >  = function (rhs) { rhs < self };
  >= = function (rhs) { rhs < self || self == rhs };
};

## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
