# FIXME: this code should be split in several files, once we have
# a "load" that works.

## -------- ##
## Object.  ##
## -------- ##

# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

{
  # Cannot use "copy", nor "from" which are k1 reserved words :) :) :)
  var Object.slotCopy = function (frm, to) {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self . setSlot(to, getSlot(frm))
  };
  Object.slotCopy ("addProto", "inherit");
  Object.slotCopy ("removeProto", "disinherit");
  
  Object.slotCopy ("sameAs", "==");
  void
};

## --------- ##
## Closure.  ##
## --------- ##

var Object.makeExplicitClosure = function (f, context)
{
  var nf = getSlot ("f").clone;
  getSlot ("nf").context = context;
  getSlot ("nf");
};

var Object.makeClosure = function
{
  makeExplicitClosure (call.evalArgAt (1), call.context);
};

var Object.makeClosedCode = function
{
  var f = function () { call.evalArgAt (1) };
  makeClosure (getSlot ("f"))
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context. The task will be stopped when there is no
# more references onto the returned object.
var Object.detach = function
{
  var f = makeClosedCode (call.evalArgAt (1));
  new Task (getSlot ("f"))
};

# every_ takes two arguments, a delay and an expression.
var Object.every_ = function
{
  detach ({
    var delay = call.evalArgAt (1);
    var runners = [];
    loop {
      runners += [detach (call.evalArgAt (2))];
      sleep (delay);
    }
  })
};

# at_ takes two expressions, a test and a code to execute when the test
# becomes true
var Object.at_ = function
{
  var t = detach ({
    loop {
      if (call.evalArgAt (1)) {
        call.evalArgAt (2);
        break
      };
      t.waitForChanges
    }
  });
  t
};

## ----------------- ##
## VisibilityScope.  ##
## ----------------- ##

# Must be before the first 'do' or 'class'
# Do and class blocks are inheriting from VisibilityScope.
# VisibilityScope has special setSlot and updateSlot preventing to write to
# the locals. Only the target can be modified implicitly
# The slot __target is expected to be set to the target of the block.
{
  var Object.VisibilityScope = Object.clone;

  var VisibilityScope.updateSlot = function(x, y)
  {
    __target.updateSlot(x, getSlot("y"));
  };
  
  var VisibilityScope.setSlot = function(x, y)
  {
    __target.setSlot(x, getSlot("y"));
  };

  void
};

## ------- ##
## Scope.  ##
## ------- ##

class Object.Scope {
  var init = function () { self.makeScope (true) }
};

## --------- ##
## Constants ##
## --------- ##

class Object.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
  void;
};
Object.addProto (Constants);


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
class Object.Channel
{
  var init = function (x) { var self.name = x };
  var '<<' = function (x) { x.print (name); {} };
  void;
};

// Default channels.
do Object
{
  // Long names are k1 compatible.
  var output  = new Channel("output");
  var error   = new Channel("error");
  var warning = new Channel("warning");
  // Short names are user compatible.
  var cout  = output;
  var cerr  = error;

  var warn = function (msg) { echo (msg, "warning") };
  void;
};


## ------ ##
## void.  ##
## ------ ##
do void
{
  // void prints nothing.
  var print = function() {};
  // void is a singleton.
  var clone = function() { self; };
  void;
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  // nil is a singleton.
  var clone = function () { self };
  var isNil = true;
  var '=='  = function (x) { x.isNil };

  var Object.isNil = false;
  void;
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Object.Comparable
{
  var '!=' = function (rhs) { ! (self == rhs) };
  var '==' = function (rhs) { ! (self != rhs) };
  void;
};


## ----------- ##
## Orderable.  ##
## ----------- ##

class Object.Orderable
{
  var '<'  = function (rhs) { rhs > self };
  var '<=' = function (rhs) { self < rhs || self == rhs };
  var '>'  = function (rhs) { rhs < self };
  var '>=' = function (rhs) { self > rhs || self == rhs };
  void;
};


## ------- ##
## Float.  ##
## ------- ##

do Float
{
  self.addProto(Comparable);
  self.addProto(Orderable);

  var init = function (x) { self.set(x) };

  var sqr = function () { self * self };

  var '+=' = function (x) { self.set (self + x) };
  var '-=' = function (x) { self.set (self - x) };
  var '*=' = function (x) { self.set (self * x) };
  var '/=' = function (x) { self.set (self / x) };

  // One would like to write
  //
  // '++' = function () { var res = self.clone; self += 1; res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-proto.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  var '++' = function () { var res = 0; res.set(self); self += 1; res };
  var '--' = function () { var res = 0; res.set(self); self -= 1; res };

  var '!' = function () { self == 0; };
  void;
};



## ----- ##
## List. ##
## ----- ##

do List
{
  var has = function (e)
  {
    # FIXME: for-in is not implemented yet.
    for (var t = self; t.size; t = t.tail)
      if (t.front == e)
	return true;
    return false;
  };

  # The Lisp-like name.
  slotCopy ("front", "head");

  void;
};

# k1 compatibility.
do Object
{
  var size = function(l)
  { 
    warn("`size(list)' is deprecated, use `list.size'");
    l.size
   };
  void;
};


## ----- ##
## Math. ##
## ----- ##

class Object.Math
{
  var abs    = function (x) { x.abs };
  var acos   = function (x) { x.acos };
  var asin   = function (x) { x.asin };
  var atan   = function (x) { x.atan };
  var cos    = function (x) { x.cos };
  var exp    = function (x) { x.exp };
  var log    = function (x) { x.log };
  var random = function (x) { x.random };
  var round  = function (x) { x.round };
  var sgn    = function (x) { x.sgn };
  var sin    = function (x) { x.sin };
  var sqr    = function (x) { x.sqr };
  var sqrt   = function (x) { x.sqrt };
  var tan    = function (x) { x.tan };
  var trunc  = function (x) { x.trunc };
  void;
};
Object.addProto (Math);



## -------- ##
## String.  ##
## -------- ##

# The connectives == and < are builtins.
# FIXME: I'd like to put the addProto in a do, but then it goes
# to the locals :(
String.addProto(Comparable);
String.addProto(Orderable);


## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
