# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;
var Code.acceptVoid = 0;
var Primitive.acceptVoid = 0;

# Must appear before any scope creation
var Scope.setSlot = Object.getSlot("setSlot");

## --------- ##
## Constants ##
## --------- ##

# Define true and false outside a do, since they are needed to run do
# scopes' doSetSlot.
class Global.Constants {};
var Global.Constants.true   = 1.0;
var Global.Constants.false  = 0.0;
Global.addProto (Global.Constants);

do Global.Constants
{
  var asString = "<Constants>";

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
};

## ------- ##
## Scope.  ##
## ------- ##

do Scope
{
  function init() { self.makeScope (true) };

  function atExit (func)
  {
    self.getLazyLocalSlot ("atexit", [], true);
    self.atexit += [getSlot ("func")]
  };
};


## -------- ##
## Object.  ##
## -------- ##

do Object
{
  # Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self.setSlot(to, self.getSlot(frm))
  };
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  copySlot ("sameAs", "==");
  copySlot ("memSameAs", "===");

  copySlot("setSlot", "setVoidSlot").acceptVoid = true;
  copySlot("updateSlot", "updateVoidSlot").acceptVoid = true;

  function '!==' (rhs)
  {
    !(self === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    # The fresh child.
    var res = call.getSlot("target").clone |
    # Call the "init" from the parent, retargetted to the child.
    getSlot("res").getSlot("init").apply([getSlot("res")] + call.evalArgs) |
    getSlot("res")
  };
};

## -------- ##
## Global.  ##
## -------- ##

do Global
{
  // Import the primitives.
  self.addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  # Add proto to obj's list of protos.  Return obj.
  # Does not require that object derives from Object to have addProto.
  function _addProto(obj, proto)
  {
    Object.getSlot("addProto").apply([obj, proto]) |
    obj
  };

  // Assertion control
  var System.ndebug = 0;
  function System.assert {
    if (!System.ndebug)
      System.assert_ (call.evalArgAt (1), call.argString (1));
  };

  function asString()
  {
    if (getSlot ("self") === Global)
      "<Global>"
    else
      Scope.getSlot("asString").apply([self]);
  };

  function noop () {}
};

## -------------- ##
## Call message.  ##
## -------------- ##

class Global.CallMessage
{
  function argString(i)
  {
    args.nth(i).string
  };

  function evalArgAt(i)
  {
    args.nth(i).eval
  };

  function argAt(i)
  {
    args.nth(i).value
  };

  function evalArgs()
  {
    args.tail.map(function (arg) { arg.eval })
  };

  function argsCount
  {
    args.size
  };
};

## ----- ##
## Lazy. ##
## ----- ##

load("urbi/lazy.u");

## ------ ##
## List.  ##
## ------ ##

load("urbi/list.u");

## --------- ##
## Closure.  ##
## --------- ##

class Global.Closure
{
  var asString = "<Closure>";

  function makeClosure ()
  {
    getSlot("self").capturedVars = nil|
    getSlot("self")
  };

  function capture (varname)
  {
    getSlot ("self").capturedVars.push_back(varname)|
    getSlot ("self")
  };

  function inject (name, value)
  {
    getSlot("self").context.setSlot(name, getSlot("value"))|
    capture (name)|
    getSlot ("self")
  };
};
Code.addProto(Global.Closure);

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context.
do Object
{
  function detach
  {
    new Task (function { call.evalArgAt (1) }) |
    void
  };

  function detach_linked
  {
    new Task (function { call.evalArgAt (1) }, true) |
    void
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1) |
      var deadline = time |
      loop {
        detach (call.evalArgAt (2)) |
	deadline += delay |
        sleep (deadline - time)
      }
    })
  };

  # at_ takes three expressions, a test and a code to execute each time the test
  # becomes true and a code to execute each time the test becomes false
  function at_
  {
    detach ({
      var t = currentRunner |
      loop {
        waituntil (call.evalArgAt (1)) |
        detach (call.evalArgAt (2)) |
        waituntil (!call.evalArgAt (1)) |
        if (call.argsCount > 3)
          detach (call.evalArgAt (3))
      }
    })
  };

  # whenever_ takes three expressions, a test and a code to execute each time the
  # test is true and a code to execute each time the test then becomes false
  function whenever_
  {
    detach ({
      var t = currentRunner |
      loop {
        waituntil (call.evalArgAt (1)) |
        loop {
          call.evalArgAt (2) |
          if (!call.evalArgAt (1))
            break
        };
        call.evalArgAt (3)
      }
    })
  };

  # waituntil takes an expression and waits until it becomes true
  function waituntil {
    var t = currentRunner |
    t.setSideEffectFree (true) |
    while (!call.evalArgAt (1)) {
      t.waitForChanges
    } |
    t.setSideEffectFree (false)
  };

  # persist takes an expression and a delay, and return an object whose val slot
  # evaluates to true if the expression has been continously true for this delay and
  # false otherwise.
  #
  # This function will be used to implement
  #   at (condition ~ delay) action [onleave leaveaction]
  # as
  #   var u = persist (condition, delay);
  #   at (u.val) action [onleave leaveaction]
  #
  # but this will require the assistance from the parser (FIXME: do it)
  #
  # FIXME: We need a way to scope the "at" and destroy it when "o" is no longer
  # visible.
  function persist {
    var o = new Object |
    var o.val = false |
    var o.tag = new Tag ("persist".fresh) |
    var delay = call.evalArgAt (2) |
    at (call.evalArgAt (1)) o.tag: { sleep (delay) | o.val = true }
      onleave { o.val = false | o.tag.stop } |
    o
  };

  class Global.Event {
    var asString = "<Event>";

    function init  () {
      var self.emitted = [] |
      var self.generation = 0
    };

    function 'emit' {
      var l = call.evalArgs |
      generation = generation + 1 |
      emitted.push_back (l);  # We want to yield here
      emitted.removeById (l) |
      void
    };

    function onEvent (func) {
      var prev_launched = [] |
      var prev_generation = 0 |
      loop {
        waituntil (generation != prev_generation) |
        prev_generation = generation |
        var launched = emitted + [] |
        for| instance in (launched) {
          if (!prev_launched.hasSame (instance))
            detach (getSlot ("func").apply ([self] + instance))
        } |
        prev_launched = launched
      }
    };
  };
};

load("urbi/channel.u");
load("urbi/singleton.u");


## ------ ##
## void.  ##
## ------ ##

void.addProto(Singleton);
// void prints nothing.
var void.asString = "";


## ---- ##
## nil. ##
## ---- ##

do nil
{
  self.addProto(Singleton);
  var isNil = true;
  function '==' (x) { x.isNil };
  var Object.isNil = false;
  var asString = "";
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Global.Comparable
{
  var asString = "<Comparable>";

  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
};
# Provide !=.
Object.addProto(Comparable);

## ----------- ##
## Orderable.  ##
## ----------- ##

class Global.Orderable
{
  var asString = "<Orderable>";

  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
};


## ------- ##
## Float.  ##
## ------- ##

load("urbi/float.u");


## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## --------- ##
## Printing. ##
## --------- ##

do Object
{
  function isProto ()
  {
    locateSlot("protoName") === locals.getSlot("self")
  };

  function type ()
  {
    if (isProto)
      "<" + protoName + ">"
    else
      protoName
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };
};

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }.capture("fn")
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (getSlot ("f"), list.tail)
    };
  };
};

load("urbi/k1.u");

## ----- ##
## Math. ##
## ----- ##

class Global.Math
{
  var asString = "<Math>";

  for fn in ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
             "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"]
  {
    Global.Math.setSlot (fn, bounce_named (fn))
  };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;
};
Global.addProto (Global.Math);


## -------- ##
## Groups.  ##
## -------- ##
load("urbi/group.u");

## ------ ##
## Tags.  ##
## ------ ##

Global.addProto (Tag);

## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object
{
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  };
};

class Global.Binary
{
  function asString()
  {
    if (self === Binary)
      "<Binary>"
    else
    {
      var res = "BIN " + data.size.asString |
      if (!keywords.empty)
	res += " " + keywords |
      res += "\n" + data |
      res
    }
  };
};

## ---------------------- ##
## Profiling operations.  ##
## ---------------------- ##

class Global.Profiling
{
  var asString = "<Profiling>";

  function timen {
    var niters = call.evalArgAt (2);
    var start_time = time;
    var start_cycle = cycle |
    { for (var i = 0; i < niters; i++)
        call.evalArgAt (1)
    } |
    var ncycles = cycle - start_cycle - 1;
    var expired = time - start_time;
    echo ("Profiling information");
    echo ("  Expression:       " + call.argString (1));
    echo ("  Iterations:       " + niters);
    echo ("  Cycles:           " + ncycles);
    echo ("  Total time:       " + expired + " ms");
    echo ("  Single iteration: " + expired / niters + " ms");
    echo ("                    " + ncycles / niters + " cycles");
  };
};
Global.addProto (Global.Profiling);

## ----------- ##
## Semaphores. ##
## ----------- ##

load("urbi/semaphore.u");


## ----------- ##
## Executable. ##
## ----------- ##

# This class is used as a flag to recognize all kind of executable code
class Global.Executable;
[Code, Primitive, Delegate].each(function (c) { c.addProto(Executable) });

## -------- ##
## UObject. ##
## -------- ##

"Initializing uobjects NOW";
load("urbi/uobject.u");

// This variable is used by initialization code to detect the end of urbi.u.
var Object.loaded = 1;

// Force a yield
sleep(10);

// Load URBI.INI outside initialization phase.
"Loading URBI.INI";
load("URBI.INI");

## ------------- ##
## Ready to go.  ##
## ------------- ##
# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
