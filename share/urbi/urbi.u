## ----------------- ##
## VisibilityScope.  ##
## ----------------- ##

# Must be before the first 'do' or 'class'
# Do and class blocks are inheriting from VisibilityScope.
# VisibilityScope has special setSlot and updateSlot preventing to write to
# the locals. Only the target can be modified implicitly
# The slot __target is expected to be set to the target of the block.
{
  var Object.VisibilityScope = Object.clone;

  function VisibilityScope.updateSlot(x, y)
  {
    getSlot("__target").updateSlot(x, getSlot("y"));
  };

  function VisibilityScope.setSlot(x, y)
  {
    getSlot("__target").setSlot(x, getSlot("y"));
  };

  void
};

# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

## -------- ##
## Protos.  ##
## -------- ##

# There are many object, functions, etc. that we want to provide.
# Instead of having Object derive from them all, we let Protos derive
# from them, and have Object derive from it.
class Object.Protos
{
  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  void;
};

Object.addProto(Object.Protos);


## -------- ##
## Object.  ##
## -------- ##

do Object
{
  # Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self.setSlot(to, getSlot(frm))
  };
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  copySlot ("sameAs", "==");

  // Invoke "clone", then "init".
  function 'new'
  {
    # The fresh child.
    var res = call.target.clone;
    # Call the "init" from the parent, retargetted to the child.
    call.target.getSlot("init").apply([res] + call.evalArgs);
    res;
  };

  void;
};

## --------- ##
## Closure.  ##
## --------- ##

class Protos.Closure
{
  function makeExplicitClosure (f, context)
  {
    var nf = getSlot ("f").clone;
    getSlot ("nf").context = context;
    var getSlot ("nf").self = context.self;
    getSlot ("nf");
  };

  function makeClosure
  {
    makeExplicitClosure (call.evalArgAt (1), call.context);
  };

  function makeClosedCode
  {
    var f = function () { call.evalArgAt (1) };
    makeClosure (getSlot ("f"))
  };

  function capture (varname, value)
  {
    if (getSlot ("self").context.isNil)
      getSlot ("self").context = new Object;
    getSlot ("self").context.setSlot (varname, value);
    getSlot ("self")
  };

  function captureVars
  {
    for (var i = 1; i < call.argsCount; i++)
      getSlot("self").capture (call.argString (i), call.evalArgAt (i));
    getSlot ("self")
  };

  void;
};

Protos.addProto(Protos.Closure);

## ------------ ##
## Scope exit.  ##
## ------------ ##

do Object
{
  function getLazy (name, default)
  {
    if (!self.slotNames.has (name))
      self.setSlot (name, default);
    self.getSlot (name);
  };
  function atExit (func)
  {
    self.getLazy ("atexit", []) += [getSlot ("func")]
  };

  void;
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context. The task will be stopped when there is no
# more references onto the returned object.
do Object
{
  function detach
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"))
  };

  function detach_linked
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"), true)
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1);
      var runners = [];
      loop {
        runners += [detach (call.evalArgAt (2))];
        sleep (delay);
      }
    })
  };

  # at_ takes two expressions, a test and a code to execute when the test
  # becomes true
  function at_
  {
    var t = detach ({
      t.setSideEffectFree (true);
      loop {
        if (call.evalArgAt (1)) {
          t.setSideEffectFree (false);
          call.evalArgAt (2);
          break
        };
        t.waitForChanges
      }
    });
    t
  };

  void
};

## ------- ##
## Scope.  ##
## ------- ##

class Protos.Scope
{
  function init() { self.makeScope (true) };
  void;
};

## --------- ##
## Constants ##
## --------- ##

class Protos.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
  void;
};
Protos.addProto (Protos.Constants);


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
class Protos.Channel
{
  function init(x) { var self.name = x };
  function '<<' (x) { x.print (name); {} };
  void;
};

// Default channels.
do Protos
{
  // Long names are k1 compatible.
  var output  = new Channel("output");
  var error   = new Channel("error");
  var warning = new Channel("warning");
  // Short names are user compatible.
  var cout    = output;
  var cerr    = error;

  function warn(msg) { echo (msg, "warning") };
  void;
};


## ------ ##
## void.  ##
## ------ ##
do void
{
  // void prints nothing.
  function print() {};
  // void is a singleton.
  function clone() { self; };
  void;
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  // nil is a singleton.
  function clone () { self };
  var isNil = true;
  function '==' (x) { x.isNil };

  var Object.isNil = false;
  void;
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Protos.Comparable
{
  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
  void;
};

// Provide !=.
Protos.addProto(Protos.Comparable);

## ----------- ##
## Orderable.  ##
## ----------- ##

class Protos.Orderable
{
  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
  void;
};


## ------- ##
## Float.  ##
## ------- ##

load("urbi/float.u");


## ------ ##
## List.  ##
## ------ ##
load("urbi/list.u");

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }.captureVars (fn)
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };

  void;
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (getSlot ("f"), list.tail)
    };
  };

  void;
};

load("urbi/k1.u");

## ----- ##
## Math. ##
## ----- ##

class Protos.Math
{
  for fn in ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
             "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"]
  {
    setSlot (fn, bounce_named (fn))
  };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;

  void;
};
Protos.addProto (Protos.Math);


## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## -------- ##
## Groups.  ##
## -------- ##
load("urbi/group.u");



## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object
{
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  };

  void;
};

## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
