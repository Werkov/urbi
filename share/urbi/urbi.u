# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

# Must appear before any scope creation

# ...

var Scope.locals = function () { self };
var lobby.locals = function () { lobby };
var lobby.self = lobby; # FIXME: leak!

# Override slot mechanisms
var Scope.setSlot = Object.getSlot("setSlot");
var Scope.getSlot = function (slotName)
{
  Object.getSlot("getSlot").apply([self.target(slotName), slotName])
};

var Scope.updateSlot = function (slotName, value)
{
  Object.getSlot("updateSlot").apply([self.target(slotName), slotName, value])
};

var Scope.removeSlot = function (slotName)
{
  Object.getSlot("removeSlot").apply([self.target(slotName), slotName])
};

## ------- ##
## Scope.  ##
## ------- ##

do Scope
{
  function init() { self.makeScope (true) };
};

## -------- ##
## Protos.  ##
## -------- ##

# There are many object, functions, etc. that we want to provide.
# Instead of having Object derive from them all, we let Protos derive
# from them, and have Object derive from it.
do Protos
{
  // Import the primitives.
  self.addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  // Assertion control
  var System.ndebug = 0;
  function System.assert {
    if (!System.ndebug)
      System.assert_ (call.evalArgAt (1), call.argString (1));
  };
};


## -------- ##
## Object.  ##
## -------- ##

do Object
{
  # Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self.setSlot(to, self.getSlot(frm))
  };
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  copySlot ("sameAs", "==");
  copySlot ("memSameAs", "===");

  // Invoke "clone", then "init".
  function 'new'
  {
    # The fresh child.
    var res = call.target.clone;
    # Call the "init" from the parent, retargetted to the child.
    call.target.getSlot("init").apply([res] + call.evalArgs);
    res;
  };
};

## --------- ##
## Closure.  ##
## --------- ##

class Protos.Closure
{
  function makeExplicitClosure (f, context)
  {
    var nf = locals.getSlot("f").clone;
    locals.getSlot("nf").context = context;
#    var locals.getSlot("nf").self = context.self;
    locals.getSlot ("nf");
  };

  function makeClosure
  {
    makeExplicitClosure (call.evalArgAt (1), call.context);
  };

  function makeClosedCode
  {
    var f = function () { call.evalArgAt (1) };
    makeClosure (locals.getSlot ("f"))
  };

  function capture (varname, value)
  {
    if (locals.getSlot("self").context.isNil)
      locals.getSlot ("self").context = new Object;
    locals.getSlot ("self").context.setSlot (varname, value);
    locals.getSlot ("self")
  };

  function captureVars
  {
    for (var i = 1; i < call.argsCount; i++)
      locals.getSlot("self").capture (call.argString (i), call.evalArgAt (i));
    locals.getSlot ("self")
  };
};

Protos.addProto(Protos.Closure);

## ------------ ##
## Scope exit.  ##
## ------------ ##

do Object
{
  function atExit (func)
  {
    self.getLazyLocalSlot ("atexit", [], true) += [locals.getSlot ("func")]
  };
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context.
do Object
{
  function detach
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"));
    void
  };

  function detach_linked
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"), true);
    void
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1);
      var deadline = time;
      loop {
        detach (call.evalArgAt (2));
	deadline += delay;
        sleep (deadline - time);
      }
    })
  };

  # at_ takes three expressions, a test and a code to execute each time the test
  # becomes true and a code to execute each time the test becomes false
  function at_
  {
    detach ({
      var t = currentRunner;
      loop {
        waituntil (call.evalArgAt (1));
        detach (call.evalArgAt (2));
        waituntil (!call.evalArgAt (1));
        if (call.argsCount > 3)
          detach (call.evalArgAt (3))
      }
    })
  };

  # whenever_ takes three expressions, a test and a code to execute each time the
  # test is true and a code to execute each time the test then becomes false
  function whenever_
  {
    detach ({
      var t = currentRunner;
      loop {
        waituntil (call.evalArgAt (1));
        loop {
          call.evalArgAt (2);
          if (!call.evalArgAt (1))
            break
        };
        call.evalArgAt (3)
      }
    })
  };

  # waituntil takes an expression and waits until it becomes true
  function waituntil {
    var t = currentRunner;
    t.setSideEffectFree (true);
    while (!call.evalArgAt (1)) {
      t.waitForChanges
    };
    t.setSideEffectFree (false);
  };

  # persist takes an expression and a delay, and return an object whose val slot
  # evaluates to true if the expression has been continously true for this delay and
  # false otherwise.
  #
  # This function will be used to implement
  #   at (condition ~ delay) action [onleave leaveaction]
  # as
  #   var u = persist (condition, delay);
  #   at (u.val) action [onleave leaveaction]
  #
  # but this will require the assistance from the parser (FIXME: do it)
  #
  # FIXME: We need a way to scope the "at" and destroy it when "o" is no longer
  # visible.
  function persist {
    var o = new Object;
    var o.val = false;
    var o.tag = new Tag ("persist".fresh);
    var delay = call.evalArgAt (2);
    at (call.evalArgAt (1)) o.tag: { sleep (delay); o.val = true }
      onleave { o.val = false; o.tag.stop };
    o;
  };
};

## --------- ##
## Constants ##
## --------- ##

class Protos.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
};
Protos.addProto (Protos.Constants);


load("urbi/channel.u");
load("urbi/singleton.u");


## ------ ##
## void.  ##
## ------ ##

do void
{
  self.addProto(Singleton);
  // void prints nothing.
  var asString = "";
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  self.addProto(Singleton);
  var isNil = true;
  function '==' (x) { x.isNil };
  var Object.isNil = false;
  var asString = "";
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Protos.Comparable
{
  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
};

// Provide !=.
Protos.addProto(Protos.Comparable);

## ----------- ##
## Orderable.  ##
## ----------- ##

class Protos.Orderable
{
  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
};


## ------- ##
## Float.  ##
## ------- ##

load("urbi/float.u");


## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## --------- ##
## Printing. ##
## --------- ##

do Object
{
  function isProto ()
  {
    locateSlot("protoName") === locals.getSlot("self")
  };

  function type ()
  {
    if (isProto)
      "<" + protoName + ">"
    else
      protoName
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone;
    if (!isProto)
      res += "_" + uid;
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };
};


## ------ ##
## List.  ##
## ------ ##
load("urbi/list.u");

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }.captureVars (fn)
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (getSlot ("f"), list.tail)
    };
  };
};

load("urbi/k1.u");

## ----- ##
## Math. ##
## ----- ##

class Protos.Math
{
  for fn in ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
             "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"]
  {
    setSlot (fn, bounce_named (fn))
  };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;
};
Protos.addProto (Protos.Math);


## -------- ##
## Groups.  ##
## -------- ##
load("urbi/group.u");

## ------ ##
## Tags.  ##
## ------ ##

Object.addProto (Tag);

## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object
{
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  };
};

class Protos.Binary
{
  function asString()
  {
    if (self === Protos.Binary)
      "<Binary>"
    else
    {
      var res = "BIN " + data.size.asString;
      if (!keywords.empty)
	res += " " + keywords;
      res += "\n" + data;
      res;
    };
  };
};

## ---------------------- ##
## Profiling operations.  ##
## ---------------------- ##

class Profiling
{
  function timen {
    var niters = call.evalArgAt (2);
    var start_time = time;
    for (var i = 0; i < niters; i++)
      call.evalArgAt (1);
    var expired = time - start_time;
    echo ("Profiling information");
    echo ("  Expression:       " + call.argString (1));
    echo ("  Iterations:       " + niters);
    echo ("  Total time:       " + expired + " ms");
    echo ("  Single iteration: " + expired / niters + " ms");
  };
};
Protos.addProto (Profiling);

## ----------- ##
## Semaphores. ##
## ----------- ##

load("urbi/semaphore.u");

## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
