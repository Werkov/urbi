/*---------.
| Object.  |
`---------*/

do (Object)
{
  // Cannot use "from" which is a k1 reserved word.
  function copySlot(frm, to)
  {
    setSlot(to, getSlot(frm))
  };

  function cloneSlot(frm, to)
  {
    setSlot(to, getSlot(frm).clone)
  };

  // Some sort of k1 compatibility.
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  // Change the whole set of parents.
  function setProtos(ps)
  {
    // Beware that we may be losing the ancestry on Object, which has
    // access to "addProto".
    var add = Object.getSlot("addProto") |
    protos.clear() |
    for| (var p: ps.reverse)
      add.apply([this, p]) |
  };

  function '!==' (rhs)
  {
    !(this === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };
};

/*---------.
| Global.  |
`---------*/

do (Global)
{
  // Import the primitives.
  addProto(System);

  // Look for file and load file.
  function load(file)
  {
    loadFile(searchFile(file));
  };
};


load("urbi/exception.u");
load("urbi/call-message.u");
load("urbi/lazy.u");
load("urbi/list.u");
load("urbi/singleton.u");

/*-------.
| void.  |
`-------*/

// FIXME: Can't do this in urbi
// void.addProto(Singleton);

do (Object)
{
  var isVoid = false;
  function acceptVoid()   { this };
  function unacceptVoid() { this };
};
do (void.acceptVoid)
{
  function acceptVoid()   { new };
  function unacceptVoid() { protos.front };
};

/*-----------.
| Booleans.  |
`-----------*/

load("urbi/boolean.u");

/*------.
| nil.  |
`------*/

do (nil)
{
  // Singleton derives from Object.
  setProtos([Singleton]);
  function '==' (x) { x.isNil };
  var asString = "nil";
  // nil prints nothing in the toplevel
  var asToplevelPrintable = nil;
};

do (Object)
{
  function isNil()
  {
    nil === this
  }
};

/*---------------------------.
| Method function wrappers.  |
`---------------------------*/

do (Global)
{
  // Make a function f from a method m, so as f(a, b, c) is equivalent
  // to a.m(b, c)
  // FIXME: I'm not satisfied with the name, but can't find anything
  // better
  function methodToFunction(name)
  {
    function
    {
      var args = call.evalArgs |
      var val = args.head.getSlot(name) |
      if (val.isA(Executable))
        return val.apply(args)
      else
        return val |
    }
  };
};


load("urbi/control.u");
load("urbi/channel.u");

// Disable top-level display
topLevel.enabled = false;

load("urbi/comparable.u");
// Provide !=.
Object.addProto(Comparable);

load("urbi/orderable.u");
load("urbi/updatehook-stack.u");
load("urbi/float.u");
load("urbi/trajectory-generator.u");
load("urbi/path.u");
load("urbi/string.u");
load("urbi/system.u");
load("urbi/object.u");
load("urbi/file.u");
load("urbi/formatter.u");

do (Object)
{
  function ownsSlot(s)
  {
    warn("`o.ownsSlot(s)' is deprecated, use `o.hasLocalSlot(s)'") |
    hasLocalSlot(s)
  };

  function slotNames()
  {
    warn("the semantics of `slotNames' is about to change from `localSlotNames' to `allSlotNames', consistently with `hasLocalSlot'/`hasSlot'.  In the meanwhile please use either `localSlotNames' or `allSlotNames'") |
    localSlotNames
  };

  function isProto()
  {
    hasLocalSlot("type")
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };

  function format (f = FormatInfo)
  {
    asPrintable.format(f)
  };

  function asPrintable ()
  {
    asString
  };

  function asToplevelPrintable ()
  {
    asPrintable
  };
};

do (Object)
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do (Object)
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };
};

load("urbi/k1.u");

/*--------------.
| Conversions.  |
`--------------*/

do (Object)
{
  function as(type)
  {
    getSlot("as" + type.type).apply([this])
  }
};


load("urbi/math.u");
load("urbi/group.u");
load("urbi/binary.u");
load("urbi/profiling.u");
load("urbi/position.u");
load("urbi/loadable.u");
load("urbi/tuple.u");
load("urbi/dictionary.u");
load("urbi/weak-pointer.u");
load("urbi/pattern.u");
load("urbi/task.u");

// Properties require patterns
do (Object)
{
  // Syntactic sugar for setProtos.
  protos->updateHook = function(slot, value) { setProtos(value); };
};

load("urbi/pubsub.u");
load("urbi/event.u");
load("urbi/tag.u");
load("urbi/lobby.u");
load("urbi/mutex.u");
load("urbi/timeout.u");
load("urbi/socket.u");

/*----------.
| UObject.  |
`----------*/

"Initializing uobjects NOW";
load("urbi/uobject.u");

/*-----------.
| Tutorial.  |
`-----------*/

function help()
{
  load("urbi/tutorial.u");
  detach(tutorial.start);
};

// This variable is used by initialization code to detect the end of
// urbi.u.
topLevel.enabled = true |
var Object.loaded = 1 |;

// Load URBI.INI outside initialization phase.
try
{
  var this.urbi_ini_path = searchFile("URBI.INI");
}
catch (var e if e.isA(FileNotFound))
{
  var this.urbi_ini_path = nil;
}|;
if (!urbi_ini_path.isNil)
{
  echo("Loading %s" % [urbi_ini_path], "start");
  loadFile(urbi_ini_path);
};
removeSlot("urbi_ini_path")|;

/*-----------------------------------------------------------.
| Ready to go.  This string is special and expected by       |
|  uconsole-check as the signal that we have loaded urbi.u.  |
|  Messages before, and including this one, are ignored.     |
`-----------------------------------------------------------*/
echo("Urbi is up and running.", "start");

