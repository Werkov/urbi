/*-----------------.
| System version.  |
`-----------------*/

var System.version = "2.0";

/*------------.
| Constants.  |
`------------*/

class Global.Constants
{
  var pi     = 3.14159265358979323846264338327950288;
  var inf    = Float.inf;
  var nan    = Float.nan;
};

Global.addProto (Global.Constants);

/*------.
| Tag.  |
`------*/

Global.addProto (Global.Tag);

/*---------.
| Object.  |
`---------*/

do Object
{
  // Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    setSlot(to, getSlot(frm))
  };

  function cloneSlot (frm, to)
  {
    setSlot(to, getSlot(frm).clone)
  };

  /// Whether <slot> is a (direct, not from protos) member of this.
  /// Works properly with "nil", which is not the case of versions
  /// relying on locateSlot.
  function ownsSlot (s)
  {
    return s in slotNames;
  };

  // Some sort of k1 compatibility.
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  // Change the whole set of parents.
  function setProtos(ps)
  {
    // Beware that we may be losing the ancestry on Object, which has
    // access to "addProto".
    var add = Object.getSlot("addProto") |
    protos.clear() |
    for| (var p: ps.reverse)
      add.apply([this, p]) |
  };

  // Syntactic sugar for setProtos.
  protos->updateHook = function(slot, value) { setProtos(value); };

  function '==' (other)
  {
    sameAs(other)
  };

  function '===' (other)
  {
    memSameAs(other)
  };

  function '!==' (rhs)
  {
    !(this === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };
};

/*---------.
| Global.  |
`---------*/

do Global
{
  // Import the primitives.
  addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  // Assertion control
  var System.ndebug = false;
  function System.assert
  {
    if (!System.ndebug)
      System.assert_ (call.evalArgAt (0), call.argString (0));
  };

  function noop () {};
};

/*------------.
| Exception.  |
`------------*/

load("urbi/exception.u");

/*---------------.
| Call message.  |
`---------------*/

load("urbi/call-message.u");

/*-------.
| Lazy.  |
`-------*/

load("urbi/lazy.u");

/*-------.
| List.  |
`-------*/

load("urbi/list.u");

/*------------.
| Singleton.  |
`------------*/

load("urbi/singleton.u");

/*-------.
| void.  |
`-------*/

// FIXME: Can't do this in urbi
// void.addProto(Singleton);

do Object
{
  var isVoid = false;
  function acceptVoid ()
  {
    this
  };
  function unAcceptVoid()
  {
    this
  }
};
var void.acceptVoid.acceptVoid = function() { new };
var void.acceptVoid.unAcceptVoid = function() { protos.front };

/*-----------.
| Booleans.  |
`-----------*/

load("urbi/boolean.u");

/*------.
| nil.  |
`------*/

do nil
{
  // Singleton derives from Object.
  setProtos([Singleton]);
  function '==' (x) { x.isNil };
  var asString = "nil";
  // nil prints nothing in the toplevel
  var asToplevelPrintable = nil;
};

do Object
{
  function isNil()
  {
    nil === this
  }
};

/*---------------------------.
| Method function wrappers.  |
`---------------------------*/

do Global
{
  // Make a function f from a method m, so as f(a, b, c) is equivalent
  // to a.m(b, c)
  // FIXME: I'm not satisfied with the name, but can't find anything
  // better
  function methodToFunction(name)
  {
    function
    {
      var args = call.evalArgs |
      var val = args.head.getSlot(name) |
      if (val.isA(Executable))
        return val.apply(args)
      else
        return val |
    }
  };
};


/*----------.
| Control.  |
`----------*/

load("urbi/control.u");


/*----------.
| Channel.  |
`----------*/

load("urbi/channel.u");


// Disable top-level display
topLevel.enabled = false;
/*-------------.
| Comparable.  |
`-------------*/

class Global.Comparable
{
  function '!=' (rhs) { ! (this == rhs) };
  function '==' (rhs) { ! (this != rhs) };
};
// Provide !=.
Object.addProto(Comparable);

/*------------.
| Orderable.  |
`------------*/

class Global.Orderable
{
  function '<'  (rhs) { rhs > this };
  function '<=' (rhs) { this < rhs || this == rhs };
  function '>'  (rhs) { rhs < this };
  function '>=' (rhs) { this > rhs || this == rhs };
};


load("urbi/updatehook-stack.u");
load("urbi/float.u");
load("urbi/trajectory-generator.u");
load("urbi/string.u");



/*-----------.
| Printing.  |
`-----------*/

do Object
{
  function isProto ()
  {
    ownsSlot("protoName")
  };

  function type ()
  {
    if (isProto)
      "<" + protoName + ">"
    else
      protoName
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };

  function asPrintable ()
  {
    asString
  };

  function asToplevelPrintable ()
  {
    asPrintable
  };
};

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };
};

load("urbi/k1.u");

/*--------------.
| Conversions.  |
`--------------*/

do Object
{
  function as(type)
  {
    getSlot("as" + type.protoName).apply([this])
  }
};

/*-------.
| Math.  |
`-------*/

class Global.Math
{
  for (var fn: ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
               "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"])
  {
    setSlot (fn, bounce_named (fn))
  };

  // Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;
};
Global.addProto(Global.Math);


/*---------.
| Groups.  |
`---------*/
load("urbi/group.u");

load("urbi/binary.u");

load("urbi/profiling.u");


/*-------------.
| Executable.  |
`-------------*/

// This class is used as a flag to recognize all kind of executable code
class Global.Executable {};

// Executable derives from Object.
for (var c: [Code, Primitive])
  c.setProtos([Executable]);
var Object.'()' = function()
{
  this.apply([this]);
};

load("urbi/loadable.u");

/*--------.
| Tuple.  |
`--------*/

load("urbi/tuple.u");

/*-------------.
| Dictionary.  |
`-------------*/

load("urbi/dictionary.u");

/*--------------------.
| Debugging helpers.  |
`--------------------*/

load("urbi/debug.u");

/*-------------------.
| Pattern matching.  |
`-------------------*/

load("urbi/pattern.u");

/*--------------------.
| Publish-subscribe.  |
`--------------------*/

load("urbi/pubsub.u");

/*---------.
| Events.  |
`---------*/

load("urbi/event.u");

/*----------.
| UObject.  |
`----------*/

"Initializing uobjects NOW";
load("urbi/uobject.u");

/*-----------.
| Tutorial.  |
`-----------*/

function help()
{
  load("urbi/tutorial.u");
  detach(tutorial.start);
};

// This variable is used by initialization code to detect the end of urbi.u.
topLevel.enabled = true |
var Object.loaded = 1 |
{};

// Load URBI.INI outside initialization phase.
"Loading URBI.INI";
load("URBI.INI");

/*-----------------------------------------------------------.
| Ready to go.  This string is special and expected by       |
|  uconsole-check as the signal that we have loaded urbi.u.  |
|  Messages before, and including this one, are ignored.     |
`-----------------------------------------------------------*/
"Urbi is up and running.";
