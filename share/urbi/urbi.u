## -------- ##
## Object.  ##
## -------- ##

# Cannot use "copy", nor "from" which are k1 reserved words :) :) :)
Object.slotCopy = function (frm, to) {
  # This is annoying: one has to specify "self" here, otherwise the
  # setSlot goes to the locals_ :(
  self . setSlot(to, getSlot(frm))
};
Object.slotCopy ("addParent", "inherit");
Object.slotCopy ("removeParent", "disinherit");


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
var Channel = new Object;


## ------- ##
## Float.  ##
## ------- ##

Float.init = function (x) { self.set(x) };

Float.+= = function (x) { self.set (self + x) };
Float.-= = function (x) { self.set (self - x) };
Float.*= = function (x) { self.set (self * x) };
Float./= = function (x) { self.set (self / x) };

// One would like to write
//
// Float.++ = function () { var res = self.clone; self += 1; res };
//
// but it does not return a Float, it returns an Object which
// has Float as *grand*-parent.  As a result, it does not have
// a value (it is not an Atom<Float>).  This might be to change,
// but it is to me (akim) unclear how.
//
// This does not work either: var res = new Float(self), because it
// creates an Object which derives from Float, but which is not a
// Atom<Float>.  Not nice, eh?
Float.++ = function () { var res = 0; res.set(self); self += 1; res };
Float.-- = function () { var res = 0; res.set(self); self -= 1; res };


## -------- ##
## String.  ##
## -------- ##

# We do have ==, <, and != as builtins.
# FIXME: Introduce "Sortable", or whatever, which defines these
# operators, and derive from it.
String.<= = function (rhs) { self < rhs || self == rhs };
String.>  = function (rhs) { rhs < self };
String.>= = function (rhs) { rhs < self || self == rhs };


## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
