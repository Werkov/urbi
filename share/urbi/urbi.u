# FIXME: this code should be split in several files, once we have
# a "load" that works.

## ----------------- ##
## VisibilityScope.  ##
## ----------------- ##

# Must be before the first 'do' or 'class'
# Do and class blocks are inheriting from VisibilityScope.
# VisibilityScope has special setSlot and updateSlot preventing to write to
# the locals. Only the target can be modified implicitly
# The slot __target is expected to be set to the target of the block.
{
  var Object.VisibilityScope = Object.clone;

  function VisibilityScope.updateSlot(x, y)
  {
   getSlot("__target").updateSlot(x, getSlot("y"));
  };

  function VisibilityScope.setSlot(x, y)
  {
   getSlot("__target").setSlot(x, getSlot("y"));
  };

  void
};

## -------- ##
## Object.  ##
## -------- ##

# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

do Object
{
  # Cannot use "copy", nor "from" which are k1 reserved words :) :) :)
  function slotCopy (frm, to) {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self . setSlot(to, getSlot(frm))
  };
  slotCopy ("addProto", "inherit");
  slotCopy ("removeProto", "disinherit");
  
  slotCopy ("sameAs", "==");
  void
};

## --------- ##
## Closure.  ##
## --------- ##

do Object {
  function makeExplicitClosure (f, context)
  {
    var nf = getSlot ("f").clone;
    getSlot ("nf").context = context;
    getSlot ("nf");
  };

  function makeClosure
  {
    makeExplicitClosure (call.evalArgAt (1), call.context);
  };

  function makeClosedCode
  {
    var f = function () { call.evalArgAt (1) };
    makeClosure (getSlot ("f"))
  };

  function capture (varname, value)
  {
    if (getSlot ("self").context.isNil)
      getSlot ("self").context = new Object;
    getSlot ("self").context.setSlot (varname, value);
    getSlot ("self")
  };

  function captureVars
  {
    for (var i = 1; i < call.argsCount; i++)
      getSlot("self").capture (call.argString (i), call.evalArgAt (i));
    getSlot ("self")
  }
};

## ------------ ##
## Scope exit.  ##
## ------------ ##

do Object
{
  function getLazy (name, default)
  {
    if (!self.slotNames.has (name))
      self.setSlot (name, default);
    self.getSlot (name);
  };
  function atExit (func)
  {
    self.getLazy ("atexit", []) += [getSlot ("func")]
  }
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context. The task will be stopped when there is no
# more references onto the returned object.
do Object
{
  function detach
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"))
  };
  
  function detach_linked
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"), true)
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1);
      var runners = [];
      loop {
        runners += [detach (call.evalArgAt (2))];
        sleep (delay);
      }
    })
  };
  
  # at_ takes two expressions, a test and a code to execute when the test
  # becomes true
  function at_
  {
    var t = detach ({
      t.setSideEffectFree (true);
      loop {
        if (call.evalArgAt (1)) {
          t.setSideEffectFree (false);
          call.evalArgAt (2);
          break
        };
        t.waitForChanges
      }
    });
    t
  };

  void
};

## ------- ##
## Scope.  ##
## ------- ##

class Object.Scope {
  function init() { self.makeScope (true) }
};

## --------- ##
## Constants ##
## --------- ##

class Object.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
  void;
};
Object.addProto (Constants);


## --------- ##
## Channel.  ##
## --------- ##

// Does not have anything special.  Yet.
class Object.Channel
{
  function init(x) { var self.name = x };
  function '<<'(x) { x.print (name); {} };
  void;
};

// Default channels.
do Object
{
  // Long names are k1 compatible.
  var output  = new Channel("output");
  var error   = new Channel("error");
  var warning = new Channel("warning");
  // Short names are user compatible.
  var cout  = output;
  var cerr  = error;

  function warn(msg) { echo (msg, "warning") };
  void;
};


## ------ ##
## void.  ##
## ------ ##
do void
{
  // void prints nothing.
  function print() {};
  // void is a singleton.
  function clone() { self; };
  void;
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  // nil is a singleton.
  function clone () { self };
  var isNil = true;
  function '==' (x) { x.isNil };

  var Object.isNil = false;
  void;
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Object.Comparable
{
  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
  void;
};


## ----------- ##
## Orderable.  ##
## ----------- ##

class Object.Orderable
{
  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
  void;
};


## ------- ##
## Float.  ##
## ------- ##

do Float
{
  self.addProto(Comparable);
  self.addProto(Orderable);

  function init(x) { self.set(x) };

  function sqr() { self * self };

  function '+='(x) { self.set (self + x) };
  function '-='(x) { self.set (self - x) };
  function '*='(x) { self.set (self * x) };
  function '/='(x) { self.set (self / x) };

  // One would like to write
  //
  // function '++' () { var res = self.clone; self += 1; res };
  //
  // but it does not return a Float, it returns an Object which
  // has Float as *grand*-proto.  As a result, it does not have
  // a value (it is not an Atom<Float>).  This might be to change,
  // but it is to me (akim) unclear how.
  //
  // This does not work either: var res = new Float(self), because it
  // creates an Object which derives from Float, but which is not a
  // Atom<Float>.  Not nice, eh?

  function '++'() { var res = 0; res.set(self); self += 1; res };
  function '--'() { var res = 0; res.set(self); self -= 1; res };
  function '~='(x) { (self - x).abs <= epsilontilde };
  function '%='(x) { (1.0 - self / x).abs <= epsilonpercent };
  # FIXME: =~= cannot be correctly implemented without properties.
  function '=~='(x) { (self - x) <= self.delta + x.delta };
  function sgn() { if (self < 0) -1 else if (self > 0) 1 else 0 };

  function '!'() { self == 0; };

  function seq()
  {
    var result = [];
    for (var i = 0; i < self; i++)
      result.insert(i.clone);
    result
  };

  void;
};



## ----- ##
## List. ##
## ----- ##

do List
{
  function has(e)
  {
    for i in self
    {
      if (i == e)
	return true;
    };
    return false;
  };

  # The Lisp-like name.
  slotCopy ("front", "head");

  void;
};

load("urbi/k1.u");

## ----- ##
## Math. ##
## ----- ##

class Object.Math
{
  # Standard functions.
  function abs   (x) { x.abs };
  function acos  (x) { x.acos };
  function asin  (x) { x.asin };
  function atan  (x) { x.atan };
  function cos   (x) { x.cos };
  function exp   (x) { x.exp };
  function log   (x) { x.log };
  function random(x) { x.random };
  function round (x) { x.round };
  function sgn   (x) { x.sgn };
  function sin   (x) { x.sin };
  function sqr   (x) { x.sqr };
  function sqrt  (x) { x.sqrt };
  function tan   (x) { x.tan };
  function trunc (x) { x.trunc };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;

  void;
};
Object.addProto (Math);


## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## ------------------------ ##
## Functional programming.  ##
## ------------------------ ##

do List {
  function map (f)
  {
    var res = [];
    for i in self { res += [f (i)] };
    res
  };

  function any (f)
  {
    for i in self { if (f (i)) return true };
    false
  };

  function all (f)
  {
    for i in self { if (!f (i)) return false };
    true
  }
};

var Object.tasks = [];

function Object.eachBg(f, list)
{
  if (list.size)
  {
    Object.tasks += [detach (f (list.head))];
    eachBg (getSlot ("f"), list.tail)
  }
};

## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object {
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  }
};

## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
