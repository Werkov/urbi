## ----------------- ##
## VisibilityScope.  ##
## ----------------- ##

# Must be before the first 'do' or 'class'
# Do and class blocks are inheriting from VisibilityScope.
# VisibilityScope has special setSlot and updateSlot preventing to write to
# the locals. Only the target can be modified implicitly
# The slot __target is expected to be set to the target of the block.
{
  var Protos.VisibilityScope = Object.clone;

  function VisibilityScope.updateSlot(x, y)
  {
    getSlot("__target").updateSlot(x, getSlot("y"));
  };

  function VisibilityScope.setSlot(x, y)
  {
    getSlot("__target").setSlot(x, getSlot("y"));
  };

  void;
};

# This has to be present before the first function call, otherwise
# we will have a fatal error when trying to determine the context
# in which the function will be evaluated.
var Code.context = nil;

## -------- ##
## Protos.  ##
## -------- ##

# There are many object, functions, etc. that we want to provide.
# Instead of having Object derive from them all, we let Protos derive
# from them, and have Object derive from it.
do Protos
{
  // Import the primitives.
  self.addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  void;
};


## -------- ##
## Object.  ##
## -------- ##

do Object
{
  # Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    # This is annoying: one has to specify "self" here, otherwise the
    # setSlot goes to the locals_ :(
    self.setSlot(to, getSlot(frm))
  };
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  copySlot ("sameAs", "==");

  // Invoke "clone", then "init".
  function 'new'
  {
    # The fresh child.
    var res = call.target.clone;
    # Call the "init" from the parent, retargetted to the child.
    call.target.getSlot("init").apply([res] + call.evalArgs);
    res;
  };

  void;
};

## --------- ##
## Closure.  ##
## --------- ##

class Protos.Closure
{
  function makeExplicitClosure (f, context)
  {
    var nf = getSlot ("f").clone;
    getSlot ("nf").context = context;
    var getSlot ("nf").self = context.self;
    getSlot ("nf");
  };

  function makeClosure
  {
    makeExplicitClosure (call.evalArgAt (1), call.context);
  };

  function makeClosedCode
  {
    var f = function () { call.evalArgAt (1) };
    makeClosure (getSlot ("f"))
  };

  function capture (varname, value)
  {
    if (getSlot ("self").context.isNil)
      getSlot ("self").context = new Object;
    getSlot ("self").context.setSlot (varname, value);
    getSlot ("self")
  };

  function captureVars
  {
    for (var i = 1; i < call.argsCount; i++)
      getSlot("self").capture (call.argString (i), call.evalArgAt (i));
    getSlot ("self")
  };

  void;
};

Protos.addProto(Protos.Closure);

## ------------ ##
## Scope exit.  ##
## ------------ ##

do Object
{
  function atExit (func)
  {
    self.getLazyLocalSlot ("atexit", [], true) += [getSlot ("func")]
  };

  void;
};

## -------------------- ##
## Task related stuff.  ##
## -------------------- ##

# Detach takes an expression and evaluates it in background within
# the caller's context. The task will be stopped when there is no
# more references onto the returned object.
do Object
{
  function detach
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"))
  };

  function detach_linked
  {
    var f = makeClosedCode (call.evalArgAt (1));
    new Task (getSlot ("f"), true)
  };

  # every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1);
      loop {
        detach (call.evalArgAt (2));
        sleep (delay);
      }
    })
  };

  # at_ takes three expressions, a test and a code to execute each time the test
  # becomes true and a code to execute each time the test becomes false
  function at_
  {
    detach ({
      var t = currentRunner;
      loop {
        t.setSideEffectFree (true);
        loop {
          if (call.evalArgAt (1))
            break;
          t.waitForChanges
        };
        t.setSideEffectFree (false);
        detach (call.evalArgAt (2));
        t.setSideEffectFree (true);
        loop {
          if (!call.evalArgAt (1))
            break;
          t.waitForChanges
        };
        t.setSideEffectFree (false);
        detach (call.evalArgAt (3))
      }
    })
  };

  # whenever_ takes three expressions, a test and a code to execute each time the
  # test is true and a code to execute each time the test then becomes false
  function whenever_
  {
    detach ({
      var t = currentRunner;
      loop {
        t.setSideEffectFree (true);
        loop {
          if (call.evalArgAt (1))
            break;
          t.waitForChanges
        };
        t.setSideEffectFree (false);
        loop {
          call.evalArgAt (2);
          if (!call.evalArgAt (1))
            break
        };
        call.evalArgAt (3)
      }
    })
  };

  void;
};

## ------- ##
## Scope.  ##
## ------- ##

class Protos.Scope
{
  function init() { self.makeScope (true) };
  void;
};

## --------- ##
## Constants ##
## --------- ##

class Protos.Constants
{
  var true   = 1.0;
  var false  = 0.0;

  # FIXME: use real float infinity, or a special token, but not that
  var inf    = 999999999999999.0;

  var pi     = 3.14159265358979323846264338327950288;
  void;
};
Protos.addProto (Protos.Constants);


load("urbi/channel.u");
load("urbi/singleton.u");


## ------ ##
## void.  ##
## ------ ##

do void
{
  self.addProto(Singleton);
  // void prints nothing.
  function print() {};
};


## ---- ##
## nil. ##
## ---- ##

do nil
{
  self.addProto(Singleton);
  var isNil = true;
  function '==' (x) { x.isNil };
  var Object.isNil = false;
  void;
};


## ------------ ##
## Comparable.  ##
## ------------ ##

class Protos.Comparable
{
  function '!=' (rhs) { ! (self == rhs) };
  function '==' (rhs) { ! (self != rhs) };
  void;
};

// Provide !=.
Protos.addProto(Protos.Comparable);

## ----------- ##
## Orderable.  ##
## ----------- ##

class Protos.Orderable
{
  function '<'  (rhs) { rhs > self };
  function '<=' (rhs) { self < rhs || self == rhs };
  function '>'  (rhs) { rhs < self };
  function '>=' (rhs) { self > rhs || self == rhs };
  void;
};


## ------- ##
## Float.  ##
## ------- ##

load("urbi/float.u");


## ------ ##
## List.  ##
## ------ ##
load("urbi/list.u");

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }.captureVars (fn)
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };

  void;
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (getSlot ("f"), list.tail)
    };
  };

  void;
};

load("urbi/k1.u");

## ----- ##
## Math. ##
## ----- ##

class Protos.Math
{
  for fn in ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
             "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"]
  {
    setSlot (fn, bounce_named (fn))
  };

  # Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;

  void;
};
Protos.addProto (Protos.Math);


## -------- ##
## String.  ##
## -------- ##
load("urbi/string.u");



## -------- ##
## Groups.  ##
## -------- ##
load("urbi/group.u");



## -------------------------- ##
## Logic with short-circuit.  ##
## -------------------------- ##

do Object
{
  function '&&' {
    if (self) call.evalArgAt (1) else self;
  };

  function '||' {
    if (self) self else call.evalArgAt (1);
  };

  void;
};

class Object.Binary {};
var Object.Binary.asString = function() {
  "BIN " + data.size.asString + " "  + keywords + "\n" + data
};
## ------------- ##
## Ready to go.  ##
## ------------- ##

# This string is special and expected by uconsole-check as the
# signal that we have loaded urbi.u.  Messages before, and including
# this one, are ignored.
"Urbi is up and running.";
