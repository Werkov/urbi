/*
 * Copyright (C) 2010, Gostai S.A.S.
 *
 * This software is provided "as is" without warranty of any kind,
 * either expressed or implied, including but not limited to the
 * implied warranties of fitness for a particular purpose.
 *
 * See the LICENSE file for more information.
 */

do (System)
{
  const var version = "2.0";

  // Assertion control.
  var ndebug = false;

  function assert_(assertion, message)
  {
    if (!assertion)
      throw Exception.new("failed assertion: " + message);
  };

  /// assert(assertion).
  function 'assert'
  {
    if (call.args.size != 1)
      throw Exception.Arity.new(call.message, call.args.size, 1) |
    if (!ndebug)
      assert_(call.evalArgAt(0), call.argString(0));
  };

  // To be executed when we have dictionnaries.
  function '$registerOps'()
  {
    if (this.hasLocalSlot("$opNeg"))
      return |
    var this.'$fun_rename' =
      [
        "has"    => ("in", [(0, 1)]),
        "hasNot" => ("not in", [(0, 1)]),
      ] |
    var this.'$opNeg' =
      [
        "=="  => "!=",
        "===" => "!==",
        "<"   => ">=",
        "<="  => ">",
        "in"  => "not in",
      ] |
    // add the opposite.
    for|(var p: this.'$opNeg')
      this.'$opNeg'[p[1]] = p[0];
  };

  /// assertCall(Message: String | Lazy, Lhs, Rhs).
  function assertCall
  {
    if (call.args.size < 2)
      throw Exception.Arity.new(call.message, call.args.size, 2) |
    if (!ndebug)
    {
      '$registerOps' |
      // Support lazy invocations (all arguments are lazy),
      // or a partially lazy one, to ease bouncing from functions.
      var message =
      {
        if (call.args[0].type == "String")
          call.args[0]
        else
          call.argAt(0)
      }|

      // Skip the function name.
      var args = call.args.tail |

      var c = call |
      c.message = message |

      var target = args[0] |
      c.args = args.tail |

      // Do the assertion and compute its message if thrown.
      var res = target.value.acceptVoid.callMessage(c) |
      assert_(res, {

        var unevaluated = Object.new |
        var unevaluated.asString = "?" |

        var args = [target] + c.args |
        // Evaluate all arguments, and pretty print them.
        var argStr = args.map(closure (v) { v.asString }) |
        var argVal = args.map(closure (v) {
          if (v.getSlot("val").isVoid
            || v.getSlot("val").allProtos.hasSame(Executable))
            unevaluated
          else
            v.val
        }) |
        var argPrint = argVal.map(closure (v) { v.asPrintable }) |

        // Cases where an operator is just a sugar over a function name,
        // and reorder the argument in consequences.
        var op = message |
        if (message in '$fun_rename')
        {
          var renamed = '$fun_rename'[message] |
          op = renamed[0] |
          var tmp |
          for|(var sw: renamed[1])
          {
            tmp = argStr[sw[0]] |
            argStr[sw[0]] = argStr[sw[1]] |
            argStr[sw[1]] = tmp |
            tmp = argPrint[sw[0]] |
            argPrint[sw[0]] = argPrint[sw[1]] |
            argPrint[sw[1]] = tmp |
          }
        } |

        // The format string to display the unevaluated assertion.
        var msg = "" |
        // The format string to display the assertion with values.
        var simpleMsg |

        var msgArgs =       [argStr.head, op] + argStr.tail |
        var simpleMsgArgs = [argPrint.head, op] + argPrint.tail |

        // Binary operators.
        if (args.size == 2 && op in '$opNeg')
        {
          // Output messages for operators
          msg = "%s %s %s" |
          simpleMsg = "%s %s %s" |
          simpleMsgArgs[1] = '$opNeg'[op];
        }
        else
        {
          // If the assertion is about an implicit target, don't mention
          // it.
          if (argStr[0] == "<IMPLICIT>")
          {
            msgArgs.removeFront |
            simpleMsgArgs.removeFront |
          }
          else
            msg = "%s."|

          // Message name.
          msg += "%s" |

          // Arguments.
          if (2 <= args.size)
            msg += "(%s" + ", %s" * (args.size - 2) + ")" |

          simpleMsg = "! " + msg |
        }|

        // Add resolved values, if differerent from the unevaluated
        // arguments.
        if (msgArgs != simpleMsgArgs)
        {
          msg += " (" + simpleMsg + ")" |
          msgArgs += simpleMsgArgs |
        }|

        msg % msgArgs
      })|
    }
  };


  /// assert_op(Operator: String | Lazy, Lhs, Rhs).
  var assert_op = getSlot("assertCall");

  var period = 20ms;

  // systemFiles.
  systemFiles->updateHook = function(slot, value)
  {
    setSystemFiles(value) |
    void
  };
  var loadFile_ = getSlot("loadFile");
  var defaultIsSystem = true;
  loadFile = function(file, isSystem = defaultIsSystem)
  {
    var res = loadFile_(file).acceptVoid |
    if (isSystem)
    {
      addSystemFile(file.asString)
    } |
    res.unacceptVoid
  };
  addSystemFile("urbi/urbi.u");
  addSystemFile(searchFile("urbi/urbi.u").asString);
  addSystemFile(searchFile("urbi/system.u").asString);

  [
    "ast/factory.cc",
    "ast/parametric-ast.cc",
    "ast/parametric-ast.hh",
    "ast/parametric-ast.hxx",
    "binder/binder.cc",
    "flower/flower.cc",
    "object/code.cc",
    "parser/ugrammar.y",
    "rewrite/desugarer.cc",
    "rewrite/pattern-binder.cc",
    "rewrite/rescoper.cc"
  ].each(getSlot("addSystemFile"));

  /// Look for file and load it.
  // Throw on errors.
  function load(file)
  {
    loadFile(searchFile(file));
  };

  function lobbies()
  {
    Lobby.instances
  };

  function lobby()
  {
    Lobby.lobby
  };

  // Look for file, and load it if found.
  function maybeLoad(var file, var channel = Global.clog)
  {
    var path = nil |
    try
    {
      path = searchFile(file)
    }
    catch (var e if e.isA(Exception.FileNotFound))
    {
    }|
    if (!path.isNil)
    {
      channel.echo("loading %s." % path) |
      loadFile(path)
    }
  };

  function ps()
  {
    nonInterruptible |
    for| (var t : jobs)
      t.dumpState
  };

  // Do not make a wrapper function here, as you would get a tag for
  // the scope of that function, instead of the caller.
  setSlot("scopeTag", Tag.getSlot("scope"));

};
