do (System)
{
  const var version = "2.0";

  // Assertion control.
  var ndebug = false;

  function assert_(assertion, message)
  {
    if (!assertion)
      throw Exception.new("failed assertion: " + message);
  };

  /// assert(assertion).
  function 'assert'
  {
    if (call.args.size != 1)
      throw Exception.Arity.new(call.message, call.args.size, 1) |
    if (!ndebug)
      assert_(call.evalArgAt(0), call.argString(0));
  };

  // Return a string that represents the negation of "op".
  function assert_neg_op (op)
  {
    var ops =
      (
        '==':  "!="
        '===': "!=="
        '<':   ">="
        '<=':  ">"
      );
    for (var p: ops)
      ops[p.second] = p.first;
    ops.getWithDefault(op, "(! %s)" % op);
  };

  /// assert_op(Operator: String | Lazy, Lhs, Rhs).
  function assert_op
  {
    if (call.args.size != 3)
      throw Exception.Arity.new(call.message, call.args.size, 3) |
    if (!ndebug)
    {
      var lhs = call.evalArgAt(1) |
      var rhs = call.evalArgAt(2) |
      var lhsStr = call.argString(1) |
      var rhsStr = call.argString(2) |

      // Support lazy invocations (all arguments are lazy),
      // or a partially lazy one, to ease bouncing from assert_eq.
      var opStr =
        {
          if (call.args[0].'$type' == "String")
            call.args[0]
          else
            call.argAt(0);
        } |
      assert_(lhs.getSlot(opStr).apply([lhs, rhs]),
              "%s %s %s (%s %s %s)"
                 % [lhsStr, opStr, rhsStr,
                    lhs.asPrintable, assert_neg_op(opStr), rhs.asPrintable])
    }
  };

  /// assert_eq(Lhs, Rhs) and so forth.
  // Cannot do this, as we don't have Dictionary.each yet.
  //for (var p :
  //      (
  //        assert_eq: "=="
  //        assert_ge: ">="
  //        assert_gt: ">"
  //        assert_le: "<="
  //        assert_lt: "<"
  //        assert_ne: "!="
  //      ))
  //  setSlot(p.first,
  //          function () {
  //            call.args.insertFront(p.second) |
  //            call.message = "assert_op" |
  //            callMessage(call)
  //          });

  function assert_eq
  {
    call.args.insertFront("==") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_ge
  {
    call.args.insertFront(">=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_gt
  {
    call.args.insertFront(">") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_le
  {
    call.args.insertFront("<=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_lt
  {
    call.args.insertFront("<") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_meq
  {
    call.args.insertFront("===") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_mne
  {
    call.args.insertFront("!==") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_ne
  {
    call.args.insertFront("!=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  systemFiles->updateHook = function(slot, value)
  {
    setSystemFiles(value) |
    void
  };
  var loadFile_ = getSlot("loadFile");
  var defaultIsSystem = true;
  loadFile = function(file, isSystem = defaultIsSystem)
  {
    var res = loadFile_(file).acceptVoid |
    if (isSystem)
    {
      addSystemFile(file.asString)
    } |
    res.unacceptVoid
  };
  addSystemFile("urbi/urbi.u");
  addSystemFile(searchFile("urbi/urbi.u").asString);
  addSystemFile(searchFile("urbi/system.u").asString);

  [
    "ast/factory.cc",
    "ast/parametric-ast.cc",
    "ast/parametric-ast.hh",
    "ast/parametric-ast.hxx",
    "binder/binder.cc",
    "flower/flower.cc",
    "object/code.cc",
    "parser/ugrammar.y",
    "rewrite/desugarer.cc",
    "rewrite/pattern-binder.cc",
    "rewrite/rescoper.cc"
  ].each(getSlot("addSystemFile"));

  /// Look for file and load it.
  // Throw on errors.
  function load(file)
  {
    loadFile(searchFile(file));
  };

  // Look for file, and load verbosely on channel it if found.
  function maybeLoad(file, channelName = "")
  {
    var path = nil;
    try
    {
      path = searchFile(file);
    }
    catch (var e if e.isA(Exception.FileNotFound))
    {
    }|;
    if (!path.isNil)
    {
      if (channelName)
        echo("Loading %s" % [path], channelName);
      loadFile(path);
    };
  };

  function ps()
  {
    nonInterruptible |
    for| (var t : jobs)
      t.dumpState
  };

};
