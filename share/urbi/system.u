/*
 * Copyright (C) 2010, Gostai S.A.S.
 *
 * This software is provided "as is" without warranty of any kind,
 * either expressed or implied, including but not limited to the
 * implied warranties of fitness for a particular purpose.
 *
 * See the LICENSE file for more information.
 */

do (System)
{
  const var version = "2.0";

  // Assertion control.
  var ndebug = false;

  function assert_(assertion, message)
  {
    if (!assertion)
      throw Exception.new("failed assertion: " + message);
  };

  /// assert(assertion).
  function 'assert'
  {
    if (call.args.size != 1)
      throw Exception.Arity.new(call.message, call.args.size, 1) |
    if (!ndebug)
      assert_(call.evalArgAt(0), call.argString(0));
  };

  // To be executed when we have dictionnaries.
  function '$registerOps'()
  {
    if (this.hasSlot("$opNeg"))
      return |
    var this.'$fun_rename' =
      [
        "has"  => ("in", [(0, 1)]),
      ] |
    var this.'$opNeg' =
      [
        "=="  => "!=",
        "===" => "!==",
        "<"   => ">=",
        "<="  => ">",
        "in"  => "not in",
      ] |
    // add the opposite.
    for|(var p: this.'$opNeg')
      this.'$opNeg'[p[1]] = p[0];
  };

  /// assert_call(Message: String | Lazy, Lhs, Rhs).
  function assert_call
  {
    if (call.args.size < 2)
      throw Exception.Arity.new(call.message, call.args.size, 2) |
    if (!ndebug)
    {
      '$registerOps' |

      // Support lazy invocations (all arguments are lazy),
      // or a partially lazy one, to ease bouncing from assert_eq.
      var message =
        {
          if (call.args[0].type == "String")
            call.args[0]
          else
            call.argAt(0)
        }|

      // Skip the function name.
      var args = call.args.tail |

      // Evaluate all arguments, and pretty print them.
      var argStr = args.map(closure (v) { v.asString }) |
      var argVal = args.map(closure (v) { v.eval }) |
      var argPrint = argVal.map(closure (v) { v.asPrintable }) |

      // handle cases where an operator is just a sugar over a function
      // name, and reorder the argument in consequences.
      var op = message |
      if (message in '$fun_rename')
      {
        var renamed = '$fun_rename'[message] |
        op = renamed[0] |
        var tmp |
        for|(var sw: renamed[1])
        {
          tmp = argStr[sw[0]] |
          argStr[sw[0]] = argStr[sw[1]] |
          argStr[sw[1]] = tmp |
          tmp = argPrint[sw[0]] |
          argPrint[sw[0]] = argPrint[sw[1]] |
          argPrint[sw[1]] = tmp |
        }
      } |

      var msg |
      var simpleMsg |
      var pp_op = op |
      if (args.size == 2 && op in '$opNeg')
      {
        // Output messages for operators
        msg = "%s %s %s" |
        simpleMsg = "%s %s %s" |
        pp_op = '$opNeg'[op]
      }
      else
      {
        // Different ouput message in function of the number of arguments.
        if (args.size == 1)
          msg = "%s.%s()"
        else if (args.size == 2)
          msg = "%s.%s(%s)"
        else
          msg = "%s.%s(%s" + ", %s" * (args.size - 2) + ")" |

        simpleMsg = "! " + msg |
      }|

      var msgArgs = [argStr.head, op] + argStr.tail |
      var simpleMsgArgs = [argPrint.head, pp_op] + argPrint.tail |

      // Check if the simplified message is identical to the complex message
      // to avoid identical messages.
      var simple = true;
      for|(var i: msgArgs.size)
        if (msgArgs[i] != simpleMsgArgs[i])
        {
          simple = false |
          break
        }|

      // Add the simplified message.
      if (!simple)
      {
        msg += " (" + simpleMsg + ")" |
        msgArgs += simpleMsgArgs |
      }|

      // Do the assertion with it's message.
      msg = msg % msgArgs |
      assert_(argVal.head.getSlot(message).apply(argVal), msg)|
    }
  };


  /// assert_op(Operator: String | Lazy, Lhs, Rhs).
  var assert_op = getSlot("assert_call");


  /// assert_eq(Lhs, Rhs) and so forth.
  // Cannot do this, as we don't have Dictionary.each yet.
  //for (var p :
  //      [
  //        "assert_eq" => "==",
  //        "assert_ge" => ">=",
  //        "assert_gt" => ">",
  //        "assert_le" => "<=",
  //        "assert_lt" => "<",
  //        "assert_ne" => "!=",
  //      ])
  //  setSlot(p.first,
  //          function () {
  //            call.args.insertFront(p.second) |
  //            call.message = "assert_op" |
  //            callMessage(call)
  //          });

  function assert_eq
  {
    call.args.insertFront("==") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_ge
  {
    call.args.insertFront(">=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_gt
  {
    call.args.insertFront(">") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_le
  {
    call.args.insertFront("<=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_lt
  {
    call.args.insertFront("<") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_meq
  {
    call.args.insertFront("===") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_mne
  {
    call.args.insertFront("!==") |
    call.message = "assert_op" |
    callMessage(call)
  };

  function assert_ne
  {
    call.args.insertFront("!=") |
    call.message = "assert_op" |
    callMessage(call)
  };

  var period = 20ms;

  // systemFiles.
  systemFiles->updateHook = function(slot, value)
  {
    setSystemFiles(value) |
    void
  };
  var loadFile_ = getSlot("loadFile");
  var defaultIsSystem = true;
  loadFile = function(file, isSystem = defaultIsSystem)
  {
    var res = loadFile_(file).acceptVoid |
    if (isSystem)
    {
      addSystemFile(file.asString)
    } |
    res.unacceptVoid
  };
  addSystemFile("urbi/urbi.u");
  addSystemFile(searchFile("urbi/urbi.u").asString);
  addSystemFile(searchFile("urbi/system.u").asString);

  [
    "ast/factory.cc",
    "ast/parametric-ast.cc",
    "ast/parametric-ast.hh",
    "ast/parametric-ast.hxx",
    "binder/binder.cc",
    "flower/flower.cc",
    "object/code.cc",
    "parser/ugrammar.y",
    "rewrite/desugarer.cc",
    "rewrite/pattern-binder.cc",
    "rewrite/rescoper.cc"
  ].each(getSlot("addSystemFile"));

  /// Look for file and load it.
  // Throw on errors.
  function load(file)
  {
    loadFile(searchFile(file));
  };

  // Look for file, and load it if found.
  function maybeLoad(var file, var channel = Global.clog)
  {
    var path = nil |
    try
    {
      path = searchFile(file)
    }
    catch (var e if e.isA(Exception.FileNotFound))
    {
    }|
    if (!path.isNil)
    {
      channel.echo("loading %s." % path) |
      loadFile(path)
    }
  };

  function ps()
  {
    nonInterruptible |
    for| (var t : jobs)
      t.dumpState
  };

};
