// Completion of events code

class Global.Event
{
  function init()
  {
    var this.on_pubsub = PubSub.new |
    var this.wu_pubsub = PubSub.new |
    var this.alive = [] |
    var this.listeners = [] |
  };

  function 'emit'
  {
    var res = clone |
    var res.payload = call.evalArgs |
    var res.active = false |
    on_pubsub.publish(res) |
    wu_pubsub.publish(res) |
    void
  };

  function syncEmit
  {
    var res = clone |
    var res.payload = call.evalArgs |
    var res.active = false |
    // Publish event on the waituntil channel, to unfreeze other
    // waiting jobs
    wu_pubsub.publish(res) |
    // Then call synchronously 'at' subscribers
    for& (var code : listeners)
      code(res) |
    void
  };

  function trigger
  {
    var res = clone |
    var res.payload = call.evalArgs |
    var res.active = true |
    alive.push_back(res) |
    on_pubsub.publish(res) |
    wu_pubsub.publish(res) |
    res
  };

  function 'stop'()
  {
    alive.removeById(this) |
    active = false |
    this
  };

  function onEvent(code)
  {
    listeners << code |
    var id = on_pubsub.subscribe |
    // We cannot replace these for loops of detached code with a for&,
    // since it would delay subsequent onEvent execution if code
    // doesn't return immediately.
    for (var evt : alive)
      detach(code(evt)) |
    while| (true)
      for (var evt : on_pubsub.getAll(id))
        detach(code(evt)) |
  };

  function 'waituntil'(pattern)
  {
    var id = wu_pubsub.subscribe |
    for| (var e: alive)
      if (pattern.match(e.payload))
      {
        wu_pubsub.unsubscribe(id) |
        return
      } |
    while| (true)
      for| (var e: wu_pubsub.getAll(id))
        if (pattern.match(e.payload))
        {
          wu_pubsub.unsubscribe(id) |
          return
        }
  };
};
