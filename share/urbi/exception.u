class Global.Exception
{
  var message = "<no message>";
  var backtrace;
  var location = "";

  function init(msg)
  {
    message = msg
  };

  /// Make the instanciation of subobjects easier.
  function '$Exception'(msg)
  {
    Exception.getSlot("init").apply([this, msg])
  };

  function asString()
  {
    var res = message |
    if (!location.empty)
      res = "%s: %s" % [location, res] |
    return res
  };

  function asPrintable()
  {
    "%s `%s'" % [type, message]
  };
};

class Global.ConstError: Exception
{
  function init()
  {
    '$Exception'("cannot modify const slot")
  }
};

class Global.ImplicitTagComponentError: Exception
{
  function init()
  {
    '$Exception'("invalid component in implicit tag")
  }
};

class Global.SchedulingError: Exception
{
  function throwNew(msg)
  {
    throw SchedulingError.new(msg)
  }
};

class Global.UnexpectedVoidError: Exception
{
  function init()
  {
    '$Exception'("unexpected void")
  }
};

class Global.PrimitiveError: Exception
{
  var routine;

  function init(routine, msg)
  {
    this.routine = routine |
    '$Exception'("%s: %s" % [routine, msg])
  };
};

class Global.ArityError: Exception
{
  var routine;
  var effective;

  function init(routine, effective, min, max = void)
  {
    this.routine = routine |
    this.effective = effective |

    if (max.isVoid)
      '$Exception'("%s: Expected %s argument%s, given %s"
                   % [routine, min, {if (1 < min) "s" else ""}, effective])
    else
      '$Exception'("%s: Expected between %s and %s argument%s, given %s"
                   % [routine, min, max, {if (1 < max) "s" else ""}, effective])
  }
};

class Global.BadIntegerError: Exception
{
  var routine;
  var effective;

  function init(routine, fmt, effective)
  {
    this.routine = routine |
    this.effective = effective |
    '$Exception'("%s: %s" % [routine, fmt % effective])
  };
};

class Global.TypeError: Exception
{
  var expected;
  var effective;

  function init(expected, effective)
  {
    this.expected = expected |
    this.effective = effective |
    message = "unexpected %s, expected a %s"
              % [effective.asPrintable, expected.type]
  }
};

class Global.ArgumentTypeError: TypeError
{
  var index;
  var routine;

  function init(routine, index, exp, eff)
  {
    TypeError.getSlot("init").apply([this, exp, eff]) |
    this.routine = routine |
    this.index = index |
    message = "%s: unexpected %s for argument %s, expected a %s" %
              [routine, eff.asPrintable, index, exp.type]
  }
};

class Global.LookupError: Exception
{
  var msg;
  var obj;

  var fixSpellingErrors = true;

  function init(m, o)
  {
    msg = m |
    obj = o |
    var explanation = "lookup failed: %s" % m |
    var closest = nil |
    if (fixSpellingErrors)
      closest = mispelling(m, o) |
    if (closest)
      explanation += " (possible mispelling of %s)" % closest |
    '$Exception'(explanation)
  };

  // Return the most probable slot in "o" (recursively) ressembling "m"
  // or "nil" if we have no satisfying answer.
  function mispelling(m, o)
  {
    // One character is too short.
    if (m.size == 1)
      return nil |

    var lcm = m.toLower |
    var allNames = o.allSlotNames |
    var min = 999 |
    var closest = nil |
    for| (var n: allNames) {
      var d = lcm.distance(n.toLower) |
      if (d < min) {
        min = d |
        closest = n |
	if (min == 0)      // Case mismatch only, that must be it.
          return closest
      }
    } |
    // Do not overcorrect. Two errors, not including case mismatches,
    // ought to be enough for everybody. Also, do not try to correct
    // words with less than three letters unless we got a case
    // mismatch (caught above) or only one case-sensitive change.
    if (2 < min
        || (m.size < 3 && closest.size < 3 && 1 < m.distance(closest)))
      return nil |
    closest
  }
};

class Global.RedefinitionError: Exception
{
  var slot;

  function init(s)
  {
    slot = s |
    '$Exception'("slot redefinition: %s" % s)
  }
};

class Global.FileNotFound: Exception
{
  var path;

  function init(p)
  {
    path = p|
    '$Exception'("file not found: %s" % p)
  }
};

class Global.MatchFailure: Exception
{
  function init()
  {
    '$Exception'("pattern did not match");
  }
};
