/*
 * Copyright (C) 2010, Gostai S.A.S.
 *
 * This software is provided "as is" without warranty of any kind,
 * either expressed or implied, including but not limited to the
 * implied warranties of fitness for a particular purpose.
 *
 * See the LICENSE file for more information.
 */

class Global.Exception
{
  var message = "<no message>";

  // location and backtrace are defined by the raise function of the
  // interpreter.  They point to where the Exception was thrown, not
  // created.
  var backtrace;
  var location;
  var slot;
  var routine;

  function init(msg)
  {
    message = msg
  };

  /// Make the instanciation of subobjects easier.
  function '$Exception'(msg)
  {
    Exception.getSlot("init").apply([this, msg])
  };

  // <loc>: <slot or routine>: <message>
  function asString()
  {
    var res = message |
    if (!slot.isVoid)
      res = "%s: %s" % [slot, res]
    else if (!routine.isVoid)
      res = "%s: %s" % [routine, res] |
    if (!location.isVoid)
      res = "%s: %s" % [location, res] |
    res
  };

  function asPrintable()
  {
    "%s%s `%s'" %
      [{if (type == "Exception") "" else "Exception."},
       type, asString]
  };
};


// These functions should not be visible outside of this file.  The
// exception indentation is not done to minize differences.
{
  function makeFmtException(name, inherit, locSlots, fmt, fmtSlots)
  {
    var locSize = locSlots.size;
    var fmtSize = fmtSlots.size;

    class Res : inherit
    {
      type = name;
      var fmt = fmt;

      function init
      {
        if (call.argsCount != locSize + fmtSize)
          throw Exception.Arity.new("%s.%s" % [name, "init"],
                                    call.argsCount,
                                    size) |
        var values = call.evalArgs |
        for (var i: locSize)
          this.updateSlot(locSlots[i], values[i]) |
        for (var i: fmtSize)
          this.setSlot(fmtSlots[i], values[i + locSize])
      };

      function message()
      {
        var l = [];
        for (var i: fmtSize)
          l << this.getSlot(fmtSlots[i]) |
        fmt % l
      };
    };

    Exception.setSlot(name, Res);
  };

  function makeMsgException(name, inherit, locSlots, msg)
  {
    makeFmtException(name, inherit, locSlots, "", []);
    Exception.getSlot(name).removeSlot("fmt");
    Exception.getSlot(name).message = msg;
  };

  function makeException(name, inherit, locSlots)
  {
    makeMsgException(name, inherit, locSlots, Exception.message);
  };

class Exception.Arity: Exception
{
  var effective;
  var min;
  var max;

  function init(routine, effective, min, max = void)
  {
    this.routine = routine |
    this.effective = effective |
    this.min = min |
    if (!max.isVoid)
      this.max = max |
  };

  function message()
  {
     if (max.isVoid)
      "expected %s argument%s, given %s"
      % [min, {if (1 < min) "s" else ""}, effective]
    else
      "expected between %s and %s argument%s, given %s"
      % [min, max, {if (1 < max) "s" else ""}, effective]
  };
};

class Exception.BadNumber: Exception
{
  function init(routine, fmt, effective)
  {
    this.routine = routine;
    var this.fmt = fmt;
    var this.effective = effective;
  };

  function message()
  {
    fmt % effective
  };
};

class Exception.BadInteger: Exception.BadNumber
{
};

makeFmtException(
  "NegativeNumber", Exception.BadNumber, ["routine"],
  "expected non-negative number, got %s", ["effective"]
);

makeFmtException(
  "NonPositiveNumber", Exception.BadNumber, ["routine"],
  "expected positive number, got %s", ["effective"]
);

makeMsgException(
  "Constness", Exception.BadNumber, [],
  "cannot modify const slot"
);

makeFmtException(
  "FileNotFound", Exception, [],
  "file not found: %s", ["path"]
);

makeMsgException(
  "ImplicitTagComponent", Exception, [],
  "invalid component in implicit tag"
);

makeMsgException(
  "MatchFailure", Exception, [],
  "pattern did not match"
);

makeException(
  "Primitive", Exception, ["routine", "message"]
);

// Should move the slot in the location instead of adding it at the end of
// the message.
makeFmtException(
  "Redefinition", Exception, [],
  "slot redefinition: %s", ["slot_name"]
);

class Exception.Scheduling: Exception
{
  function throwNew(msg)
  {
    throw Exception.Scheduling.new(msg)
  };
};

class Exception.Syntax: Exception
{
  var error = "syntax error";
  var loc = "<no location>";
  var input = "<no input>";

  function init(var loc, var message, var input)
  {
    this.loc = loc |
    this.input = input |
    '$Exception'(message)
  };

  function asString()
  {
    if (location.isVoid)
      "syntax error: %s: %s" % [loc, message]
      // Don't display the syntax error location if it is the same as
      // the location from which the exception was thrown.  This
      // happens for "direct" syntax errors: at the top level, as
      // opposed to "load"ing and "eval"ing syntax errors.

      // FIXME: Use Location.'=='.
    else if (location.asString == loc.asString)
      "%s: syntax error: %s" % [location, message]
    else
      "%s: syntax error: %s: %s" % [location, loc, message]
  };

};

/*----------------------.
| Type and subobjects.  |
`----------------------*/

class Exception.Type: Exception
{
  var expectedType;
  var effective;

  function init(effective, expected)
  {
    this.expectedType = expected.type |
    this.effective = effective
  };

  function message()
  {
    "unexpected %s, expected a %s"
      % [effective.asPrintable, expectedType]
  };
};

class Exception.ArgumentType: Exception.Type
{
  var index;
  var routine;

  function init(routine, index, effective, expected)
  {
    Exception.Type.getSlot("init").apply([this, effective, expected]) |
    this.routine = routine |
    this.index = index
  };

  function message()
  {
    "unexpected %s for argument %s, expected a %s"
      % [effective.asPrintable, index, expectedType]
  };
};

/*---------.
| Lookup.  |
`---------*/

class Exception.Lookup: Exception
{
  var msg;
  var obj;
  var suggested = nil;

  var fixSpelling = true;

  function init(m, o)
  {
    msg = m |
    obj = o |
    if (fixSpelling)
      suggested = misspelling(m, o)
  };

  function message()
  {
    var res = "lookup failed: %s" % msg;
    if (suggested)
      res += " (possible misspelling of %s)" % suggested |
    res
  };

  // Return the most probable slot in "o" (recursively) ressembling "m"
  // or "nil" if we have no satisfying answer.
  function misspelling(var m, var o)
  {
    // One character is too short.
    if (m.size == 1)
      return nil |

    var lcm = m.toLower |
    var allNames = o.allSlotNames |
    var min = 999 |
    var closest = nil |
    for| (var n: allNames)
    {
      var d = lcm.distance(n.toLower) |
      if (d < min)
      {
        min = d |
        closest = n |
	if (min == 0)      // Case mismatch only, that must be it.
          return closest
      }
    } |
    // Do not overcorrect. Two errors, not including case mismatches,
    // ought to be enough for everybody. Also, do not try to correct
    // words with less than three letters unless we got a case
    // mismatch (caught above) or only one case-sensitive change.
    if (2 < min
        || (m.size < 3 && closest.size < 3 && 1 < m.distance(closest)))
      return nil |
    closest
  }
};

makeMsgException(
  "UnexpectedVoid", Exception, [],
  "unexpected void"
);


// Close the scope of make*Exception functions.
};
