/*! \file urbi/ucallbacks.hh
 *******************************************************************************

 Definition of the callback classes.

 This file is part of UObject Component Architecture\n
 Copyright (c) 2006, 2007, 2008, 2009 Gostai S.A.S.

 Permission to use, copy, modify, and redistribute this software for
 non-commercial use is hereby granted.

 This software is provided "as is" without warranty of any kind,
 either expressed or implied, including but not limited to the
 implied warranties of fitness for a particular purpose.

 For more information, comments, bug reports: http://www.urbiforge.com

 **************************************************************************** */

#ifndef URBI_UCALLBACKS_HH
# define URBI_UCALLBACKS_HH

# include <string>

# include <libport/meta.hh>
# include <urbi/export.hh>
# include <urbi/fwd.hh>
# include <urbi/utable.hh>
# include <urbi/uvalue.hh>
# include <urbi/ucontext.hh>

namespace urbi
{

  namespace impl
  {
    class URBI_SDK_API UGenericCallbackImpl
    {
    public:
      virtual ~UGenericCallbackImpl() = 0;
      virtual void initialize(UGenericCallback* owner, bool owned) = 0;
      virtual void initialize(UGenericCallback* owner) = 0;
      virtual void registerCallback() = 0;
      virtual void clear() = 0;
    };
  };

  //! Function and Event storage mechanism
  /// This heavily overloaded class is the only way in C++ to make
  /// life easy from the the interface user point's of view.  */

  class URBI_SDK_API UGenericCallback: public UContext
  {
  public:
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name,
		     int size, bool owned,
                     impl::UContextImpl* ctx);
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name,
                     impl::UContextImpl* ctx);
    virtual ~UGenericCallback();

    void registerCallback();

    const std::string& getName() const
    {
      return name;
    }

    virtual UValue __evalcall(UList& param)  = 0;

    /// Used to store the UVar* pointeur for var monitoring.
    void* storage;
    /// Period of timers.
    ufloat period;

    /// Nb params of the callbacked function.
    int nbparam;

    /// Name of the UObject that created the callback.
    std::string objname;
    std::string type;

    std::string name;
    impl::UGenericCallbackImpl* impl_;

  protected:
    template<typename T>
    static inline impl::UContextImpl* fetchContext(T* ptr, libport::meta::True)
    {
    return ptr->ctx_;
    }

    template<typename T>
    static inline impl::UContextImpl* fetchContext(T*, libport::meta::False)
    {
    return getCurrentContext();
    }
  };


  /*------------------------------------------------.
  | This section is generated. Not for human eyes.  |
  `------------------------------------------------*/

%%%% 0 16

  // non void return type

  template <class OBJ, class R%%, class P% %%>
  class UCallback%N% : public UGenericCallback
  {
  public:

# define MKUCallBackNotifyCtr%N%(Const, IsConst)			\
      UCallback%N%(const std::string& objname, const std::string& type,	\
		   OBJ* obj,						\
		   R (OBJ::*fun) (%%%,% P% %%) Const,			\
		   const std::string& funname, bool owned)	        \
      : UGenericCallback(objname, type, funname, %N%, owned,            \
      fetchContext(obj,                                                 \
      typename libport::meta::If<libport::meta::Inherits<OBJ,           \
        UContext>::res>::res())),                                         \
	obj(obj), fun##Const(fun), is_const_ (IsConst)			\
    {									\
      nbparam = %N%;                                                    \
      registerCallback();						\
    }

    MKUCallBackNotifyCtr%N% (/**/, false);
    MKUCallBackNotifyCtr%N% (const, true);

# undef MKUCallBackNotifyCtr%N%

    virtual UValue __evalcall(UList& param)
    {
      // Avoid warnings when we don't use param.
      (void) param;
      UValue res;
      res(),
	(is_const_)
	? ((*obj).*funconst)(%%%,% uvalue_cast<P%>(param[% - 1]) %%)
	: ((*obj).*fun)     (%%%,% uvalue_cast<P%>(param[% - 1]) %%);
      return res;
    }

  private:
    OBJ* obj;
    R (OBJ::*fun)      (%%%,% P% %%);
    R (OBJ::*funconst) (%%%,% P% %%) const;
    bool is_const_;
  };

#if 0
  // void return type
  template <class OBJ%%, class P% %%>
  class UCallbackvoid%N% : public UGenericCallback
  {
  public:
    UCallbackvoid%N%(const std::string& objname, const std::string& type,
		     OBJ* obj,
		     void (OBJ::*fun) (%%%,% P% %%),
		   const std::string& funname, bool owned)
      : UGenericCallback(objname, type, funname,%N%, owned),
	obj(obj), fun(fun)
    {
      registerCallback();
    }

    virtual UValue __evalcall(UList &param)
    {
      // Avoid warnings when we don't use param.
      (void) param;
      ((*obj).*fun)(%%%,% uvalue_cast<P%>(param[% - 1]) %%);
      return UValue();
    }
  private:
    OBJ* obj;
    void (OBJ::*fun) (%%%,% P% %%);
  };
#endif


  // void return type : special case for notifyend event callbacks
  template <class OBJ%%, class P% %%>
  class UCallbacknotifyend%N% : public UGenericCallback
  {
  public:

# define MKUCallBackNotifyEndCtr%N%(FConst, EConst, IsConst)		\
      UCallbacknotifyend%N%(const std::string& objname,			\
			    const std::string& type,			\
			    OBJ* obj,					\
			    void (OBJ::*fun) (%%%,% P% %%) FConst,	\
			    void (OBJ::*end)() EConst,			\
			    const std::string& funname)	                \
      : UGenericCallback(objname, type, funname,%N%, false,             \
      fetchContext(obj,                                                 \
        typename libport::meta::If<libport::meta::Inherits<OBJ,         \
          UContext>::res>::res())),                                       \
	obj(obj), fun(end), is_const_(IsConst)				\
    {									\
      nbparam = %N%;                                                    \
      registerCallback();						\
    }

    MKUCallBackNotifyEndCtr%N% (/**/, /**/, false);
    MKUCallBackNotifyEndCtr%N% (/**/, const, true);
    MKUCallBackNotifyEndCtr%N% (const ,/**/, false);
    MKUCallBackNotifyEndCtr%N% (const, const, true);

# undef MKUCallBackNotifyEndCtr%N%

    virtual UValue __evalcall(UList &)
    {
      UValue res;
      res(), (is_const_) ? ((*obj).*func)() : ((*obj).*fun)();
      return res;
    }

  private:
    OBJ* obj;
    void (OBJ::*fun) ();
    void (OBJ::*func) ();
    bool is_const_;
  };

#if 0
  // void non-member function
  template <class INU %%, class P% %%>
  class UFCallbackvoid%N% : public UGenericCallback
  {
  public:
    UFCallbackvoid%N%(const std::string& objname, const std::string& type,
		      void (*fun) (%%%,% P% %%),
		    const std::string& funname, UTable &t, bool owned)
      : UGenericCallback(objname, type, funname,%N%, t, owned),  fun(fun)
    {
      registerCallback();
    }

    virtual UValue __evalcall(UList &param)
    {
      // Avoid warnings when we don't use param.
      (void) param;
      (*fun)(%%%,% uvalue_cast<P%>(param[% - 1]) %%);
      return UValue();
    }

  private:
    void (*fun) (%%%,% P% %%);
  };

#endif

  // non void non-member function
  template <class R%%, class P% %%>
  class UFCallback%N% : public UGenericCallback
  {
    public:
    UFCallback%N%(const std::string& objname, const std::string& type,
		  R (*fun) (%%%,% P% %%),
		const std::string& funname, bool owned,
                impl::UContextImpl* ctx)
      : UGenericCallback(objname, type, funname,%N%, owned, ctx),  fun(fun)
    {
      nbparam = %N%;
      registerCallback();
    }

    virtual UValue __evalcall(UList& param)
    {
      // Avoid warnings when we don't use param.
      (void) param;
      UValue res;
      res(), (*fun)(%%%,% uvalue_cast<P%>(param[% - 1]) %%);
      return res;
    }

    private:
    R (*fun) (%%%,% P% %%);
  };

  // callback creation for non-member non void return type

  template <class R%%, class P% %%>
  UGenericCallback*
  createUCallback(const std::string& objname, const std::string& type,
		  R (*fun) (%%%,% P% %%),
		  const std::string& funname, bool owned,
                  impl::UContextImpl* ctx)
  {
    return new UFCallback%N%<R%%, P% %%> (objname, type,fun,funname, owned,
    ctx);
  }

#if 0
  // callback creation for non-member void return type
  // inline required since one of them is not a template
  template <%%%,% class P% %%> inline
    UGenericCallback*
    createUCallback(const std::string& objname, const std::string& type,
		    void (*fun) (%%%,% P% %%),
		    const std::string& funname, UTable &t, bool owned)
  {
    return new UFCallbackvoid%N%<void %%, P% %%> (objname, type,fun,funname,t,
						  owned);
  }
#endif

  // callback creation for non void return type

  // Second argument is useless, it exist only for visual c++ compiler
  // which warn at compilation for a call of MKUCreateCallBack()
# define MKUCreateCallBack%N%(Const, Useless)					\
  template <class OBJ, class R%%, class P% %%>				\
  UGenericCallback*							\
  createUCallback(const std::string& objname, const std::string& type,	\
		  OBJ* obj,						\
		  R (OBJ::*fun) (%%%,% P% %%) Const,			\
		  const std::string& funname,  bool owned)	        \
  {									\
    return new UCallback%N%<OBJ,R%%, P% %%> (objname, type, obj, fun,	\
					     funname,			\
					     owned);			\
  }

  MKUCreateCallBack%N% (/**/, /**/);
  MKUCreateCallBack%N% (const, /**/);

# undef MKUCreateCallBack%N%

#if 0
  // callback creation for void return type

  template <class OBJ%%, class P% %%>
  UGenericCallback*
  createUCallback(const std::string& objname, const std::string& type,
		  OBJ* obj,
		  void (OBJ::*fun) (%%%,% P% %%),
		  const std::string& funname, UTable &t, bool owned)
  {
    return new UCallbackvoid%N%<OBJ%%, P% %%> (objname, type,obj,fun,funname,t,
					       owned);
  }
#endif

  // Special case for eventend notification
# define MKCreateUCallBackEnd%N%(FConst, EConst)			\
  template <class OBJ%%, class P% %%>					\
  UGenericCallback*							\
  createUCallback(const std::string& objname, const std::string& type,	\
		  OBJ* obj,						\
		  void (OBJ::*fun) (%%%,% P% %%) FConst,		\
		  void (OBJ::*end)() EConst,				\
		  const std::string& funname)		\
  {									\
    return new UCallbacknotifyend%N%<OBJ%%, P% %%> (objname,		\
						    type, obj, fun,	\
						    end,funname);	\
  }

  MKCreateUCallBackEnd%N% (/**/, /**/);
  MKCreateUCallBackEnd%N% (/**/, const);
  MKCreateUCallBackEnd%N% (const, /**/);
  MKCreateUCallBackEnd%N% (const, const);

# undef MKCreateUCallBackEnd%N%

  %%%%

} // end namespace urbi

#endif // ! URBI_UCALLBACKS_HH

/// Local Variables:
/// mode: c++
/// End:
