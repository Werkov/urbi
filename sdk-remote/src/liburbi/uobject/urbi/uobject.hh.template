/*! \file uobject.hh
 *******************************************************************************

 File: uobject.hh\n
 Definition of the UObject class and necessary related classes.

 This file is part of UObject Component Architecture\n
 (c) 2006 Gostai S.A.S.

 Permission to use, copy, modify, and redistribute this software for
 non-commercial use is hereby granted.

 This software is provided "as is" without warranty of any kind,
 either expressed or implied, including but not limited to the
 implied warranties of fitness for a particular purpose.

 For more information, comments, bug reports: http://www.urbiforge.com

 **************************************************************************** */

#ifndef URBI_UOBJECT_HH
# define URBI_UOBJECT_HH

# include <string>
# include <list>
# include <algorithm>

# include "libport/singleton-ptr.hh"
# include "libport/ufloat.h"
# include "libport/hash.hh"


/// This macro must be called once for every UObject class.
# define UStart(x) \
  ::urbi::URBIStarter<x> x ##  ____URBI_object(std::string(# x),    \
					       ::urbi::objectlist)

/// This macro must be called once for every UObject class.
# define UStartRename(x,name) \
  ::urbi::URBIStarter<x> x ##  ____URBI_object(std::string(# name), \
					       ::urbi::objectlist)

/// This macro must be called once for each UObjectHub class.
# define UStartHub(x) \
  ::urbi::URBIStarterHub<x> x ##  ____URBI_object(std::string(# x), \
						  ::urbi::objecthublist)


/** Bind a variable to an object.

     This macro can only be called from within a class inheriting from
     UObject.  It binds the UVar x within the object to a variable
     with the same name in the corresponding URBI object.  */
# define UBindVar(obj,x) x.init(__name,# x)

/** This macro defines a UVar as a sensor/effector couple.

     After this call is made, writes by this module affect the sensed
     value, and reads read the target value. Writes by other modules
     and URBI code affect the target value, and reads get the sensed
     value. Without this call, all operations affect the same
     underlying variable.  */
# define USensor(x) x.setOwned()

/** Bind the function x in current URBI object to the C++ member
    function of same name.  The return value and parameters must be of
    a basic integral or floating types, char *, std::string, UValue,
    UBinary, USound or UImage, or any type that can cast to/from
    UValue.  */
# define UBindFunction(obj,x)						\
  ::urbi::createUCallback(__name, "function", this,			\
		  (&obj::x),__name+"."+std::string(# x),                \
		  ::urbi::functionmap)

/** Registers a function x in current object that will be called each
    time the event of same name is triggered. The function will be
    called only if the number of arguments match between the function
    prototype and the URBI event.
 */
# define UBindEvent(obj,x)						\
  ::urbi::createUCallback(__name, "event", this,			\
		  (&obj::x),__name+"."+std::string(# x),                \
		  ::urbi::eventmap)

/** Registers a function x in current object that will be called each
 * time the event of same name is triggered, and a function fun called
 * when the event ends. The function will be called only if the number
 * of arguments match between the function prototype and the URBI
 * event.
 */
# define UBindEventEnd(obj,x,fun)					\
  ::urbi::createUCallback(__name, "eventend", this,			\
		  (&obj::x),(&obj::fun),__name+"."+std::string(# x),    \
		  ::urbi::eventendmap)

/** Register current object to the UObjectHub named 'hub'.
 */
# define URegister(hub)							\
  do {									\
    objecthub = ::urbi::getUObjectHub((std::string) #hub);		\
    if (objecthub)							\
      objecthub->addMember(dynamic_cast<UObject*>(this));		\
    else								\
      echo("Error: hub name '%s' is unknown\n", #hub);			\
  } while (0)

// defines a variable and it's associated accessors
# define PRIVATE(vartype,varname)		\
  private:					\
    vartype varname;				\
  public:					\
    vartype get_ ##  varname ()			\
    {						\
      return varname;				\
    }						\
    void set_ ##  varname (vartype& ____value)	\
    {						\
      varname = ____value;			\
    }						\
  private:


//macro to send urbi commands
# ifndef URBI
/** Send unquoted URBI commands to the server. Add an extra layer of parenthesis
    for safety.
*/
#   define URBI(a) ::urbi::uobject_unarmorAndSend(# a)
# endif


namespace urbi
{

  // Forward declarations and global scope structures
  class UObjectData;
  class UVar;
  class UObject;
  class UObjectHub;
  class baseURBIStarter;
  class baseURBIStarterHub;
  class UGenericCallback;
  class UTimerCallback;
  class UValue;
  class UVardata;

  // A few list and hashtable types
  typedef hash_map_type<std::string, std::list<UGenericCallback*> >::type UTable;
  typedef hash_map_type<std::string, std::list<UVar*> >::type UVarTable;
  typedef std::list<baseURBIStarter*> UStartlist;
  typedef std::list<baseURBIStarterHub*> UStartlistHub;
  typedef std::list<UTimerCallback*> UTimerTable;
  typedef std::list<UObject*> UObjectList;

  typedef int UReturn;

  // Two singleton lists to handle the object and hubobject registration.
  EXTERN_STATIC_INSTANCE(UStartlist, objectlist);
  EXTERN_STATIC_INSTANCE(UStartlistHub, objecthublist);

  // Lists and hashtables used.
  extern UVarTable varmap;
  extern UTable functionmap;
  extern UTable eventmap;
  extern UTable eventendmap;
  extern UTable monitormap;
  extern UTable accessmap;

  // Timer and update maps.
  extern UTimerTable timermap;
  extern UTimerTable updatemap;

  // For remote mode.
  extern void main(int argc, char *argv[]);

  // *****************************************************************************
  // Global function of the urbi:: namespace to access kernel features

  /// Write a message to the server debug output. Printf syntax.
  void echo(const char * format, ... );
  /// Retrieve a UObjectHub based on its name or return 0 if not found.
  UObjectHub* getUObjectHub(const std::string& n);
  /// Retrieve a UObject based on its name or return 0 if not found.
  UObject* getUObject(const std::string& n);

  /// Send URBI code (ghost connection in plugin mode, default
  /// connection in remote mode).
  void uobject_unarmorAndSend(const char * str);
  /// Send the string to the connection hosting the UObject.
  void send(const char* str);
  /// Send buf to the connection hosting the UObject.
  void send(void* buf,int size);

  // *****************************************************************************
  // UValue and other related types

  /// Possible value types a UValue can contain.
  enum UDataType
  {
    DATA_DOUBLE,
    DATA_STRING,
    DATA_BINARY,
    DATA_LIST,
    DATA_OBJECT,
    DATA_VOID
  };

  enum UBinaryType
  {
    BINARY_NONE,
    BINARY_UNKNOWN,
    BINARY_IMAGE,
    BINARY_SOUND
  };

  enum UImageFormat
  {
    IMAGE_RGB=1,     ///< RGB 24 bit/pixel
    IMAGE_YCbCr=2,   ///< YCbCr 24 bit/pixel
    IMAGE_JPEG=3,    ///< JPEG
    IMAGE_PPM=4,     ///< RGB with a PPM header
    IMAGE_UNKNOWN
  };

  enum USoundFormat
  {
    SOUND_RAW,
    SOUND_WAV,
    SOUND_MP3,
    SOUND_OGG,
    SOUND_UNKNOWN
  };

  enum USoundSampleFormat
  {
    SAMPLE_SIGNED=1,
    SAMPLE_UNSIGNED=2
  };

  //WARNING: synchronize with blendNames below, must be 0-based
  /// Possible blending mode for an UVar
  enum UBlendType
  {
    UMIX=0,
    UADD,
    UDISCARD,
    UQUEUE,
    UCANCEL,
    UNORMAL
  };

  // values for enum-like properties
  namespace
    {
      const char * blendNames[]=
      {
	"mix",
	"add",
	"discard",
	"queue",
	"cancel",
	"normal",
	""
      };
      const int blendNum = 6;
    }


  //WARNING: synchronize with propNames in uvar.cc
  /// URBI properties associated to a variable
  enum UProperty
  {
    PROP_RANGEMIN=0,
    PROP_RANGEMAX,
    PROP_SPEEDMIN,
    PROP_SPEEDMAX,
    PROP_BLEND,
    PROP_DELTA
  };

  //internal use: unparsed binary data
  class BinaryData
  {
  public:
  BinaryData()
    : data (0), size (0)
      {}
    BinaryData(void *d, int s)
      : data(d), size(s)
    {}
    void* data;
    int size;
  };


  /** Class encapsulating an image.

      This class does not handle its memory: the data field msut be
      freed manualy.  */
  class UImage
  {
  public:
    unsigned char         *data;            ///< pointer to image data
    int                   size;             ///< image size in byte
    int                   width, height;    ///< size of the image
    UImageFormat          imageFormat;
  };

  /** Class encapsulating sound informations.

      This class does not handle its memory: the data field msut be
      freed manualy.  */
  class USound
  {
  public:
    char                  *data;            ///< pointer to sound data
    int                   size;             ///< total size in byte
    int                   channels;         ///< number of audio channels
    int                   rate;             ///< rate in Hertz
    int                   sampleSize;       ///< sample size in bit
    USoundFormat          soundFormat;      ///< format of the sound data
    USoundSampleFormat    sampleFormat;     ///< sample format

    bool operator ==(const USound &b) const
    {
      return !memcmp(this, &b, sizeof(USound));
    }
  };

  /** Class containing binary data of known or unknown type.
      Handles its memory: the data field will be freed when the destructor is called.
  */
  class UBinary
  {
  public:
    UBinaryType             type;
    union
    {
      struct
      {
	void                  *data;             ///< binary data
	int                   size;
      } common;
      UImage                image;
      USound                sound;
    };
    /// Extra bin headers(everything after BIN <size> and before ';'.
    std::string                message;

    UBinary();
    /// Deep copy constructor.
    UBinary(const UBinary &b);
    explicit UBinary(const UImage &);
    explicit UBinary(const USound &);
    /// Deep copy.
    UBinary & operator = (const UBinary &b);
    /// Build message from structures.
    void buildMessage();
    /// Get message extracted from structures.
    std::string getMessage() const;
    /// Frees binary buffer.
    ~UBinary();
    int parse(const char* message, int pos,
	      std::list<BinaryData> &bins,
	      std::list<BinaryData>::iterator &binpos);
  };

  /// Class storing URBI List type
  class UList
  {
  public:
    std::vector<UValue *> array;
    UList();
    UList(const UList &b);
    UList & operator = (const UList &b);
    ~UList();
    UValue & operator [](int i) {return *array[i+offset];}
    const UValue & operator [](int i) const {return *array[i+offset];}
    int size() const {return array.size();}
    void setOffset(int n) { offset = n;};

  private:
    int offset;
  };

  class UNamedValue
  {
  public:
    UNamedValue(const std::string& n, UValue *v)
      : val(v),name(n)
    {}
    UNamedValue()
      : val(0),name(0)
    {}
    UValue *val;
    std::string name;
  };

  class UObjectStruct
  {
  public:
    std::string refName;
    std::vector<UNamedValue> array;
    UObjectStruct();
    UObjectStruct(const UObjectStruct &b);
    UObjectStruct & operator = (const UObjectStruct &b);
    ~UObjectStruct();
    UValue & operator [](const std::string& s);
    UNamedValue & operator [](int i) {return array[i];}
    int size() {return array.size();}
  };

  /** Container for a value that handles all types known to URBI.
   */
  class UValue
  {
  public:
    UDataType       type;
    ufloat          val;  ///< value if of type DATA_DOUBLE
    union
    {
      std::string    *stringValue; ///< value if of type DATA_STRING
      UBinary        *binary;  ///< value if of type DATA_BINARY
      UList          *list;  ///< value if of type DATA_LIST
      UObjectStruct  *object;  ///< value if of type DATA_OBJ
      void           *storage; // internal
    };

    UValue();
    UValue(const UValue&);
    explicit UValue(ufloat doubleValue);
    explicit UValue(int intValue);
    explicit UValue(long intValue);
    explicit UValue(unsigned int intValue);
    explicit UValue(unsigned long intValue);
    explicit UValue(char * val);
    explicit UValue(void * val);
    explicit UValue(const std::string& str);
    explicit UValue(const UBinary& b);
    explicit UValue(const UList & l);
    explicit UValue(const UObjectStruct &o);
    explicit UValue(const USound &);
    explicit UValue(const UImage &);
    operator ufloat() const;
    operator std::string() const;
    operator int() const {return (int)(ufloat)(*this);}
    operator unsigned int() const {return (unsigned int)(ufloat)(*this);}
    operator long() const {return (int)(ufloat)(*this);}
    operator unsigned long() const {return (unsigned int)(ufloat)(*this);}
    operator bool() const {return (bool)(int)(ufloat)(*this);}
    operator UBinary() const; ///< deep copy
    operator UList() const; ///< deep copy
    operator UImage() const; ///< ptr copy
    operator USound() const; ///< ptr copy
    UValue& operator=(const UValue&);

    ~UValue();

    //parse an uvalue in current message+pos, returns pos of end of match -pos of error if error
    int parse(const char* message,
	      int pos,
	      std::list<BinaryData> &bins,
	      std::list<BinaryData>::iterator &binpos);

    /// Print itself on \c s, and return it.
    std::ostream& print (std::ostream& s) const;
  };

  inline
  std::ostream&
  operator<<(std::ostream &s, const UValue &v)
  {
    return v.print (s);
  }

  //! Provides easy access to variable properties
  class UProp
  {
  public:

    void operator =(const UValue &v ) ;
    void operator =(const double v ) ;
    void operator =(const std::string & v ) ;

    operator double() ;
    operator std::string() ;
    operator UValue() ;

    UProp(UVar &owner, UProperty name):owner(owner),name(name){}

  private:

    UVar & owner;
    UProperty name;

    //disable copy ctor and equal operator
    UProp & operator =(const UProp &b);
    UProp(const UProp &b);
  };



  //Helper macro to initialize UProps in UVar constructors
#   define VAR_PROP_INIT			\
  rangemin(*this, PROP_RANGEMIN),		\
  rangemax(*this, PROP_RANGEMAX),		\
  speedmin(*this, PROP_SPEEDMIN),		\
  speedmax(*this, PROP_SPEEDMAX),		\
  delta(*this, PROP_DELTA),			\
  blend(*this, PROP_BLEND)

  // *****************************************************************************
  /** UVar class definition
      Each UVar instance corresponds to one URBI variable. The class provides access to
      the variable properties, and reading/writting the value to/from all known types.
  */
  class UVar
  {
  public:
    UVar()
      : owned (false),
	VAR_PROP_INIT,
	vardata (0), name ("noname")
    {}
    UVar(UVar&)
      : owned (false),
	VAR_PROP_INIT,
	vardata (0), name ("")
    {
      /// FIXME: This is really weird: a copy-ctor that does not use
      /// the lhs?
    }
    UVar(const std::string&);
    UVar(const std::string&, const std::string&);
    UVar(UObject&, const std::string&);
    ~UVar();

    void init(const std::string&,const std::string&);
    void setOwned();
    void syncValue ();

    void operator = (ufloat);
    void operator = (const std::string&);
    void operator = (const UBinary &);  ///< deep copy
    void operator = (const UImage &i);  ///< deep copy
    void operator = (const USound &s);  ///< deep copy
    void operator = (const UList &l);
    void operator = (const UValue &v);
    operator int ();
    operator bool () {return (int)(*this);}
    operator UBinary ();   ///< deep copy
    operator UBinary *();  ///< deep copy, binary will have to be deleted by the user
    operator UImage (); ///< In plugin mode, gives direct access to the buffer, which may not be valid after the calling function returns. Changes to the other fields of the structure have no effect.
    operator USound(); ///< In plugin mode, gives direct access to the buffer, which may not be valid after the calling function returns. Changes to the other fields of the structure have no effect.
    operator ufloat ();
    operator std::string ();
    operator UList();



    void requestValue(); ///< No effect in plugin mode. In remote mode, updates the value once asynchronously.

    //kernel operators
    ufloat& in();
    ufloat& out();

    bool owned; //< is the variable owned by the module?

    //Property accessors

    UProp rangemin;
    UProp rangemax;
    UProp speedmin;
    UProp speedmax;
    UProp delta;
    UProp blend;

    UValue getProp(UProperty prop);
    void setProp(UProperty prop, const UValue &v);
    void setProp(UProperty prop, double v);
    void setProp(UProperty prop, const char * v);
    void setProp(UProperty prop, const std::string& v) {setProp(prop,v.c_str());}

    // internal
    void __update(UValue&);

  private:
    UValue& val() { return value; }; ///< XXX only works in softdevice mode

    UVardata  *vardata; ///< pointer to internal data specifics
    void __init();

    PRIVATE(std::string,name) ///< full name of the variable as seen in URBI
    PRIVATE(UValue,value) ///< the variable value on the softdevice's side
  };

  inline void UProp::operator =(const UValue& v) {owner.setProp(name,v);}
  inline void UProp::operator =(const double v) {owner.setProp(name,v);}
  inline void UProp::operator =(const std::string& v) {owner.setProp(name,v);}
  inline UProp::operator double() {return (double)owner.getProp(name);}
  inline UProp::operator std::string()  {return owner.getProp(name);}
  inline UProp::operator UValue() {return owner.getProp(name);}

  // *****************************************************************************
  //! Function and Event storage mechanism
  /*! This heavily overloaded class is the only way in C++ to make life easy from the
    the interface user point's of view.
  */

  class UGenericCallback
  {
  public:
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name,
		     int size, UTable &t);
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name, UTable &t);
    virtual ~UGenericCallback();
    std::string getName() { return name;};

    virtual UValue __evalcall(UList &param)  = 0;

    /// Used to store the UVar* pointeur for var monitoring.
    void   *storage;
    /// Period of timers.
    ufloat period;
    /// Nb params of the callbacked function.
    int    nbparam;
    /// Name of the UObject that has created the callback.
    std::string objname;

  private:
    std::string name;
  };

  // *****************************************************************************
  //! Timer mechanism
  /*! This class stores a callback as a class method
   */

  class UTimerCallback
  {
  public:
    UTimerCallback(const std::string& objname, ufloat period, UTimerTable &tt);
    virtual ~UTimerCallback();

    virtual void call() = 0;

    ufloat period;
    ufloat lastTimeCalled;
    std::string objname;
  };

  // UTimerCallback subclasses

  template <class T>
  class UTimerCallbackobj : public UTimerCallback
  {
  public:
    UTimerCallbackobj(const std::string& objname,
		      ufloat period, T* obj, int (T::*fun) (), UTimerTable &tt)
      : UTimerCallback(objname, period,tt), obj(obj), fun(fun)
    {}

    virtual void call()
    {
      ((*obj).*fun)();
    }
  private:
    T* obj;
    int (T::*fun) ();
  };

  // *****************************************************************************
  /** Main UObject class definition
      Each UObject instance corresponds to an URBI object. It provides mechanisms to
      bind variables and functions between C++ and URBI.
  */
  class UObject
  {
  public:

    UObject(const std::string&);
    virtual ~UObject();

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (UVar& v, int (T::*fun) ())
    {
      createUCallback(__name, "var", (T*)this, fun, v.get_name(), monitormap);
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb = createUCallback(__name, "var", (T*)this, fun, v.get_name(), monitormap);
      if (cb) cb->storage = (void*)(&v);
    }

    /// Calls the specified function when the variable value is updated on request by requestValue().
    template <class T>
    void UNotifyOnRequest (UVar& v, int (T::*fun) ())
    {
      createUCallback(__name, "var_onrequest", (T*)this, fun, v.get_name(), monitormap);
    }

    /// Calls the specified function when the variable value is updated on request by requestValue().
    template <class T>
    void UNotifyOnRequest (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb = createUCallback(__name, "var_onrequest", (T*)this, fun, v.get_name(), monitormap);
      if (cb) cb->storage = (void*)(&v);
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (const std::string& name, int (T::*fun) ())
    {
      createUCallback(__name, "var", (T*)this, fun, name, monitormap);
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (const std::string& name, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb = createUCallback(__name, "var", (T*)this, fun, name, monitormap);
      if (cb) cb->storage = new UVar(name);
    }

    /// Calls the specified function each time the variable v is read.
    template <class T>
    void UNotifyAccess (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb = createUCallback(__name, "varaccess", (T*)this, fun, v.get_name(), accessmap);
      if (cb) cb->storage = (void*)(&v);
    }

    /// Set a timer that will call tune 'fun' function every 't' milliseconds.
    template <class T>
    void USetTimer(ufloat t, int (T::*fun) ())
    {
      new UTimerCallbackobj<T> (__name, t,(T*)this, fun, timermap);
    }

    /// Request permanent synchronization for v.
    void USync(UVar &v);

    /// Name of the object as seen in URBI.
    std::string __name;
    /// Name of the class the object is derived from.
    std::string classname;
    /// True when the object has been newed by an urbi command.
    bool   derived;

    UObjectList members;
    /// The hub, if it exists.
    UObjectHub  *objecthub;

    /// Set a timer that will call the update function every 'period' milliseconds
    void USetUpdate(ufloat period);
    virtual int update() {return 0;};
    /// Set autogrouping facility for each new subclass created..
    void UAutoGroup() { autogroup = true; };
    /// Called when a subclass is created if autogroup is true.
    virtual void addAutoGroup() { UJoinGroup(classname+"s"); };

    /// Join the uobject to the 'gpname' group.
    virtual void UJoinGroup(const std::string& gpname);
    /// Void function used in USync callbacks.
    int voidfun() {return  0;};
    /// Add a group with a 's' after the base class name.
    bool autogroup;

    /// Remove all bindings, this method is called by the destructor.
    void clean();

    /// The load attribute is standard and can be used to control the
    /// activity of the object.
    UVar load;

  private:
    /// Pointer to a globalData structure specific to the
    /// remote/plugin architectures who defines it.
    UObjectData*  objectData;
    ufloat period;
  };


  // *****************************************************************************
  //! Main UObjectHub class definition
  class UObjectHub
  {
  public:

    UObjectHub(const std::string&);
    virtual ~UObjectHub();

    void addMember(UObject* obj);

    /// Set a timer that will call update every 'period' milliseconds.
    void USetUpdate(ufloat period);
    virtual int update() {return 0;}

    UObjectList  members;
    UObjectList* getSubClass(const std::string&);
    //   UObjectList* getAllSubClass(const std::string&); //TODO

  protected:
    /// This function calls update and the subclass update.
    int updateGlobal();

    ufloat period;
    std::string name;
  };

  // *****************************************************************************
  // Casters


# define SETCAST(type)				\
  inline type					\
  cast(UValue &val, type *)			\
  {						\
    return (type)val;				\
  }

  SETCAST(int);
  SETCAST(unsigned int);
  SETCAST(long);
  SETCAST(unsigned long);
  SETCAST(ufloat);
  SETCAST(std::string);
  SETCAST(UImage);
  SETCAST(USound);
  UVar& cast(UValue &val, UVar *var);
  UBinary cast(UValue &v, UBinary * b);
  UList cast(UValue &v, UList *l);
  UObjectStruct cast(UValue &v, UObjectStruct *o);
  const char * cast(UValue &v, const char ** b);

#ifndef UOBJECT_NO_LIST_CAST
template<class I> std::list<I> cast(UValue &val, std::list<I> * inu)
{
  std::list<I> result;
  if (val.type != DATA_LIST)
  {
    //cast just the element
    result.push_back(cast(val, (I*)0));
  }
  else
  {
    for (int i=0;i<val.list->size();i++)
      result.push_back(cast(*val.list->array[i], (I*)0));
  }
  return result;
}


#endif
  // **************************************************************************
  //! URBIStarter base class used to store heterogeneous template class objects in starterlist
  class baseURBIStarter
  {
  public:

    baseURBIStarter(const std::string& name) : name(name) {};
    virtual ~baseURBIStarter() {};

    virtual UObject* getUObject() = 0;

    /// Called before deletion.
    virtual void clean() = 0;
    /// Used to provide a wrapper to initialize objects in starterlist.
    virtual void init(const std::string&) =0;
    /// Used to provide a copy of a C++ object based on its name.
    virtual void copy(const std::string&) = 0;
    std::string name;
  };

  //! This is the class containing URBI starters
  /** A starter is a class whose job is to start an instance of a particular UObject subclass,
   * resulting in the initialization of this object (registration to the kernel)
   */
  template <class T>
  class URBIStarter
    : public baseURBIStarter
  {
  public:
    URBIStarter(const std::string& name, UStartlist& _slist)
      : baseURBIStarter(name)
    {
      slist = &_slist;
      slist->push_back(dynamic_cast<baseURBIStarter*>(this));
    };

    virtual ~URBIStarter() { clean(); }

    virtual void clean()
    {
      UObject* tokill = getUObject();
      if (tokill /*&& tokill->derived*/)
	delete tokill;
      UStartlist::iterator toerase =
	std::find(slist->begin(),
		  slist->end(),
		  dynamic_cast<baseURBIStarter*>(this));
      if (toerase != slist->end())
	slist->erase(toerase);
    };

    virtual void
    copy(const std::string& objname)
    {
      URBIStarter<T>* ustarter = new URBIStarter<T>(objname,*slist);
      ustarter->init(objname);
      dynamic_cast<UObject*>(object)->members.push_back(dynamic_cast<UObject*>(ustarter->object));
      dynamic_cast<UObject*>(ustarter->object)->derived   = true;
      dynamic_cast<UObject*>(ustarter->object)->classname =
	dynamic_cast<UObject*>(object)->classname;
      if (dynamic_cast<UObject*>(ustarter->object)->autogroup)
	dynamic_cast<UObject*>(ustarter->object)->addAutoGroup();
    };

    /// Access to the object from the outside.
    virtual UObject* getUObject()
    {
      return dynamic_cast<UObject*>(object);
    };

  protected:
    /// Called when the object is ready to be initialized.
    virtual void init(const std::string& objname)
    {
      object = new T(objname);
    };

    UStartlist  *slist;
    T*          object;
  };

  // **************************************************************************
  //! URBIStarter base class used to store heterogeneous template class objects in starterlist
  class baseURBIStarterHub
  {
  public:

    baseURBIStarterHub(const std::string& name) : name(name) {};
    virtual ~baseURBIStarterHub() {};

    /// Used to provide a wrapper to initialize objects in starterlist.
    virtual void init(const std::string&) = 0;
    virtual UObjectHub* getUObjectHub() = 0;
    std::string name;
  };

  //! This is the class containing URBI starters
  /** A starter is a class whose job is to start an instance of a particular UObject subclass,
   * resulting in the initialization of this object (registration to the kernel)
   */
  template <class T> class URBIStarterHub : public baseURBIStarterHub
  {
  public:
    URBIStarterHub(const std::string& name, UStartlistHub& _slist)
      : baseURBIStarterHub(name)
    {
      slist = &_slist;
      slist->push_back(dynamic_cast<baseURBIStarterHub*>(this));
    };
    virtual ~URBIStarterHub() {/* noone can kill a hub*/ };

  protected:
    /// Called when the object is ready to be initialized.
    virtual void init(const std::string& objname)
    {
      object = new T(objname);
    };

    /// Access to the object from the outside.
    virtual UObjectHub* getUObjectHub()
    {
      return dynamic_cast<UObjectHub*>(object);
    };

    UStartlistHub  *slist;
    T*              object;
  };

  /**********************************************************/
  // This section is autogenerated. Not for humans eyes ;)
  /**********************************************************/

  template<typename T>
  class utrait
  {
  public:
    typedef T noref;
  };

# ifndef _MSC_VER

  template<typename T>
  class utrait<T&>
  {
  public:
    typedef T noref;
  };

# else

  template<>
  class utrait<UVar&>
  {
  public:
    typedef UVar noref;
  };

# endif

%%%% 0 16

       // non void return type

template <class OBJ, class R%%, class P% %%>
class UCallback%N% : public UGenericCallback
{
 public:
  UCallback%N%(const std::string& objname, const std::string& type, OBJ* obj, R (OBJ::*fun) (%%%,% P% %%), const std::string& funname, UTable &t):
    UGenericCallback(objname, type, funname,%N%, t), obj(obj), fun(fun) {};
  virtual UValue __evalcall(UList& param)
  {
    return UValue(( (*obj).*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%));
  };
 private:
  OBJ* obj;
  R (OBJ::*fun) (%%%,% P% %%);
};

// void return type

template <class OBJ%%, class P% %%>
class UCallbackvoid%N% : public UGenericCallback
{
 public:
  UCallbackvoid%N%(const std::string& objname, const std::string& type, OBJ* obj, void (OBJ::*fun) (%%%,% P% %%), const std::string& funname, UTable &t):
    UGenericCallback(objname, type, funname,%N%, t), obj(obj), fun(fun) {};

  virtual UValue __evalcall(UList &param)
  {
    ((*obj).*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%);
    return UValue();
  };
 private:
  OBJ* obj;
  void (OBJ::*fun) (%%%,% P% %%);
};

// void return type : special case for notifyend event callbacks

template <class OBJ%%, class P% %%>
class UCallbacknotifyend%N% : public UGenericCallback
{
 public:
  UCallbacknotifyend%N%(const std::string& objname, const std::string& type, OBJ* obj, void (OBJ::*fun) (%%%,% P% %%), void (OBJ::*end)(),const std::string& funname, UTable &t):
    UGenericCallback(objname, type, funname,%N%, t), obj(obj), fun(end) {};

  virtual UValue __evalcall(UList &)
  {
    ((*obj).*fun)();
    return UValue();
  };
 private:
  OBJ* obj;
  void (OBJ::*fun) ();
};

// void non-member function
template <class INU %%, class P% %%>
class UFCallbackvoid%N% : public UGenericCallback
{
 public:
  UFCallbackvoid%N%(const std::string& objname, const std::string& type,  void (*fun) (%%%,% P% %%), const std::string& funname, UTable &t):
    UGenericCallback(objname, type, funname,%N%, t),  fun(fun) {};

  virtual UValue __evalcall(UList &param)
  {
    (*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%);
    return UValue();
  };
 private:
  void (*fun) (%%%,% P% %%);
};

// non void non-member function
template <class R%%, class P% %%>
class UFCallback%N% : public UGenericCallback
{
 public:
  UFCallback%N%(const std::string& objname, const std::string& type, R (*fun) (%%%,% P% %%), const std::string& funname, UTable &t):
    UGenericCallback(objname, type, funname,%N%, t),  fun(fun) {};
  virtual UValue __evalcall(UList& param)
  {
    return UValue((*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%));
  };
 private:
  R (*fun) (%%%,% P% %%);
};

// callback creation for non-member non void return type

template <class R%%, class P% %%>
UGenericCallback* createUCallback(const std::string& objname, const std::string& type, R (*fun) (%%%,% P% %%), const std::string& funname,UTable &t)
{
  return ((UGenericCallback*) new UFCallback%N%<R%%, P% %%> (objname, type,fun,funname,t));
}

// callback creation for non-member void return type
// inline required since one of them is not a template
template <%%%,% class P% %%> inline 
UGenericCallback* createUCallback(const std::string& objname, const std::string& type,  void (*fun) (%%%,% P% %%), const std::string& funname,UTable &t)
{
  return ((UGenericCallback*) new UFCallbackvoid%N%<void %%, P% %%> (objname, type,fun,funname,t));
}

// callback creation for non void return type

template <class OBJ, class R%%, class P% %%>
UGenericCallback* createUCallback(const std::string& objname, const std::string& type, OBJ* obj, R (OBJ::*fun) (%%%,% P% %%), const std::string& funname,UTable &t)
{
  return ((UGenericCallback*) new UCallback%N%<OBJ,R%%, P% %%> (objname, type,obj,fun,funname,t));
}

// callback creation for void return type

template <class OBJ%%, class P% %%>
UGenericCallback* createUCallback(const std::string& objname, const std::string& type, OBJ* obj, void (OBJ::*fun) (%%%,% P% %%), const std::string& funname,UTable &t)
{
  return ((UGenericCallback*) new UCallbackvoid%N%<OBJ%%, P% %%> (objname, type,obj,fun,funname,t));
}

// special case for eventend notification
template <class OBJ%%, class P% %%>
UGenericCallback* createUCallback(const std::string& objname, const std::string& type, OBJ* obj, void (OBJ::*fun) (%%%,% P% %%), void (OBJ::*end)(), const std::string& funname,UTable &t)
{
  return ((UGenericCallback*) new UCallbacknotifyend%N%<OBJ%%, P% %%> (objname, type,obj,fun,end,funname,t));
}

%%%%


} // end namespace urbi

#endif // ! URBI_UOBJECT_HH

/// Local Variables:
/// mode: c++
/// End:
