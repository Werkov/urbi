/*! \file urbi/uobject.hh
 *******************************************************************************

 File: uobject.hh\n
 Definition of the UObject class and necessary related classes.

 This file is part of UObject Component Architecture\n
 (c) 2006 Gostai S.A.S.

 Permission to use, copy, modify, and redistribute this software for
 non-commercial use is hereby granted.

 This software is provided "as is" without warranty of any kind,
 either expressed or implied, including but not limited to the
 implied warranties of fitness for a particular purpose.

 For more information, comments, bug reports: http://www.urbiforge.com

 **************************************************************************** */

#ifndef URBI_UOBJECT_HH
# define URBI_UOBJECT_HH

# include <string>
# include <list>
# include <algorithm>

# include "libport/singleton-ptr.hh"
# include "libport/ufloat.h"
# include "libport/hash.hh"

# include "urbi/fwd.hh"
# include "urbi/ubinary.hh"
# include "urbi/utypes-common.hh"
# include "urbi/uvalue.hh"
# include "urbi/uvar.hh"

/// This macro must be called once for every UObject class.
# define UStart(x)							\
  ::urbi::URBIStarter<x> x ##  ____URBI_object(std::string(# x),	\
					       ::urbi::objectlist)

/// This macro must be called once for every UObject class.
# define UStartRename(x,name)						\
  ::urbi::URBIStarter<x> x ##  ____URBI_object(std::string(# name),	\
					       ::urbi::objectlist)

/// This macro must be called once for each UObjectHub class.
# define UStartHub(x)							\
  ::urbi::URBIStarterHub<x> x ##  ____URBI_object(std::string(# x),	\
						  ::urbi::objecthublist)


/** Bind a variable to an object.

 This macro can only be called from within a class inheriting from
 UObject.  It binds the UVar x within the object to a variable
 with the same name in the corresponding URBI object.  */
# define UBindVar(obj,x) x.init(__name,# x)

/** This macro inverts a UVar in/out accesses.

 After this call is made, writes by this module affect the sensed
 value, and reads read the target value. Writes by other modules
 and URBI code affect the target value, and reads get the sensed
 value. Without this call, all operations affect the same
 underlying variable.  */
# define UOwned(x) x.setOwned()
// for backward compatibility
# define USensor(x) x.setOwned()

/** Bind the function x in current URBI object to the C++ member
 function of same name.  The return value and parameters must be of
 a basic integral or floating types, char *, std::string, UValue,
 UBinary, USound or UImage, or any type that can cast to/from
 UValue.  */
# define UBindFunction(obj,x)						\
  ::urbi::createUCallback(__name, "function", this,			\
			  (&obj::x),__name+"."+std::string(# x),	\
			  ::urbi::functionmap)

/** Registers a function x in current object that will be called each
 time the event of same name is triggered. The function will be
 called only if the number of arguments match between the function
 prototype and the URBI event.
 */
# define UBindEvent(obj,x)						\
  ::urbi::createUCallback(__name, "event", this,			\
			  (&obj::x),__name+"."+std::string(# x),	\
			  ::urbi::eventmap)

/** Registers a function x in current object that will be called each
 * time the event of same name is triggered, and a function fun called
 * when the event ends. The function will be called only if the number
 * of arguments match between the function prototype and the URBI
 * event.
 */
# define UBindEventEnd(obj,x,fun)					\
  ::urbi::createUCallback(__name, "eventend", this,			\
			  (&obj::x),(&obj::fun),__name+"."+std::string(# x), \
			  ::urbi::eventendmap)

/// Register current object to the UObjectHub named 'hub'.
# define URegister(hub)						\
  do {								\
    objecthub = ::urbi::getUObjectHub((std::string) #hub);	\
    if (objecthub)						\
      objecthub->addMember(dynamic_cast<UObject*>(this));	\
    else							\
      ::urbi::echo("Error: hub name '%s' is unknown\n", #hub);	\
  } while (0)


//macro to send urbi commands
# ifndef URBI
/** Send unquoted URBI commands to the server. Add an extra layer of parenthesis
    for safety.
*/
#   define URBI(a) ::urbi::uobject_unarmorAndSend(# a)
# endif


namespace urbi
{

  // A few list and hashtable types
  typedef libport::hash_map_type<std::string, std::list<UGenericCallback*> >::type UTable;
  typedef libport::hash_map_type<std::string, std::list<UVar*> >::type UVarTable;
  typedef std::list<baseURBIStarter*> UStartlist;
  typedef std::list<baseURBIStarterHub*> UStartlistHub;
  typedef std::list<UTimerCallback*> UTimerTable;
  typedef std::list<UObject*> UObjectList;

  typedef int UReturn;

  // Two singleton lists to handle the object and hubobject registration.
  EXTERN_STATIC_INSTANCE(UStartlist, objectlist);
  EXTERN_STATIC_INSTANCE(UStartlistHub, objecthublist);

  // Lists and hashtables used.
  extern UVarTable varmap;
  extern UTable functionmap;
  extern UTable eventmap;
  extern UTable eventendmap;
  extern UTable monitormap;
  extern UTable accessmap;

  // Timer and update maps.
  extern UTimerTable timermap;
  extern UTimerTable updatemap;

  // For remote mode.
  extern void main(int argc, char *argv[]);

  /// an empty dummy UObject used by UVar to set a NotifyChange
  /// This avoid coupling a UVar to a particular object
  extern UObject* dummyUObject;

  // Global function of the urbi:: namespace to access kernel features

  /// Write a message to the server debug output. Printf syntax.
  void echo(const char * format, ... );
  /// Retrieve a UObjectHub based on its name or return 0 if not found.
  UObjectHub* getUObjectHub(const std::string& n);
  /// Retrieve a UObject based on its name or return 0 if not found.
  UObject* getUObject(const std::string& n);

  /// Send URBI code (ghost connection in plugin mode, default
  /// connection in remote mode).
  void uobject_unarmorAndSend(const char * str);
  /// Send the string to the connection hosting the UObject.
  void send(const char* str);
  /// Send buf to the connection hosting the UObject.
  void send(void* buf,int size);

  //! Function and Event storage mechanism
  /*! This heavily overloaded class is the only way in C++ to make life easy from the
    the interface user point's of view.
  */

  class UGenericCallback
  {
  public:
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name,
		     int size, UTable &t);
    UGenericCallback(const std::string& objname,
		     const std::string& type,
		     const std::string& name, UTable &t);
    virtual ~UGenericCallback();
    std::string getName() { return name;};

    virtual UValue __evalcall(UList &param)  = 0;

    /// Used to store the UVar* pointeur for var monitoring.
    void   *storage;
    /// Period of timers.
    ufloat period;
    /// Nb params of the callbacked function.
    int    nbparam;
    /// Name of the UObject that has created the callback.
    std::string objname;

  private:
    std::string name;
  };


  //! Timer mechanism
  /*! This class stores a callback as a class method
   */

  class UTimerCallback
  {
  public:
    UTimerCallback(const std::string& objname, ufloat period, UTimerTable &tt);
    virtual ~UTimerCallback();

    virtual void call() = 0;

    ufloat period;
    ufloat lastTimeCalled;
    std::string objname;
  };

  // UTimerCallback subclasses

  template <class T>
  class UTimerCallbackobj : public UTimerCallback
  {
  public:
    UTimerCallbackobj(const std::string& objname,
		      ufloat period, T* obj, int (T::*fun) (), UTimerTable &tt)
      : UTimerCallback(objname, period,tt), obj(obj), fun(fun)
    {}

    virtual void call()
    {
      ((*obj).*fun)();
    }
  private:
    T* obj;
    int (T::*fun) ();
  };


  /** Main UObject class definition
      Each UObject instance corresponds to an URBI object. It provides mechanisms to
      bind variables and functions between C++ and URBI.
  */
  class UObject
  {
  public:

    UObject(const std::string&);
    /// dummy UObject constructor
    UObject(int);
    virtual ~UObject();

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (UVar& v, int (T::*fun) ())
    {
      createUCallback(__name, "var", (T*)this, fun, v.get_name(), monitormap);
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb =
	createUCallback(__name, "var", (T*)this, fun, v.get_name(), monitormap);
      if (cb)
	cb->storage = &v;
    }

    /// Calls the specified function when the variable value is updated on request by requestValue().
    template <class T>
    void UNotifyOnRequest (UVar& v, int (T::*fun) ())
    {
      createUCallback(__name, "var_onrequest", (T*)this,
		      fun, v.get_name(), monitormap);
    }

    /// Calls the specified function when the variable value is updated on request by requestValue().
    template <class T>
    void UNotifyOnRequest (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb =
	createUCallback(__name, "var_onrequest", (T*)this,
			fun, v.get_name(), monitormap);
      if (cb)
	cb->storage = &v;
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (const std::string& name, int (T::*fun) ())
    {
      createUCallback(__name, "var", (T*)this, fun, name, monitormap);
    }

    /// Calls the specified function each time the variable v is modified.
    template <class T>
    void UNotifyChange (const std::string& name, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb =
	createUCallback(__name, "var", (T*)this, fun, name, monitormap);
      if (cb)
	cb->storage = new UVar(name);
    }

    /// Calls the specified function each time the variable v is read.
    template <class T>
    void UNotifyAccess (UVar& v, int (T::*fun) (UVar&))
    {
      UGenericCallback* cb =
	createUCallback(__name, "varaccess", (T*)this,
			fun, v.get_name(), accessmap);
      if (cb)
	cb->storage = &v;
    }

    /// Set a timer that will call tune 'fun' function every 't' milliseconds.
    template <class T>
    void USetTimer(ufloat t, int (T::*fun) ())
    {
      new UTimerCallbackobj<T> (__name, t,(T*)this, fun, timermap);
    }

    /// Request permanent synchronization for v.
    void USync(UVar &v);

    /// Name of the object as seen in URBI.
    std::string __name;
    /// Name of the class the object is derived from.
    std::string classname;
    /// True when the object has been newed by an urbi command.
    bool   derived;

    UObjectList members;
    /// The hub, if it exists.
    UObjectHub  *objecthub;

    /// Set a timer that will call the update function every 'period'
    /// milliseconds
    void USetUpdate(ufloat period);
    virtual int update() {return 0;};
    /// Set autogrouping facility for each new subclass created..
    void UAutoGroup() { autogroup = true; };
    /// Called when a subclass is created if autogroup is true.
    virtual void addAutoGroup() { UJoinGroup(classname+"s"); };

    /// Join the uobject to the 'gpname' group.
    virtual void UJoinGroup(const std::string& gpname);
    /// Void function used in USync callbacks.
    int voidfun() {return  0;};
    /// Add a group with a 's' after the base class name.
    bool autogroup;

    /// Flag to know whether the UObject is in remote mode or not
    bool remote;

    /// Remove all bindings, this method is called by the destructor.
    void clean();

    /// The load attribute is standard and can be used to control the
    /// activity of the object.
    UVar load;

  private:
    /// Pointer to a globalData structure specific to the
    /// remote/plugin architectures who defines it.
    UObjectData*  objectData;
    ufloat period;
  };



  //! Main UObjectHub class definition
  class UObjectHub
  {
  public:

    UObjectHub(const std::string&);
    virtual ~UObjectHub();

    void addMember(UObject* obj);

    /// Set a timer that will call update every 'period' milliseconds.
    void USetUpdate(ufloat period);
    virtual int update() {return 0;}

    UObjectList  members;
    UObjectList* getSubClass(const std::string&);
    //   UObjectList* getAllSubClass(const std::string&); //TODO

  protected:
    /// This function calls update and the subclass update.
    int updateGlobal();

    ufloat period;
    std::string name;
  };


  /*----------.
  | Casters.  |
  `----------*/

# define SETCAST(Type)				\
  inline Type					\
  cast(UValue &val, Type*)			\
  {						\
    return (Type)val;				\
  }

  inline const UValue & cast(UValue &val, const UValue *)
  {
    return val;
  }

  inline UValue cast(UValue &val,  UValue *)
  {
    return val;
  }
  SETCAST(int);
  SETCAST(unsigned int);
  SETCAST(long);
  SETCAST(unsigned long);
  SETCAST(ufloat);
  SETCAST(std::string);
  SETCAST(const std::string);
  SETCAST(bool);
  SETCAST(UImage);
  SETCAST(USound);
  UVar& cast(UValue &val, UVar *var);
  UBinary cast(UValue &v, UBinary * b);
  UList cast(UValue &v, UList *l);
  UObjectStruct cast(UValue &v, UObjectStruct *o);
  const char * cast(UValue &v, const char ** b);

#ifndef UOBJECT_NO_LIST_CAST
template<class I> std::list<I> cast(UValue &val, std::list<I> * inu)
{
  std::list<I> result;
  if (val.type != DATA_LIST)
    //cast just the element
    result.push_back(cast(val, (I*)0));
  else
    for (int i=0;i<val.list->size();i++)
      result.push_back(cast(*val.list->array[i], (I*)0));
  return result;
}
#endif

  /// URBIStarter base class used to store heterogeneous template
  /// class objects in starterlist.
  class baseURBIStarter
  {
  public:
    baseURBIStarter(const std::string& name)
      : name(name)
    {}
    virtual ~baseURBIStarter() {}

    virtual UObject* getUObject() = 0;

    /// Called before deletion.
    virtual void clean() = 0;
    /// Used to provide a wrapper to initialize objects in starterlist.
    virtual void init(const std::string&) = 0;
    /// Used to provide a copy of a C++ object based on its name.
    virtual void copy(const std::string&) = 0;
    std::string name;
  };

  //! This is the class containing URBI starters
  /** A starter is a class whose job is to start an instance of a particular UObject subclass,
   * resulting in the initialization of this object (registration to the kernel)
   */
  template <class T>
  class URBIStarter
    : public baseURBIStarter
  {
  public:
    URBIStarter(const std::string& name, UStartlist& _slist)
      : baseURBIStarter(name)
    {
      slist = &_slist;
      slist->push_back(dynamic_cast<baseURBIStarter*>(this));
    }

    virtual ~URBIStarter()
    {
      clean();
    }

    virtual void clean()
    {
      delete getUObject();
      UStartlist::iterator toerase =
	std::find(slist->begin(), slist->end(),
		  dynamic_cast<baseURBIStarter*>(this));
      if (toerase != slist->end())
	slist->erase(toerase);
    }

    virtual void
    copy(const std::string& objname)
    {
      URBIStarter<T>* ustarter = new URBIStarter<T>(objname,*slist);
      ustarter->init(objname);
      UObject *uso = dynamic_cast<UObject*>(ustarter->object);
      getUObject()->members.push_back(uso);
      uso->derived   = true;
      uso->classname = getUObject()->classname;
      if (uso->autogroup)
	uso->addAutoGroup();
    }

    /// Access to the object from the outside.
    virtual UObject* getUObject()
    {
      return dynamic_cast<UObject*>(object);
    }

  protected:
    /// Called when the object is ready to be initialized.
    virtual void init(const std::string& objname)
    {
      object = new T(objname);
    }

    UStartlist  *slist;
    T*          object;
  };


  /// URBIStarter base class used to store heterogeneous template
  /// class objects in starterlist
  class baseURBIStarterHub
  {
  public:

    baseURBIStarterHub(const std::string& name) : name(name) {};
    virtual ~baseURBIStarterHub() {};

    /// Used to provide a wrapper to initialize objects in starterlist.
    virtual void init(const std::string&) = 0;
    virtual UObjectHub* getUObjectHub() = 0;
    std::string name;
  };

  //! This is the class containing URBI starters
  /** A starter is a class whose job is to start an instance of a particular UObject subclass,
   * resulting in the initialization of this object (registration to the kernel)
   */
  template <class T> class URBIStarterHub : public baseURBIStarterHub
  {
  public:
    URBIStarterHub(const std::string& name, UStartlistHub& _slist)
      : baseURBIStarterHub(name)
    {
      slist = &_slist;
      slist->push_back(dynamic_cast<baseURBIStarterHub*>(this));
    }
    virtual ~URBIStarterHub() {/* noone can kill a hub*/ };

  protected:
    /// Called when the object is ready to be initialized.
    virtual void init(const std::string& objname)
    {
      object = new T(objname);
    }

    /// Access to the object from the outside.
    virtual UObjectHub* getUObjectHub()
    {
      return dynamic_cast<UObjectHub*>(object);
    }

    UStartlistHub  *slist;
    T*              object;
  };


  template<typename T>
  class utrait
  {
  public:
    typedef T noref;
  };

# ifndef _MSC_VER

  template<typename T>
  class utrait<T&>
  {
  public:
    typedef T noref;
  };

# else

  template<>
  class utrait<UVar&>
  {
  public:
    typedef UVar noref;
  };

# endif

  /*-----------------------------------------------------.
  | This section is autogenerated. Not for humans eyes.  |
  `-----------------------------------------------------*/

%%%% 0 16

       // non void return type

template <class OBJ, class R%%, class P% %%>
class UCallback%N% : public UGenericCallback
{
 public:
  UCallback%N%(const std::string& objname, const std::string& type,
	       OBJ* obj,
	       R (OBJ::*fun) (%%%,% P% %%),
	       const std::string& funname, UTable &t)
    : UGenericCallback(objname, type, funname, %N%, t),
      obj(obj), fun(fun)
  {
  }

  virtual UValue __evalcall(UList& param)
  {
    // Avoid warnings when we don't use param.
    (void) param;
    return UValue(((*obj).*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref*)0) %%));
  }

 private:
  OBJ* obj;
  R (OBJ::*fun) (%%%,% P% %%);
};

// void return type

template <class OBJ%%, class P% %%>
class UCallbackvoid%N% : public UGenericCallback
{
 public:
  UCallbackvoid%N%(const std::string& objname, const std::string& type,
		   OBJ* obj,
		   void (OBJ::*fun) (%%%,% P% %%),
		   const std::string& funname, UTable &t)
    : UGenericCallback(objname, type, funname,%N%, t),
    obj(obj), fun(fun)
  {
  }

  virtual UValue __evalcall(UList &param)
  {
    // Avoid warnings when we don't use param.
    (void) param;
    ((*obj).*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%);
    return UValue();
  }
 private:
  OBJ* obj;
  void (OBJ::*fun) (%%%,% P% %%);
};

// void return type : special case for notifyend event callbacks

template <class OBJ%%, class P% %%>
class UCallbacknotifyend%N% : public UGenericCallback
{
public:
  UCallbacknotifyend%N%(const std::string& objname, const std::string& type,
			OBJ* obj,
			void (OBJ::*fun) (%%%,% P% %%),
			void (OBJ::*end)(),const std::string& funname,
			UTable &t)
    : UGenericCallback(objname, type, funname,%N%, t),
    obj(obj), fun(end)
  {
  }

  virtual UValue __evalcall(UList &)
  {
    ((*obj).*fun)();
    return UValue();
  }

private:
  OBJ* obj;
  void (OBJ::*fun) ();
};

// void non-member function
template <class INU %%, class P% %%>
class UFCallbackvoid%N% : public UGenericCallback
{
 public:
  UFCallbackvoid%N%(const std::string& objname, const std::string& type,
		    void (*fun) (%%%,% P% %%),
		    const std::string& funname, UTable &t)
    : UGenericCallback(objname, type, funname,%N%, t),  fun(fun)
  {
  }

  virtual UValue __evalcall(UList &param)
  {
    // Avoid warnings when we don't use param.
    (void) param;
    (*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%);
    return UValue();
  }

 private:
  void (*fun) (%%%,% P% %%);
};

// non void non-member function
template <class R%%, class P% %%>
class UFCallback%N% : public UGenericCallback
{
 public:
  UFCallback%N%(const std::string& objname, const std::string& type,
		R (*fun) (%%%,% P% %%),
		const std::string& funname, UTable &t)
    : UGenericCallback(objname, type, funname,%N%, t),  fun(fun)
  {
  }

  virtual UValue __evalcall(UList& param)
  {
    // Avoid warnings when we don't use param.
    (void) param;
    return UValue((*fun)(%%%,% cast(param[% - 1], (typename utrait<P%>::noref *)0) %%));
  }

 private:
  R (*fun) (%%%,% P% %%);
};

// callback creation for non-member non void return type

template <class R%%, class P% %%>
UGenericCallback*
createUCallback(const std::string& objname, const std::string& type,
		R (*fun) (%%%,% P% %%),
		const std::string& funname, UTable& t)
{
  return new UFCallback%N%<R%%, P% %%> (objname, type,fun,funname,t);
}

// callback creation for non-member void return type
// inline required since one of them is not a template
template <%%%,% class P% %%> inline
UGenericCallback*
createUCallback(const std::string& objname, const std::string& type,
		void (*fun) (%%%,% P% %%),
		const std::string& funname,UTable &t)
{
  return new UFCallbackvoid%N%<void %%, P% %%> (objname, type,fun,funname,t);
}

// callback creation for non void return type

template <class OBJ, class R%%, class P% %%>
UGenericCallback*
createUCallback(const std::string& objname, const std::string& type,
		OBJ* obj,
		R (OBJ::*fun) (%%%,% P% %%),
		const std::string& funname,UTable &t)
{
  return new UCallback%N%<OBJ,R%%, P% %%> (objname, type,obj,fun,funname,t);
}

// callback creation for void return type

template <class OBJ%%, class P% %%>
UGenericCallback*
createUCallback(const std::string& objname, const std::string& type,
		OBJ* obj,
		void (OBJ::*fun) (%%%,% P% %%),
		const std::string& funname,UTable &t)
{
  return new UCallbackvoid%N%<OBJ%%, P% %%> (objname, type,obj,fun,funname,t);
}

// special case for eventend notification
template <class OBJ%%, class P% %%>
UGenericCallback*
createUCallback(const std::string& objname, const std::string& type,
		OBJ* obj,
		void (OBJ::*fun) (%%%,% P% %%),
		void (OBJ::*end)(), const std::string& funname,UTable &t)
{
  return new UCallbacknotifyend%N%<OBJ%%, P% %%> (objname, type,obj,fun,end,funname,t);
}

%%%%

} // end namespace urbi

#endif // ! URBI_UOBJECT_HH

/// Local Variables:
/// mode: c++
/// End:
