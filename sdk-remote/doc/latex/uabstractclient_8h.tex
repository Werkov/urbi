\section{uabstractclient.h File Reference}
\label{uabstractclient_8h}\index{uabstractclient.h@{uabstractclient.h}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$sys/types.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include $<$stdarg.h$>$}\par
{\tt \#include $<$list$>$}\par
{\tt \#include $<$iostream$>$}\par
\subsection*{Namespaces}
\begin{CompactItemize}
\item 
namespace {\bf urbi}
\end{CompactItemize}
\subsection*{Classes}
\begin{CompactItemize}
\item 
class {\bf UImage}
\begin{CompactList}\small\item\em Class encapsulating an image. \item\end{CompactList}\item 
class {\bf USound}
\begin{CompactList}\small\item\em Class encapsulating sound informations. \item\end{CompactList}\item 
class {\bf UBinary}
\begin{CompactList}\small\item\em Class containing binary data sent by the server, that could not be furtehr interpreted. \item\end{CompactList}\item 
class {\bf UMessage}
\begin{CompactList}\small\item\em Class containing all informations related to an URBI message. \item\end{CompactList}\item 
class {\bf UAbstract\-Client}
\begin{CompactList}\small\item\em Interface for an URBI wrapper object. \item\end{CompactList}\end{CompactItemize}
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define {\bf UINVALIDCALLBACKID}\ 0\label{uabstractclient_8h_a0}

\item 
\#define {\bf URBI}(a)\ urbi::unarmor\-And\-Send(\#a)
\begin{CompactList}\small\item\em With this macro, the following code is enough to send a simple command to a robot using URBI: int main() \{ {\bf urbi::connect}{\rm (p.\,\pageref{namespaceurbi_a7})}(\char`\"{}robot\char`\"{}); URBI( head\-Pan.val'n = 0 time:1000 $|$ head\-Tilt.val'n = 0 time:1000, speaker.play(\char`\"{}test.wav\char`\"{}), echo \char`\"{}test\char`\"{}; );. \item\end{CompactList}\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef unsigned char {\bf byte}\label{uabstractclient_8h_a2}

\item 
typedef unsigned int {\bf UCallback\-ID}\label{uabstractclient_8h_a6}

\item 
typedef {\bf UCallback\-Action}($\ast$ {\bf UCallback} )(const {\bf UMessage} \&msg)\label{uabstractclient_8h_a7}

\begin{CompactList}\small\item\em Callback prototypes. \item\end{CompactList}\item 
typedef {\bf UCallback\-Action}($\ast$ {\bf UCustom\-Callback} )(void $\ast$callback\-Data, const {\bf UMessage} \&msg)\label{uabstractclient_8h_a8}

\end{CompactItemize}
\subsection*{Enumerations}
\begin{CompactItemize}
\item 
enum {\bf UCallback\-Action} \{ {\bf URBI\_\-CONTINUE} = 0, 
{\bf URBI\_\-REMOVE}
 \}
\begin{CompactList}\small\item\em Return values for the callack functions. \item\end{CompactList}\item 
enum {\bf UMessage\-Type} \{ \par
{\bf MESSAGE\_\-DOUBLE}, 
{\bf MESSAGE\_\-STRING}, 
{\bf MESSAGE\_\-BINARY}, 
{\bf MESSAGE\_\-SYSTEM}, 
\par
{\bf MESSAGE\_\-ERROR}, 
{\bf MESSAGE\_\-UNKNOWN}
 \}
\item 
enum {\bf UBinary\-Message\-Type} \{ {\bf BINARYMESSAGE\_\-NONE}, 
{\bf BINARYMESSAGE\_\-UNKNOWN}, 
{\bf BINARYMESSAGE\_\-IMAGE}, 
{\bf BINARYMESSAGE\_\-SOUND}
 \}
\item 
enum {\bf UImage\-Format} \{ {\bf IMAGE\_\-RGB} = 1, 
{\bf IMAGE\_\-YCb\-Cr} = 2, 
{\bf IMAGE\_\-JPEG} = 3, 
{\bf IMAGE\_\-PPM} = 4
 \}
\item 
enum {\bf USound\-Format} \{ {\bf SOUND\_\-RAW}, 
{\bf SOUND\_\-WAV}, 
{\bf SOUND\_\-MP3}, 
{\bf SOUND\_\-OGG}
 \}
\item 
enum {\bf USound\-Sample\-Format} \{ {\bf SAMPLE\_\-SIGNED} = 1, 
{\bf SAMPLE\_\-UNSIGNED} = 2
 \}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
int {\bf convert\-RGBto\-YCr\-Cb} (const byte $\ast$source, int sourcelen, byte $\ast$dest)\label{uabstractclient_8h_a35}

\begin{CompactList}\small\item\em Image format conversion functions. \item\end{CompactList}\item 
int {\bf convert\-YCr\-Cbto\-RGB} (const byte $\ast$source, int sourcelen, byte $\ast$dest)\label{uabstractclient_8h_a36}

\item 
int {\bf convert\-JPEGto\-YCr\-Cb} (const byte $\ast$source, int sourcelen, byte $\ast$dest, int \&size)\label{uabstractclient_8h_a37}

\item 
int {\bf convert\-JPEGto\-RGB} (const byte $\ast$source, int sourcelen, byte $\ast$dest, int \&size)\label{uabstractclient_8h_a38}

\item 
int {\bf convert} (const {\bf USound} \&source, {\bf USound} \&destination)
\begin{CompactList}\small\item\em Conversion between various sound formats. \item\end{CompactList}\item 
UCallback\-Wrapper \& {\bf callback} ({\bf UCallback} cb)\label{uabstractclient_8h_a40}

\item 
UCallback\-Wrapper \& {\bf callback} (UCustom\-Callback cb, void $\ast$data)\label{uabstractclient_8h_a41}

\item 
template$<$class C$>$ UCallback\-Wrapper \& {\bf callback} (C \&ref, {\bf UCallback\-Action}(C::$\ast$func)(const {\bf UMessage} \&))\label{uabstractclient_8h_a42}

\item 
template$<$class C, class P1$>$ UCallback\-Wrapper \& {\bf callback} (C \&ref, {\bf UCallback\-Action}(C::$\ast$func)(P1, const {\bf UMessage} \&), P1 p1)\label{uabstractclient_8h_a43}

\item 
template$<$class C, class P1, class P2$>$ UCallback\-Wrapper \& {\bf callback} (C \&ref, {\bf UCallback\-Action}(C::$\ast$func)(P1, P2, const {\bf UMessage} \&), P1 p1, P2 p2)\label{uabstractclient_8h_a44}

\item 
template$<$class C, class P1, class P2, class P3$>$ UCallback\-Wrapper \& {\bf callback} (C \&ref, {\bf UCallback\-Action}(C::$\ast$func)(P1, P2, P3, const {\bf UMessage} \&), P1 p1, P2 p2, P3 p3)\label{uabstractclient_8h_a45}

\item 
template$<$class C, class P1, class P2, class P3, class P4$>$ UCallback\-Wrapper \& {\bf callback} (C \&ref, {\bf UCallback\-Action}(C::$\ast$func)(P1, P2, P3, P4, const {\bf UMessage} \&), P1 p1, P2 p2, P3 p3, P4 p4)\label{uabstractclient_8h_a46}

\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
const int {\bf URBI\_\-BUFLEN} = 128000\label{uabstractclient_8h_a3}

\begin{CompactList}\small\item\em Connection Buffer size. \item\end{CompactList}\item 
const int {\bf URBI\_\-PORT} = 54000\label{uabstractclient_8h_a4}

\begin{CompactList}\small\item\em Standard port of URBI server. \item\end{CompactList}\item 
const int {\bf URBI\_\-MAX\_\-TAG\_\-LENGTH} = 64\label{uabstractclient_8h_a5}

\begin{CompactList}\small\item\em Maximum length of an URBI tag. \item\end{CompactList}\item 
const char {\bf semicolon} = ';'\label{namespaceurbi_a0}

\item 
const char {\bf pipe} = '$|$'\label{namespaceurbi_a1}

\item 
const char {\bf parallel} = '\&'\label{namespaceurbi_a2}

\item 
const char {\bf comma} = ','\label{namespaceurbi_a3}

\end{CompactItemize}


\subsection{Detailed Description}
\begin{Desc}
\item[Id]{\bf uabstractclient.h}{\rm (p.\,\pageref{uabstractclient_8h})},v 1.7 2005/04/11 13:42:06 nottale Exp \end{Desc}


Definition of the URBI interface class

Copyright (C) 2004 Jean-Christophe Baillie. All rights reserved.

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

Definition in file {\bf uabstractclient.h}.

\subsection{Define Documentation}
\index{uabstractclient.h@{uabstractclient.h}!URBI@{URBI}}
\index{URBI@{URBI}!uabstractclient.h@{uabstractclient.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define URBI(a)\ urbi::unarmor\-And\-Send(\#a)}\label{uabstractclient_8h_a1}


With this macro, the following code is enough to send a simple command to a robot using URBI: int main() \{ {\bf urbi::connect}{\rm (p.\,\pageref{namespaceurbi_a7})}(\char`\"{}robot\char`\"{}); URBI( head\-Pan.val'n = 0 time:1000 $|$ head\-Tilt.val'n = 0 time:1000, speaker.play(\char`\"{}test.wav\char`\"{}), echo \char`\"{}test\char`\"{}; );. 

\}

The following construct is also valid: {\bf URBI()}{\rm (p.\,\pageref{uabstractclient_8h_a1})} $<$$<$ \char`\"{}head\-Pan.val=\char`\"{}$<$$<$12$<$$<$\char`\"{};\char`\"{}; 

Definition at line 609 of file uabstractclient.h.

\subsection{Enumeration Type Documentation}
\index{uabstractclient.h@{uabstractclient.h}!UCallbackAction@{UCallbackAction}}
\index{UCallbackAction@{UCallbackAction}!uabstractclient.h@{uabstractclient.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf UCallback\-Action}}\label{uabstractclient_8h_a47}


Return values for the callack functions. 

Each callback function, when called, must return with either URBI\_\-CONTINUE or URBI\_\-REMOVE:\begin{itemize}
\item URBI\_\-CONTINUE means that the client should continue to call this callbak function.\item URBI\_\-REMOVE means that the client should never call this callback again. \end{itemize}


Definition at line 50 of file uabstractclient.h.

Referenced by UAbstract\-Client::notify\-Callbacks().\index{uabstractclient.h@{uabstractclient.h}!UImageFormat@{UImageFormat}}
\index{UImageFormat@{UImageFormat}!uabstractclient.h@{uabstractclient.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf UImage\-Format}}\label{uabstractclient_8h_a50}


\begin{Desc}
\item[Enumeration values: ]\par
\begin{description}
\index{IMAGE_RGB@{IMAGE\_\-RGB}!uabstractclient.h@{uabstractclient.h}}\index{uabstractclient.h@{uabstractclient.h}!IMAGE_RGB@{IMAGE\_\-RGB}}\item[{\em 
IMAGE\_\-RGB\label{uabstractclient_8h_a50a25}
}]RGB 24 bit/pixel. \index{IMAGE_YCbCr@{IMAGE\_\-YCbCr}!uabstractclient.h@{uabstractclient.h}}\index{uabstractclient.h@{uabstractclient.h}!IMAGE_YCbCr@{IMAGE\_\-YCbCr}}\item[{\em 
IMAGE\_\-YCb\-Cr\label{uabstractclient_8h_a50a26}
}]YCb\-Cr 24 bit/pixel. \index{IMAGE_JPEG@{IMAGE\_\-JPEG}!uabstractclient.h@{uabstractclient.h}}\index{uabstractclient.h@{uabstractclient.h}!IMAGE_JPEG@{IMAGE\_\-JPEG}}\item[{\em 
IMAGE\_\-JPEG\label{uabstractclient_8h_a50a27}
}]JPEG. \index{IMAGE_PPM@{IMAGE\_\-PPM}!uabstractclient.h@{uabstractclient.h}}\index{uabstractclient.h@{uabstractclient.h}!IMAGE_PPM@{IMAGE\_\-PPM}}\item[{\em 
IMAGE\_\-PPM\label{uabstractclient_8h_a50a28}
}]RGB with a PPM header. \end{description}
\end{Desc}



Definition at line 79 of file uabstractclient.h.

\subsection{Function Documentation}
\index{uabstractclient.h@{uabstractclient.h}!convert@{convert}}
\index{convert@{convert}!uabstractclient.h@{uabstractclient.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int convert (const {\bf USound} \& {\em source}, {\bf USound} \& {\em dest})}\label{uabstractclient_8h_a39}


Conversion between various sound formats. 

If any of destination,'s channel, sample\-Size, rate or sample\-Format parameter is 0, values from source will be used. If the desitnation's datasize is too small, data will be realloc()ed, which means one can set data and datasize to zero, and let convert allocate the memory. 

Definition at line 1068 of file uabstractclient.cpp.

References USound::channels, USound::data, USound::rate, USound::sample\-Format, USound::sample\-Size, USound::size, and USound::sound\-Format.

Referenced by USync\-Client::sync\-Get\-Sound().