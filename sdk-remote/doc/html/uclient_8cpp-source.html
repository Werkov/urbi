<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liburbi-cpp: uclient.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>uclient.cpp</h1><a href="uclient_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00023 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00024 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00025 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00026 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00027 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00028 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00029 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00030 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00031 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00032 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00033 <span class="preprocessor">#include "<a class="code" href="uclient_8h.html">uclient.h</a>"</span>
00034 
00035 <span class="keyword">namespace </span>urbi {
00036   <a class="code" href="classUClient.html">UClient</a> * defaultClient = 0;
00037 };
00038 
00039 
00040 
00041 <span class="keyword">static</span> <span class="keywordtype">void</span> *listenThreadStarter(<span class="keywordtype">void</span> *objectPtr)
00042 {
00043   <a class="code" href="classUClient.html">UClient</a> *connection = (<a class="code" href="classUClient.html">UClient</a> *) objectPtr;
00044   connection-&gt;<a class="code" href="classUClient.html#a3">listenThread</a>();
00045 }
00046 
<a name="l00051"></a><a class="code" href="classUClient.html#a0">00051</a> <a class="code" href="classUClient.html#a0">UClient::UClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *_host, <span class="keywordtype">int</span> _port, <span class="keywordtype">int</span> _buflen) 
00052   :<a class="code" href="classUAbstractClient.html">UAbstractClient</a>(_host, _port, _buflen) {
00053     control_fd[0] = control_fd[1] = -1;
00054     <span class="keywordflow">if</span> (pipe(control_fd) == -1) {
00055       rc = -1;
00056       perror(<span class="stringliteral">"UClient::UClient failed to create pipe"</span>);
00057       <span class="keywordflow">return</span>;
00058     }
00059     pthread_mutexattr_t ma;
00060     pthread_condattr_t ca;
00061     pthread_mutexattr_init(&amp;ma);
00062     
00063     pthread_mutexattr_settype(&amp;ma, PTHREAD_MUTEX_RECURSIVE_NP);
00064     pthread_mutex_init(&amp;writeLock, &amp;ma);
00065     <span class="comment">//MUST BE RECURSIVE if a callback calls notifycallback </span>
00066     <span class="comment">//pthread_mutexattr_settype(&amp;ma, PTHREAD_MUTEX_FAST_NP);</span>
00067     pthread_mutex_init(&amp;listLock, &amp;ma);
00068     listenThreadStruct = NULL;
00069     
00070     <span class="comment">// Address resolution stage.</span>
00071     <span class="keyword">struct </span>hostent *hen;                <span class="comment">// host-to-IP translation</span>
00072     <span class="keyword">struct </span>sockaddr_in sa;      <span class="comment">// Internet address struct</span>
00073     
00074    
00075     memset(&amp;sa, 0, <span class="keyword">sizeof</span>(sa));
00076     
00077     sa.sin_family = AF_INET;
00078     sa.sin_port = htons(port);
00079     
00080     hen = gethostbyname(host);
00081     
00082     <span class="keywordflow">if</span> (!hen) { <span class="comment">//maybe it is an IP address</span>
00083       sa.sin_addr.s_addr = inet_addr(host);
00084       <span class="keywordflow">if</span> (sa.sin_addr.s_addr == INADDR_NONE) {
00085         <a class="code" href="classUClient.html#a4">printf</a>(<span class="stringliteral">"UClient::UClient couldn't resolve host name.\n"</span>);
00086         rc = -1;
00087         <span class="keywordflow">return</span>;
00088       }
00089     }
00090     
00091     <span class="keywordflow">else</span>
00092       memcpy(&amp;sa.sin_addr.s_addr, hen-&gt;h_addr_list[0], hen-&gt;h_length);
00093     
00094     <a class="code" href="classUClient.html#p0">sd</a> = socket(AF_INET, SOCK_STREAM, 0);
00095     <span class="keywordflow">if</span> (<a class="code" href="classUClient.html#p0">sd</a> &lt; 0) {
00096       <a class="code" href="classUClient.html#a4">printf</a>(<span class="stringliteral">"UClient::UClient socket allocation failed.\n"</span>);
00097       rc = -1;
00098       <span class="keywordflow">return</span>;
00099     }
00100     
00101     <span class="comment">// now connect to the remote server. </span>
00102     rc = <a class="code" href="namespaceurbi.html#a7">connect</a>(<a class="code" href="classUClient.html#p0">sd</a>, (<span class="keyword">struct</span> sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));
00103     
00104     <span class="comment">// If we attempt to connect too fast to aperios ipstack it will fail.</span>
00105     <span class="keywordflow">if</span> (rc) {
00106       usleep(20000);
00107         rc = <a class="code" href="namespaceurbi.html#a7">connect</a>(<a class="code" href="classUClient.html#p0">sd</a>, (<span class="keyword">struct</span> sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));
00108     }
00109     
00110     <span class="comment">// Check there was no error.</span>
00111     <span class="keywordflow">if</span> (rc) {
00112       <a class="code" href="classUClient.html#a4">printf</a>(<span class="stringliteral">"UClient::UClient couldn't connect.\n"</span>);
00113       <span class="keywordflow">return</span>;
00114     }
00115     
00116     <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span>;
00117     
00118     <span class="comment">//check that it really worked</span>
00119     <span class="keywordtype">int</span> pos=0;
00120     <span class="keywordflow">while</span> (pos==0)
00121       pos = read(<a class="code" href="classUClient.html#p0">sd</a>, recvBuffer, buflen);
00122     <span class="keywordflow">if</span> (pos&lt;0) {
00123       rc = pos;
00124       <a class="code" href="classUClient.html#a4">printf</a>(<span class="stringliteral">"UClient::UClient couldn't connect: read error.\n"</span>);
00125       <span class="keywordflow">return</span>;
00126     }
00127     <span class="keywordflow">else</span> recvBufferPosition = pos;
00128     recvBuffer[recvBufferPosition] = 0;
00129     listenThreadStruct = <span class="keyword">new</span> pthread_t();
00130     pthread_create(listenThreadStruct, NULL, listenThreadStarter, <span class="keyword">this</span>);
00131     <span class="keywordflow">if</span> (!urbi::defaultClient)
00132       urbi::defaultClient =  <span class="keyword">this</span>;
00133   }
00134 
00135 
00136 
00137 
00138 UClient::~UClient()
00139 {
00140   
00141   close(sd);
00142   <span class="keywordflow">if</span> (control_fd[1] != -1 ) ::write(control_fd[1],<span class="stringliteral">"a"</span>,1);
00143   <span class="comment">//must wait for listen thread to terminate</span>
00144   <span class="keywordflow">if</span> (listenThreadStruct)
00145         pthread_join(*listenThreadStruct, NULL);
00146   pthread_mutex_destroy(&amp;writeLock);
00147   pthread_mutex_destroy(&amp;listLock);
00148   <span class="keywordflow">if</span> (control_fd[1] != -1 ) close(control_fd[1]);
00149   <span class="keywordflow">if</span> (control_fd[0] != -1 ) close(control_fd[0]);
00150 }
00151 
00152 
00153 <span class="keywordtype">bool</span> 
<a name="l00154"></a><a class="code" href="classUClient.html#b1">00154</a> <a class="code" href="classUClient.html#b1">UClient::canSend</a>(<span class="keywordtype">int</span> size) {
00155   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00156 }
00157 
00158 
00159 <span class="keywordtype">int</span> 
<a name="l00160"></a><a class="code" href="classUClient.html#b0">00160</a> <a class="code" href="classUClient.html#b0">UClient::effectiveSend</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>  * buffer, <span class="keywordtype">int</span> size) {
00161   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00162   <span class="keywordtype">int</span> pos = 0;
00163   <span class="keywordflow">while</span> (pos!=size) {
00164     <span class="keywordtype">int</span> retval = ::write(sd, (<span class="keywordtype">char</span> *) buffer + pos, size-pos);
00165         <span class="keywordflow">if</span> (retval&lt;0) {
00166           rc = retval;
00167           <span class="keywordflow">return</span> rc;
00168         }
00169         pos += retval;
00170   }
00171   <span class="keywordflow">return</span> 0;
00172 }
00173 
00174 <span class="keywordtype">void</span> 
<a name="l00175"></a><a class="code" href="classUClient.html#a3">00175</a> <a class="code" href="classUClient.html#a3">UClient::listenThread</a>() {
00176   fd_set rfds;
00177   <span class="keywordtype">int</span> maxfd=1+ (<a class="code" href="classUClient.html#p0">sd</a>&gt;control_fd[0]? <a class="code" href="classUClient.html#p0">sd</a>:control_fd[0]);
00178   <span class="keywordtype">int</span> res;
00179   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
00180         <span class="keywordflow">do</span> {
00181           FD_ZERO(&amp;rfds);
00182           FD_SET(<a class="code" href="classUClient.html#p0">sd</a>, &amp;rfds);
00183           FD_SET(control_fd[0], &amp;rfds);
00184           res = select(maxfd+1, &amp;rfds, NULL, NULL, NULL);
00185           <span class="keywordflow">if</span> ( (res == -1) &amp;&amp; (errno != EINTR)) {
00186                 this-&gt;rc = -1;
00187                 <span class="comment">//TODO when error will be implemented, send an error msg</span>
00188                 <span class="comment">//TODO maybe try to reconnect?</span>
00189                 <span class="keywordflow">return</span>;
00190           }
00191           <span class="keywordflow">if</span> (res == -1) { res=0;<span class="keywordflow">continue</span>;}
00192           <span class="keywordflow">if</span> ( (res != 0) &amp;&amp; (FD_ISSET(control_fd[0], &amp;rfds)) ) <span class="keywordflow">return</span>;
00193         }
00194         <span class="keywordflow">while</span> (res == 0);       
00195         <span class="keywordtype">int</span> count = read(<a class="code" href="classUClient.html#p0">sd</a>, 
00196                      &amp;recvBuffer[recvBufferPosition], 
00197                      buflen - recvBufferPosition - 1);
00198         <span class="keywordflow">if</span> (count == -1) {
00199           rc = -1;
00200           <span class="comment">//TODO when error will be implemented, send an error msg</span>
00201           <span class="comment">//TODO maybe try to reconnect?</span>
00202           <span class="keywordflow">return</span>;
00203         }
00204 
00205         recvBufferPosition += count;
00206         recvBuffer[recvBufferPosition] = 0;
00207         <a class="code" href="classUAbstractClient.html#b0">processRecvBuffer</a>();
00208   }
00209 }
00210 
00211 
00212 
00213 <span class="keywordtype">void</span> 
<a name="l00214"></a><a class="code" href="classUClient.html#b2">00214</a> <a class="code" href="classUClient.html#b2">UClient::lockList</a>() {
00215   pthread_mutex_lock(&amp;listLock);
00216 }
00217 
00218 <span class="keywordtype">void</span> 
<a name="l00219"></a><a class="code" href="classUClient.html#a6">00219</a> <a class="code" href="classUClient.html#a6">UClient::lockSend</a>() {
00220   pthread_mutex_lock(&amp;writeLock);
00221 }
00222 
00223 <span class="keywordtype">void</span> 
<a name="l00224"></a><a class="code" href="classUClient.html#b3">00224</a> <a class="code" href="classUClient.html#b3">UClient::unlockList</a>() {
00225   pthread_mutex_unlock(&amp;listLock);
00226 }
00227 
00228 <span class="keywordtype">void</span> 
<a name="l00229"></a><a class="code" href="classUClient.html#a7">00229</a> <a class="code" href="classUClient.html#a7">UClient::unlockSend</a>() {
00230   pthread_mutex_unlock(&amp;writeLock);
00231 }
00232 
00233 
00234 
00235 <span class="keywordtype">void</span> 
<a name="l00236"></a><a class="code" href="classUClient.html#a4">00236</a> <a class="code" href="classUClient.html#a4">UClient::printf</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * format, ...) {
00237   va_list arg;
00238   va_start(arg, format);
00239   vfprintf(stderr, format, arg);
00240   va_end(arg);
00241 }
00242 
<a name="l00243"></a><a class="code" href="classUClient.html#a5">00243</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classUClient.html#a5">UClient::getCurrentTime</a>() {
00244   <span class="keyword">struct </span>timeval tv;
00245   gettimeofday(&amp;tv, NULL);
00246   <span class="keywordflow">return</span> tv.tv_sec*1000+tv.tv_usec/1000;
00247 } 
00248 
<a name="l00249"></a><a class="code" href="namespaceurbi.html#a5">00249</a> <span class="keywordtype">void</span> <a class="code" href="namespaceurbi.html#a5">urbi::execute</a>(<span class="keywordtype">void</span>) {
00250   <span class="keywordflow">while</span> (<span class="keyword">true</span>) sleep(100);
00251 }
00252 
<a name="l00253"></a><a class="code" href="namespaceurbi.html#a6">00253</a> <span class="keywordtype">void</span> <a class="code" href="namespaceurbi.html#a6">urbi::exit</a>(<span class="keywordtype">int</span> code) {
00254   ::exit(code);
00255 }
00256 
00257 
<a name="l00258"></a><a class="code" href="namespaceurbi.html#a7">00258</a> <a class="code" href="classUClient.html">UClient</a> &amp; <a class="code" href="namespaceurbi.html#a7">urbi::connect</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>  * host) {
00259   <span class="keywordflow">return</span> *<span class="keyword">new</span> <a class="code" href="classUClient.html">UClient</a>(host);
00260 }
00261 
<a name="l00262"></a><a class="code" href="namespaceurbi.html#a8">00262</a> <a class="code" href="classUClient.html">UClient</a> * <a class="code" href="namespaceurbi.html#a8">urbi::getDefaultClient</a>() {
00263   <span class="keywordflow">return</span> urbi::defaultClient;
00264 }
00265 
<a name="l00266"></a><a class="code" href="namespaceurbi.html#a9">00266</a> <span class="keywordtype">void</span> <a class="code" href="namespaceurbi.html#a9">urbi::setDefaultClient</a>(<a class="code" href="classUClient.html">UClient</a> * cl) {
00267   urbi::defaultClient = cl;
00268 }
00269 
00270 
<a name="l00271"></a><a class="code" href="namespaceurbi.html#a10">00271</a> std::ostream &amp; <a class="code" href="namespaceurbi.html#a10">urbi::unarmorAndSend</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * a) {
00272   std::ostream &amp; s = (<a class="code" href="namespaceurbi.html#a8">urbi::getDefaultClient</a>()==0)? std::cerr : (*<a class="code" href="namespaceurbi.html#a8">urbi::getDefaultClient</a>());
00273   <span class="keywordflow">if</span> (strlen(a)&gt;2)
00274     <span class="keywordflow">if</span> (a[0]==<span class="charliteral">'('</span> &amp;&amp; a[strlen(a)-1]==<span class="charliteral">')'</span>)
00275       s.rdbuf()-&gt;sputn(a+1, strlen(a)-2);
00276     <span class="keywordflow">else</span>
00277       s &lt;&lt; a; <span class="comment">//this is baaad, user forgot the parenthesis but was lucky</span>
00278   <span class="keywordflow">return</span> s;
00279 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Sep 21 08:43:19 2005 for liburbi-cpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
