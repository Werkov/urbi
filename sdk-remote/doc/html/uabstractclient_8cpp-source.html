<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liburbi-cpp: uabstractclient.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>uabstractclient.cpp</h1><a href="uabstractclient_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00024 <span class="preprocessor">#ifdef WIN32</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;Windows.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00029 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00030 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00031 <span class="preprocessor">#include &lt;math.h&gt;</span>
00032 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
00033 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00034 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00035 
00036 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
00037 {
00038 <span class="preprocessor">#include "../../lib/jpeg-6b/jpeglib.h"</span>
00039 <span class="preprocessor">#include "../../lib/jpeg-6b/jerror.h"</span>
00040 }
00041 
00042 <span class="preprocessor">#include "<a class="code" href="uabstractclient_8h.html">uabstractclient.h</a>"</span>
00043 <span class="preprocessor">#define DEBUG 0</span>
00044 <span class="preprocessor"></span><span class="keyword">using</span> std::min;
00045 <span class="preprocessor">#if DEBUG</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00047 <span class="keyword">static</span> <span class="keywordtype">int</span> mtime()
00048 {
00049   <span class="keyword">static</span> <span class="keywordtype">int</span> base = 0;
00050   timeval tv;
00051   gettimeofday(&amp;tv, NULL);
00052   <span class="keywordtype">int</span> tme = tv.tv_sec * 1000 + (tv.tv_usec / 1000);
00053   <span class="keywordflow">if</span> (!base)
00054     base = tme;
00055   <span class="keywordflow">return</span> tme - base;
00056 }
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">//inline int min(int a, int b) {if (a&lt;b) return a; else return b;}</span>
00060 <span class="preprocessor">#define URBI_ERROR_TAG "[error]"</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define URBI_WILDCARD_TAG "[wildcard]"</span>
00062 <span class="preprocessor"></span><span class="keyword">enum</span> UCallbackType
00063 {
00064   UCB_,
00065   UCB_C,
00066 };
00067 
00068 
00069 
00070 
00071 
00072 <span class="keyword">static</span> UCallbackID nextId;
00073 
00074 <span class="keyword">class </span>UCallbackWrapperCB: <span class="keyword">public</span> UCallbackWrapper {
00075   <a class="code" href="uabstractclient_8h.html#a7">UCallback</a> cb;
00076  <span class="keyword">public</span>:
00077   UCallbackWrapperCB(UCallback cb): cb(cb) {}
00078   <span class="keyword">virtual</span> <a class="code" href="uabstractclient_8h.html#a47">UCallbackAction</a> operator ()(<span class="keyword">const</span> <a class="code" href="classUMessage.html">UMessage</a> &amp; msg) {
00079     <span class="keywordflow">return</span> cb(msg);
00080   }
00081 };
00082 
00083 
00084 <span class="keyword">class </span>UCallbackWrapperCCB: <span class="keyword">public</span> UCallbackWrapper {
00085   UCustomCallback cb;
00086   <span class="keywordtype">void</span> * data;
00087  <span class="keyword">public</span>:
00088   UCallbackWrapperCCB(UCustomCallback cb, <span class="keywordtype">void</span> * data): cb(cb), data(data) {}
00089   <span class="keyword">virtual</span> <a class="code" href="uabstractclient_8h.html#a47">UCallbackAction</a> operator ()(<span class="keyword">const</span> <a class="code" href="classUMessage.html">UMessage</a> &amp; msg) {
00090     <span class="keywordflow">return</span> cb(data, msg);
00091   }
00092 };
00093 
00094 <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="uabstractclient_8cpp.html#a6">read_jpeg</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *jpgbuffer, <span class="keywordtype">int</span> jpgbuffer_size, 
00095                        <span class="keywordtype">bool</span> RGB, <span class="keywordtype">int</span> &amp;output_size);
00096 
00097 
00098 <span class="keyword">class </span>UClientStreambuf: <span class="keyword">public</span> std::streambuf {
00099  <span class="keyword">public</span>:
00100   UClientStreambuf(<a class="code" href="classUAbstractClient.html">UAbstractClient</a> * cl): client(cl) {}
00101  <span class="keyword">protected</span>:
00102   <span class="keyword">virtual</span> <span class="keywordtype">int</span> overflow ( <span class="keywordtype">int</span> c = EOF );
00103   <span class="keyword">virtual</span> std::streamsize xsputn (<span class="keywordtype">char</span> * s, std::streamsize n);
00104  <span class="keyword">private</span>:
00105   <a class="code" href="classUAbstractClient.html">UAbstractClient</a> * client;
00106 };
00107 
00108 <span class="keywordtype">int</span> UClientStreambuf::overflow ( <span class="keywordtype">int</span> c ) {
00109   <span class="keywordflow">if</span> (c != EOF) {
00110     <span class="keywordtype">char</span> ch = c;
00111     xsputn(&amp;ch, 1);
00112   }
00113 }
00114 
00115 std::streamsize UClientStreambuf::xsputn (<span class="keywordtype">char</span> * s, std::streamsize n) {
00116   client-&gt;lockSend();
00117   <span class="keywordflow">if</span> (strlen(client-&gt;sendBuffer)+1+n &gt; client-&gt;buflen) {
00118     <span class="comment">//error</span>
00119     client-&gt;unlockSend();
00120     <span class="keywordflow">return</span> 0;
00121   }
00122   <span class="keywordtype">int</span> clen = strlen(client-&gt;sendBuffer);
00123   memcpy(client-&gt;sendBuffer+clen, s, n);
00124   client-&gt;sendBuffer[clen+n] = 0;
00125   <span class="keywordflow">if</span> (strchr(client-&gt;sendBuffer,<span class="charliteral">'&amp;'</span>) ||
00126       strchr(client-&gt;sendBuffer,<span class="charliteral">'|'</span>) ||
00127       strchr(client-&gt;sendBuffer,<span class="charliteral">';'</span>) ||
00128       strchr(client-&gt;sendBuffer,<span class="charliteral">','</span>)) {
00129     client-&gt;effectiveSend(client-&gt;sendBuffer, strlen(client-&gt;sendBuffer));
00130     client-&gt;sendBuffer[0] = 0;
00131   }
00132   client-&gt;unlockSend();
00133   <span class="keywordflow">return</span> n;
00134 }
00135 
00139 <span class="keywordtype">void</span> 
<a name="l00140"></a><a class="code" href="classUAbstractClient.html#a30">00140</a> <a class="code" href="classUAbstractClient.html#a30">UAbstractClient::notifyCallbacks</a>(<span class="keyword">const</span> <a class="code" href="classUMessage.html">UMessage</a> &amp;msg) {
00141   <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00142   <span class="keywordtype">bool</span> inc=<span class="keyword">false</span>;
00143   <span class="keywordflow">for</span> (list&lt;UCallbackInfo&gt;::iterator it = callbackList.begin(); it!=callbackList.end(); inc?it:it++, inc=<span class="keyword">false</span>) {
00144     <span class="keywordflow">if</span> ( 
00145         (!strcmp(msg.<a class="code" href="classUMessage.html#o2">tag</a>, it-&gt;<a class="code" href="classUMessage.html#o2">tag</a>)) ||
00146         (!strcmp(it-&gt;tag, URBI_ERROR_TAG) &amp;&amp; msg.<a class="code" href="classUMessage.html#o3">type</a> == MESSAGE_ERROR) ||
00147         (!strcmp(it-&gt;tag, URBI_WILDCARD_TAG)) 
00148         ) {
00149       <a class="code" href="uabstractclient_8h.html#a47">UCallbackAction</a> ua = it-&gt;callback(msg);
00150       <span class="keywordflow">if</span> (ua == URBI_REMOVE) {
00151         <span class="keyword">delete</span> &amp;(it-&gt;callback);
00152         it=callbackList.erase(it);
00153         inc = <span class="keyword">true</span>;
00154       }
00155     }
00156   }
00157   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00158 }
00159 
<a name="l00166"></a><a class="code" href="classUAbstractClient.html#a0">00166</a> <a class="code" href="classUAbstractClient.html#a0">UAbstractClient::UAbstractClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *_host, <span class="keywordtype">int</span> _port, <span class="keywordtype">int</span> _buflen)
00167   :std::ostream(new UClientStreambuf(this))
00168 {
00169   setf(std::ios::fixed); 
00170   <a class="code" href="classUAbstractClient.html#p3">rc</a> = 0;
00171   uid = 0;
00172   <a class="code" href="classUAbstractClient.html#p0">host</a> = NULL;
00173   <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a> = NULL;
00174   binaryBuffer = NULL;
00175   <a class="code" href="classUAbstractClient.html#p0">host</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(_host) + 1];
00176   <span class="keywordflow">if</span> (!host) {
00177     <a class="code" href="classUAbstractClient.html#p3">rc</a> = -1;
00178     <span class="keywordflow">return</span>;
00179   }
00180   strcpy(<a class="code" href="classUAbstractClient.html#p0">host</a>, _host);
00181   <a class="code" href="classUAbstractClient.html#p1">port</a> = _port;
00182   <a class="code" href="classUAbstractClient.html#p2">buflen</a> = _buflen;
00183 
00184  
00185 
00186   <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[buflen];
00187   <span class="keywordflow">if</span> (!recvBuffer) {
00188     <a class="code" href="classUAbstractClient.html#p3">rc</a> = -1;
00189     <span class="comment">//printf("UAbstractClient::UAbstractClient out of memory\n");</span>
00190     <span class="keywordflow">return</span>;
00191   }
00192   <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[0] = 0;
00193 
00194   sendBuffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[buflen];
00195   <span class="keywordflow">if</span> (!sendBuffer) {
00196     <a class="code" href="classUAbstractClient.html#p3">rc</a> = -1;
00197     <span class="comment">//printf("UAbstractClient::UAbstractClient out of memory\n");</span>
00198     <span class="keywordflow">return</span>;
00199   }
00200   sendBuffer[0] = 0;
00201  
00202 
00203 }
00204 
00205 UAbstractClient::~UAbstractClient()
00206 {
00207   <span class="keywordflow">if</span> (host) <span class="keyword">delete</span> host;
00208   <span class="keywordflow">if</span> (recvBuffer) <span class="keyword">delete</span> recvBuffer;
00209 }
00210 
00214 <span class="keywordtype">int</span>
<a name="l00215"></a><a class="code" href="classUAbstractClient.html#a7">00215</a> <a class="code" href="classUAbstractClient.html#a7">UAbstractClient::startPack</a>()
00216 {
00217   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00218   <span class="keywordflow">return</span> 0;
00219 }
00220 
00221 <span class="keywordtype">int</span>
<a name="l00222"></a><a class="code" href="classUAbstractClient.html#a8">00222</a> <a class="code" href="classUAbstractClient.html#a8">UAbstractClient::endPack</a>()
00223 {
00224   <span class="keywordtype">int</span> retval = <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, strlen(sendBuffer));
00225   sendBuffer[0] = 0;
00226   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00227   <span class="keywordflow">return</span> retval;
00228 }
00229 
00230 
00233 <span class="keywordtype">int</span>
<a name="l00234"></a><a class="code" href="classUAbstractClient.html#a4">00234</a> <a class="code" href="classUAbstractClient.html#a3">UAbstractClient::send</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *command, ...)
00235 {
00236   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00237   va_list arg;
00238   va_start(arg, command);
00239   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00240   <a class="code" href="classUAbstractClient.html#p3">rc</a> = <a class="code" href="classUAbstractClient.html#a10">vpack</a>(command, arg);
00241   va_end(arg);
00242   <span class="keywordflow">if</span> (<a class="code" href="classUAbstractClient.html#p3">rc</a> &lt; 0) {
00243     <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00244     <span class="keywordflow">return</span> (rc);
00245   }
00246   <a class="code" href="classUAbstractClient.html#p3">rc</a> = <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, strlen(sendBuffer));
00247   sendBuffer[0] = 0;
00248   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00249   <span class="keywordflow">return</span> rc;
00250 }
00251 
00256 <span class="keywordtype">int</span> 
<a name="l00257"></a><a class="code" href="classUAbstractClient.html#a9">00257</a> <a class="code" href="classUAbstractClient.html#a9">UAbstractClient::pack</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *command, ...)
00258 {
00259   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00260   va_list arg;
00261   va_start(arg, command);
00262   <a class="code" href="classUAbstractClient.html#p3">rc</a>=<a class="code" href="classUAbstractClient.html#a10">vpack</a>(command, arg);
00263   va_end(arg);
00264   <span class="keywordflow">return</span> rc;
00265 }
00266 
00267 
00268 <span class="keywordtype">int</span> 
<a name="l00269"></a><a class="code" href="classUAbstractClient.html#a10">00269</a> <a class="code" href="classUAbstractClient.html#a10">UAbstractClient::vpack</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *command, va_list arg)
00270 {
00271   <span class="comment">//expand</span>
00272   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00273 <span class="preprocessor">#ifndef WIN32</span>
00274 <span class="preprocessor"></span>  <span class="keywordtype">int</span> size = vsnprintf(NULL, 0, command, arg);
00275   <span class="keywordflow">if</span> (strlen(sendBuffer) + size + 1 &gt; buflen)
00276     <span class="keywordflow">return</span> (-1);
00277   <span class="keywordflow">else</span> {
00278 <span class="preprocessor">#endif</span>
00279 <span class="preprocessor"></span>    <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00280     vsprintf(&amp;sendBuffer[strlen(sendBuffer)], command, arg);
00281     <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00282     <span class="keywordflow">return</span> (0);
00283 <span class="preprocessor">#ifndef WIN32</span>
00284 <span class="preprocessor"></span>  }
00285 <span class="preprocessor">#endif</span>
00286 <span class="preprocessor"></span>}
00287 
00288 
00289 <span class="keywordtype">int</span> 
<a name="l00290"></a><a class="code" href="classUAbstractClient.html#a11">00290</a> <a class="code" href="classUAbstractClient.html#a11">UAbstractClient::sendFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00291 {
00292   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00293   FILE *fd;
00294   fd = fopen(name, <span class="stringliteral">"r"</span>);
00295   <span class="keywordflow">if</span> (fd == NULL)
00296     <span class="keywordflow">return</span> (-1);
00297   <span class="keywordtype">int</span> size;     
00298   <span class="keyword">struct </span>stat s;
00299   stat(name, &amp;s);
00300   size = s.st_size;
00301   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00302   <span class="keywordflow">if</span> (!<a class="code" href="classUAbstractClient.html#b2">canSend</a>(size)) {
00303         <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00304         <span class="keywordflow">return</span> -1;
00305   }
00306 
00307   <span class="keywordflow">while</span> (!feof(fd)) {
00308     <span class="keywordtype">int</span> res = fread( sendBuffer, 1, <a class="code" href="classUAbstractClient.html#p2">buflen</a>, fd);
00309         <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, res);
00310   }
00311   fclose(fd);
00312   sendBuffer[0] = 0;
00313   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00314   <span class="keywordflow">return</span> 0;
00315 }
00316 
00317 
00318 <span class="keywordtype">int</span> 
<a name="l00319"></a><a class="code" href="classUAbstractClient.html#a5">00319</a> <a class="code" href="classUAbstractClient.html#a5">UAbstractClient::sendBin</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keywordtype">int</span> len)
00320 {
00321   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#a5">sendBin</a>(buffer, len, NULL, 0);
00322 }
00323 
00324 
00325 <span class="keywordtype">int</span> 
<a name="l00326"></a><a class="code" href="classUAbstractClient.html#a6">00326</a> <a class="code" href="classUAbstractClient.html#a5">UAbstractClient::sendBin</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keywordtype">int</span> len, 
00327                              <span class="keyword">const</span> <span class="keywordtype">char</span> *header, ...)
00328 {
00329   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> -1;
00330   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00331   <span class="keywordflow">if</span> (header) {
00332     va_list arg;
00333     va_start(arg, header);
00334     <a class="code" href="classUAbstractClient.html#a10">vpack</a>(header, arg);
00335     va_end(arg);
00336         <span class="keywordflow">if</span> (!<a class="code" href="classUAbstractClient.html#b2">canSend</a>(strlen(sendBuffer) + len)) {
00337           <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00338           <span class="keywordflow">return</span> -1;
00339         }
00340 
00341         <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, strlen(sendBuffer));
00342   }
00343 
00344   <span class="keywordtype">int</span> res = <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(buffer, len);
00345   sendBuffer[0] = 0;
00346   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00347   <span class="keywordflow">return</span> res;
00348 }
00349 
00350 <span class="keyword">struct </span>sendSoundData {
00351   <span class="keywordtype">char</span> * buffer;
00352   <span class="keywordtype">int</span> bytespersec;
00353   <span class="keywordtype">int</span> length;
00354   <span class="keywordtype">int</span> pos;
00355   <span class="keywordtype">char</span> * device;
00356   <span class="keywordtype">char</span> * tag;
00357   <span class="keywordtype">char</span> formatString[50];
00358   USoundFormat format;
00359   <a class="code" href="classUAbstractClient.html">UAbstractClient</a> * uc;
00360   <span class="keywordtype">bool</span> startNotify;
00361 };
00362 
00363 <span class="keyword">struct </span>wavheader {
00364         <span class="keywordtype">char</span> riff[4];
00365         <span class="keywordtype">int</span> length;
00366         <span class="keywordtype">char</span> wave[4];
00367         <span class="keywordtype">char</span> fmt[4];
00368         <span class="keywordtype">int</span> lnginfo;
00369         <span class="keywordtype">short</span> one;
00370         <span class="keywordtype">short</span> channels;
00371         <span class="keywordtype">int</span> freqechant;
00372         <span class="keywordtype">int</span> bytespersec;
00373         <span class="keywordtype">short</span> bytesperechant;
00374         <span class="keywordtype">short</span> bitperchannel;
00375         <span class="keywordtype">char</span> data[4];
00376         <span class="keywordtype">int</span> datalength;
00377   };
00378 
00379  <span class="keyword">static</span> <a class="code" href="uabstractclient_8h.html#a47">UCallbackAction</a> sendSound_(<span class="keywordtype">void</span> * cb, <span class="keyword">const</span> <a class="code" href="classUMessage.html">UMessage</a> &amp;msg) {
00380   <span class="comment">//the idea is to cut the sound into small chunks,</span>
00381   <span class="comment">//add a header and send each chunk separately</span>
00382   <span class="comment">//create the header.</span>
00383    <span class="comment">// printf("sound message: %s %d\n", msg.systemValue, msg.type);</span>
00384   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> CHUNK_SIZE = 32 * 8*60;
00385   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> SUBCHUNK_SIZE = CHUNK_SIZE; <span class="comment">//1024;</span>
00386   
00387 
00388    sendSoundData *s=(sendSoundData *)cb;
00389    <span class="comment">/*</span>
00390 <span class="comment">   if (msg.type != MESSAGE_SYSTEM)</span>
00391 <span class="comment">     return URBI_CONTINUE;</span>
00392 <span class="comment">   if (strstr(msg.systemValue,"start") &amp;&amp; s-&gt;startNotify==false) {</span>
00393 <span class="comment">     s-&gt;startNotify = true;</span>
00394 <span class="comment">     s-&gt;uc-&gt;notifyCallbacks(UMessage(*s-&gt;uc, 0,s-&gt;tag, "*** start"));</span>
00395 <span class="comment">   }</span>
00396 <span class="comment">   if (!strstr(msg.systemValue,"stop"))</span>
00397 <span class="comment">     return URBI_CONTINUE;</span>
00398 <span class="comment">   */</span>
00399 <span class="comment">/*wavheader wh = { </span>
00400 <span class="comment">        {'R','I','F','F'}, </span>
00401 <span class="comment">        44-8, </span>
00402 <span class="comment">        {'W','A','V','E'},</span>
00403 <span class="comment">        {'f','m','t',' '},</span>
00404 <span class="comment">        16,1,1, 16000, 32000, 2, 16, </span>
00405 <span class="comment">        {'d','a','t','a'},</span>
00406 <span class="comment">        0}; // no comment...</span>
00407 <span class="comment"> */</span>
00408   <span class="comment">//handle next chunk </span>
00409  <span class="keywordflow">if</span> (s-&gt;format == SOUND_WAV &amp;&amp; s-&gt;pos==0)
00410    s-&gt;pos = <span class="keyword">sizeof</span>(wavheader);
00411   <span class="keywordtype">int</span> tosend = (s-&gt;length-s-&gt;pos &gt; CHUNK_SIZE) ? CHUNK_SIZE:s-&gt;length-s-&gt;pos;
00412  
00413   <span class="comment">//printf("%d start chunk of size %d at offset %d\n", 0,tosend,s-&gt;pos);</span>
00414   <span class="keywordtype">int</span> playlength = tosend *1000 / s-&gt;bytespersec;
00415   s-&gt;uc-&gt;send(<span class="stringliteral">"%s.val = BIN %d %s %s;"</span>, 
00416               s-&gt;device,
00417               tosend+ ((s-&gt;format == SOUND_WAV)?<span class="keyword">sizeof</span>(wavheader):0), 
00418               (s-&gt;format == SOUND_WAV)?<span class="stringliteral">"wav"</span>:<span class="stringliteral">"raw"</span>,
00419               s-&gt;formatString
00420               );
00421   <span class="keywordflow">if</span> (s-&gt;format == SOUND_WAV) {
00422     wavheader wh;
00423     memcpy(&amp;wh, s-&gt;buffer, <span class="keyword">sizeof</span>(wh));
00424     wh.datalength=tosend;
00425     wh.length=tosend+44-8;
00426     s-&gt;uc-&gt;sendBin(&amp;wh, <span class="keyword">sizeof</span>(wavheader));
00427   }
00428  
00429 
00430 
00431   <span class="comment">/* this appears to be useless</span>
00432 <span class="comment">  int msecpause=((SUBCHUNK_SIZE/32)*10)/14;</span>
00433 <span class="comment">  int spos=0;</span>
00434 <span class="comment">  while (spos!=tosend) {</span>
00435 <span class="comment">        int ts = SUBCHUNK_SIZE;</span>
00436 <span class="comment">        if (ts&gt;tosend-spos) ts=tosend-spos;</span>
00437 <span class="comment">        printf("%d chunk\n",mtime());</span>
00438 <span class="comment">        s-&gt;uc-&gt;sendBin(s-&gt;buffer, ts);</span>
00439 <span class="comment">        s-&gt;buffer+=ts;</span>
00440 <span class="comment">        spos+=ts;</span>
00441 <span class="comment">          usleep(msecpause);</span>
00442 <span class="comment">  }</span>
00443 <span class="comment">  */</span>
00444 
00445   s-&gt;uc-&gt;sendBin(s-&gt;buffer+s-&gt;pos, tosend);
00446    s-&gt;uc-&gt;send(<span class="stringliteral">"wait(%s.remain &lt; %d); %s: ping;"</span>, s-&gt;device, playlength/2, msg.<a class="code" href="classUMessage.html#o2">tag</a>);
00447   <span class="comment">// printf("%d end sending chunk\n", 0);</span>
00448   s-&gt;pos+=tosend;
00449   <span class="keywordflow">if</span> (s-&gt;pos &gt;= s-&gt;length ) {
00450     
00451     <span class="comment">//printf("over: %d %d\n",URBI_REMOVE,URBI_CONTINUE);</span>
00452     <span class="keywordflow">if</span> (s-&gt;tag &amp;&amp; s-&gt;tag[0]) 
00453       s-&gt;uc-&gt;notifyCallbacks(<a class="code" href="classUMessage.html">UMessage</a>(*s-&gt;uc, 0,s-&gt;tag, <span class="stringliteral">"*** stop"</span>));
00454     free(s-&gt;buffer);
00455     free(s-&gt;tag);
00456     free(s-&gt;device);
00457     <span class="keyword">delete</span> s;
00458     <span class="keywordflow">return</span> URBI_REMOVE;
00459   }
00460   <span class="keywordflow">return</span> URBI_CONTINUE;
00461 }
00462 
00468 <span class="keywordtype">int</span> 
<a name="l00469"></a><a class="code" href="classUAbstractClient.html#a14">00469</a> <a class="code" href="classUAbstractClient.html#a14">UAbstractClient::sendSound</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * device, <span class="keyword">const</span> <a class="code" href="classUSound.html">USound</a> &amp;sound, <span class="keyword">const</span> <span class="keywordtype">char</span> *tag) {
00470   
00471   <span class="keywordflow">if</span> (sound.<a class="code" href="classUSound.html#o5">soundFormat</a> ==  SOUND_MP3) {
00472     <span class="comment">//we don't handle chunkuing for this format</span>
00473     <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#a5">sendBin</a>(sound.<a class="code" href="classUSound.html#o0">data</a>, sound.<a class="code" href="classUSound.html#o1">size</a>, <span class="stringliteral">"%s +report:  %s.val = BIN %d mp3;"</span>, tag, device, sound.<a class="code" href="classUSound.html#o1">size</a>);
00474   }
00475   <span class="keywordflow">if</span> (sound.<a class="code" href="classUSound.html#o5">soundFormat</a> ==  SOUND_OGG) {
00476     <span class="comment">//we don't handle chunkuing for this format</span>
00477     <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#a5">sendBin</a>(sound.<a class="code" href="classUSound.html#o0">data</a>, sound.<a class="code" href="classUSound.html#o1">size</a>, <span class="stringliteral">"%s +report:  %s.val = BIN %d ogg;"</span>, tag, device, sound.<a class="code" href="classUSound.html#o1">size</a>);
00478  }
00479 
00480   <span class="keywordflow">if</span> (sound.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV || sound.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_RAW) {
00481     sendSoundData *s=<span class="keyword">new</span> sendSoundData();
00482     <span class="keywordtype">char</span> utag[16];
00483     <a class="code" href="classUAbstractClient.html#a29">makeUniqueTag</a>(utag);
00484     s-&gt;bytespersec = sound.<a class="code" href="classUSound.html#o2">channels</a> * sound.<a class="code" href="classUSound.html#o3">rate</a> * (sound.<a class="code" href="classUSound.html#o4">sampleSize</a>/8);
00485     s-&gt;uc=<span class="keyword">this</span>;
00486     s-&gt;buffer = (<span class="keywordtype">char</span> *)malloc(sound.<a class="code" href="classUSound.html#o1">size</a>);
00487     memcpy(s-&gt;buffer, sound.<a class="code" href="classUSound.html#o0">data</a>, sound.<a class="code" href="classUSound.html#o1">size</a>);
00488     s-&gt;length=sound.<a class="code" href="classUSound.html#o1">size</a>;
00489     s-&gt;tag=strdup(tag);
00490     s-&gt;device = strdup(device);
00491     s-&gt;pos=0;
00492     s-&gt;format = sound.<a class="code" href="classUSound.html#o5">soundFormat</a>;
00493     <span class="keywordflow">if</span> ( sound.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_RAW)
00494       sprintf(s-&gt;formatString,<span class="stringliteral">"%d %d %d %d"</span>, sound.<a class="code" href="classUSound.html#o2">channels</a>, sound.<a class="code" href="classUSound.html#o3">rate</a>, sound.<a class="code" href="classUSound.html#o4">sampleSize</a>, (<span class="keywordtype">int</span>)sound.<a class="code" href="classUSound.html#o6">sampleFormat</a>);
00495     <span class="keywordflow">else</span>
00496       s-&gt;formatString[0] = 0;
00497     s-&gt;startNotify = <span class="keyword">false</span>;
00498     UCallbackID cid=<a class="code" href="classUAbstractClient.html#a17">setCallback</a>(sendSound_, s,utag);
00499     <span class="comment">//invoke it 2 times to queue sound</span>
00500     <span class="keywordflow">if</span> (sendSound_(s,<a class="code" href="classUMessage.html">UMessage</a>(*<span class="keyword">this</span>, 0, utag,<span class="stringliteral">"*** stop"</span>))==URBI_CONTINUE) {
00501       <span class="keywordflow">if</span> ( sendSound_(s,<a class="code" href="classUMessage.html">UMessage</a>(*<span class="keyword">this</span>, 0, utag,<span class="stringliteral">"*** stop"</span>))==URBI_REMOVE) {
00502         <a class="code" href="classUAbstractClient.html#a28">deleteCallback</a>(cid);
00503         }
00504     }
00505     <span class="keywordflow">else</span> 
00506       <a class="code" href="classUAbstractClient.html#a28">deleteCallback</a>(cid);
00507     <span class="keywordflow">return</span> 0;
00508   }
00509   <span class="comment">//unrecognized format</span>
00510   <span class="keywordflow">return</span> 1;
00511 }
00512 
00513 UCallbackID 
<a name="l00514"></a><a class="code" href="classUAbstractClient.html#a20">00514</a> <a class="code" href="classUAbstractClient.html#a17">UAbstractClient::setCallback</a>(UCallback cb, <span class="keyword">const</span> <span class="keywordtype">char</span> *tag)
00515 {
00516   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#b5">addCallback</a>(tag, *<span class="keyword">new</span> UCallbackWrapperCB(cb));
00517 }
00518 
00519 UCallbackID 
<a name="l00520"></a><a class="code" href="classUAbstractClient.html#a21">00520</a> <a class="code" href="classUAbstractClient.html#a17">UAbstractClient::setCallback</a>(UCustomCallback cb, <span class="keywordtype">void</span> *cbData, <span class="keyword">const</span> <span class="keywordtype">char</span> *tag)
00521 {
00522   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#b5">addCallback</a>(tag, *<span class="keyword">new</span> UCallbackWrapperCCB(cb, cbData));
00523 }
00524 
00527 <span class="keywordtype">int</span>
<a name="l00528"></a><a class="code" href="classUAbstractClient.html#a27">00528</a> <a class="code" href="classUAbstractClient.html#a27">UAbstractClient::getAssociatedTag</a>(UCallbackID <span class="keywordtype">id</span>, <span class="keywordtype">char</span> * tag) {
00529  <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00530   list&lt;UCallbackInfo&gt;:: iterator it = find(callbackList.begin(), callbackList.end(), id);
00531   <span class="keywordflow">if</span> (it == callbackList.end()) {
00532     <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00533     <span class="keywordflow">return</span> 0;
00534   }
00535   strcpy(tag, it-&gt;tag);
00536   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00537   <span class="keywordflow">return</span> 1;
00538 }
00539 
00540 
00543 <span class="keywordtype">int</span> 
<a name="l00544"></a><a class="code" href="classUAbstractClient.html#a28">00544</a> <a class="code" href="classUAbstractClient.html#a28">UAbstractClient::deleteCallback</a>(UCallbackID callbackID)
00545 {
00546   <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00547   list&lt;UCallbackInfo&gt;:: iterator it = find(callbackList.begin(), callbackList.end(), callbackID);
00548   <span class="keywordflow">if</span> (it == callbackList.end()) {
00549     <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00550     <span class="keywordflow">return</span> 0;
00551   }
00552   <span class="keyword">delete</span> &amp;(it-&gt;callback);
00553   callbackList.erase(it);
00554   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00555   <span class="keywordflow">return</span> 1;
00556 }
00557 
00558 UCallbackID 
<a name="l00559"></a><a class="code" href="classUAbstractClient.html#a12">00559</a> <a class="code" href="classUAbstractClient.html#a12">UAbstractClient::sendCommand</a>(UCallback cb, <span class="keyword">const</span> <span class="keywordtype">char</span> *cmd, ...)
00560 {
00561   <span class="keywordtype">char</span> tag[16];
00562   <a class="code" href="classUAbstractClient.html#a29">makeUniqueTag</a>(tag);
00563   <span class="keywordtype">char</span> *mcmd = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(cmd) + strlen(tag) + 5];
00564   sprintf(mcmd,<span class="stringliteral">"%s: %s"</span>,tag,cmd);
00565   UCallbackID cid = <a class="code" href="classUAbstractClient.html#a17">setCallback</a>(cb, tag);
00566   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00567   va_list arg;
00568   va_start(arg, cmd);
00569   <a class="code" href="classUAbstractClient.html#a10">vpack</a>(mcmd, arg);
00570   va_end(arg);
00571   <span class="keywordtype">int</span> retval = <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, strlen(sendBuffer));
00572   sendBuffer[0] = 0;
00573   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00574   <span class="keyword">delete</span> []  mcmd;
00575   <span class="keywordflow">if</span> (retval) {
00576         <a class="code" href="classUAbstractClient.html#a28">deleteCallback</a>(cid);
00577         <span class="keywordflow">return</span> UINVALIDCALLBACKID;
00578   }
00579   <span class="keywordflow">return</span> cid;
00580 }
00581 
00582 UCallbackID 
<a name="l00583"></a><a class="code" href="classUAbstractClient.html#a13">00583</a> <a class="code" href="classUAbstractClient.html#a12">UAbstractClient::sendCommand</a>(UCustomCallback cb, <span class="keywordtype">void</span> *cbData, 
00584                              <span class="keyword">const</span> <span class="keywordtype">char</span> *cmd,...)
00585 {
00586   <span class="keywordtype">char</span> tag[16];
00587   <a class="code" href="classUAbstractClient.html#a29">makeUniqueTag</a>(tag);
00588   <span class="keywordtype">char</span> *mcmd = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(cmd) + strlen(tag) + 10];
00589   sprintf(mcmd,<span class="stringliteral">"%s: %s"</span>,tag,cmd);
00590   UCallbackID cid = <a class="code" href="classUAbstractClient.html#a17">setCallback</a>(cb, cbData, tag);
00591   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00592   va_list arg;
00593   va_start(arg, cmd);
00594   <a class="code" href="classUAbstractClient.html#a10">vpack</a>(mcmd, arg);
00595   va_end(arg);
00596   <span class="keywordtype">int</span> retval = <a class="code" href="classUAbstractClient.html#b1">effectiveSend</a>(sendBuffer, strlen(sendBuffer));
00597   sendBuffer[0] = 0;
00598   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00599   <span class="keyword">delete</span> []mcmd;
00600   <span class="keywordflow">if</span> (retval) {
00601         <a class="code" href="classUAbstractClient.html#a28">deleteCallback</a>(cid);
00602         <span class="keywordflow">return</span> UINVALIDCALLBACKID;
00603   }
00604   <span class="keywordflow">return</span> cid;
00605 
00606 }
00607 
00608 <span class="keywordtype">int</span> 
<a name="l00609"></a><a class="code" href="classUAbstractClient.html#a15">00609</a> <a class="code" href="classUAbstractClient.html#a15">UAbstractClient::putFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * localName, <span class="keyword">const</span> <span class="keywordtype">char</span> * remoteName) {
00610   <span class="keywordtype">int</span> len;
00611   <span class="keyword">struct </span>stat st;
00612   <span class="keywordflow">if</span> (stat(localName,&amp;st) == -1) <span class="keywordflow">return</span> 1;
00613   len = st.st_size;
00614   <a class="code" href="classUAbstractClient.html#a33">lockSend</a>();
00615   <span class="keywordflow">if</span> (!<a class="code" href="classUAbstractClient.html#b2">canSend</a>(len+strlen(remoteName)+ 20)) {
00616         <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00617         <span class="keywordflow">return</span> -1;
00618   }
00619 
00620   <span class="keywordflow">if</span> (!remoteName) remoteName = localName;
00621   <a class="code" href="classUAbstractClient.html#a3">send</a>(<span class="stringliteral">"save(\"%s\", \""</span>,remoteName);
00622   <span class="keywordtype">int</span> res = <a class="code" href="classUAbstractClient.html#a11">sendFile</a>(localName);
00623   <a class="code" href="classUAbstractClient.html#a3">send</a>(<span class="stringliteral">"\");"</span>);
00624   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00625   <span class="keywordflow">return</span> res;
00626 }
00627 
00628 <span class="keywordtype">int</span> 
<a name="l00629"></a><a class="code" href="classUAbstractClient.html#a16">00629</a> <a class="code" href="classUAbstractClient.html#a15">UAbstractClient::putFile</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * buffer, <span class="keywordtype">int</span> length, 
00630                          <span class="keyword">const</span> <span class="keywordtype">char</span> * remoteName) {
00631   <span class="keywordflow">if</span> (!<a class="code" href="classUAbstractClient.html#b2">canSend</a>(length+strlen(remoteName)+ 20)) {
00632         <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00633         <span class="keywordflow">return</span> -1;
00634   }
00635   <a class="code" href="classUAbstractClient.html#a3">send</a>(<span class="stringliteral">"save(\"%s\", \""</span>,remoteName);
00636   <a class="code" href="classUAbstractClient.html#a5">sendBin</a>(buffer,length);
00637   <a class="code" href="classUAbstractClient.html#a3">send</a>(<span class="stringliteral">"\");"</span>);
00638   <a class="code" href="classUAbstractClient.html#a34">unlockSend</a>();
00639   <span class="keywordflow">return</span> 0;
00640 }
00641 
00642 <span class="keywordtype">void</span>
<a name="l00643"></a><a class="code" href="classUAbstractClient.html#a29">00643</a> <a class="code" href="classUAbstractClient.html#a29">UAbstractClient::makeUniqueTag</a>(<span class="keywordtype">char</span> *tag)
00644 {
00645   sprintf(tag, <span class="stringliteral">"URBI_%d"</span>, ++uid);
00646   <span class="keywordflow">return</span>;
00647 }
00648 
00653 <span class="keywordtype">void</span> 
<a name="l00654"></a><a class="code" href="classUAbstractClient.html#b0">00654</a> <a class="code" href="classUAbstractClient.html#b0">UAbstractClient::processRecvBuffer</a>()
00655 {
00656   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
00657 
00658         <span class="keywordflow">if</span> (binaryBuffer) {
00659           
00660           <span class="comment">//Receiving binary. Append to binaryBuffer;</span>
00661           <span class="keywordtype">int</span> len = min( <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - endOfHeaderPosition, 
00662                      binaryBufferLength - binaryBufferPosition);
00663           memcpy( (<span class="keywordtype">char</span> *)binaryBuffer + binaryBufferPosition, 
00664               <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a> + endOfHeaderPosition, len);
00665           binaryBufferPosition += len;
00666           
00667           <span class="keywordflow">if</span> (binaryBufferPosition == binaryBufferLength) {
00668                 <span class="comment">//Finished receiving binary.</span>
00669                 <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00670         <a class="code" href="classUMessage.html">UMessage</a> msg(*<span class="keyword">this</span>, currentTimestamp, currentTag, currentCommand,
00671                      binaryBuffer, binaryBufferLength);
00672                 <a class="code" href="classUAbstractClient.html#a30">notifyCallbacks</a>(msg); 
00673                 <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00674                 free(binaryBuffer);
00675                 binaryBuffer = 0;
00676                 
00677                 <span class="comment">//Move the extra we received</span>
00678                 memmove(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, 
00679                 <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a> + endOfHeaderPosition + len,  
00680                 <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - len - endOfHeaderPosition);
00681                 <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - len - endOfHeaderPosition;
00682                 
00683                 <span class="comment">//Reenter loop.</span>
00684                 <span class="keywordflow">continue</span>;
00685           }
00686           <span class="keywordflow">else</span> {
00687                 <span class="comment">//Not finished receiving binary.</span>
00688                 <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = endOfHeaderPosition;
00689                 <span class="keywordflow">return</span>;
00690           }
00691         }
00692         <span class="keywordflow">else</span> {
00693           <span class="comment">//Not in binary mode.</span>
00694           <span class="keywordtype">char</span> *endline = (<span class="keywordtype">char</span> *) memchr(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, <span class="charliteral">'\n'</span>, <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a>);
00695           <span class="keywordflow">if</span> (!endline) <span class="keywordflow">return</span>;
00696           *endline = 0;
00697           
00698           <span class="comment">//parse the line</span>
00699 <span class="preprocessor">#if DEBUG</span>
00700 <span class="preprocessor"></span>                <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"%d parse line: --%s--\n"</span>, mtime(), <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>);
00701 <span class="preprocessor">#endif</span>
00702 <span class="preprocessor"></span>          <span class="keywordtype">int</span> found = sscanf(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, <span class="stringliteral">"[%d:%64[A-Za-z0-9_]]"</span>, 
00703                          &amp;currentTimestamp, currentTag);
00704           <span class="keywordflow">if</span> (found != 2) {
00705                 found = sscanf(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, <span class="stringliteral">"[%d]"</span>, &amp;currentTimestamp);
00706                 <span class="keywordflow">if</span> (found == 1)
00707                   currentTag[0] = 0;
00708                 <span class="keywordflow">else</span> {  <span class="comment">//failure</span>
00709                   <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"UAbstractClient::read, fatal error parsing header"</span>);
00710                   <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">" line was %s\n"</span>, <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>);
00711                   currentTimestamp = 0;
00712                   strcpy(currentTag, <span class="stringliteral">"UNKNWN"</span>);
00713                   <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00714                   <a class="code" href="classUMessage.html">UMessage</a> msg(*<span class="keyword">this</span>, 0, URBI_ERROR_TAG, 
00715                                <span class="stringliteral">"!!! UAbstractClient::read, fatal error parsing header"</span>, 
00716                                0, 0);
00717                   <a class="code" href="classUAbstractClient.html#a30">notifyCallbacks</a>(msg);
00718                   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00719                 }
00720           }
00721           
00722           currentCommand = strstr(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, <span class="stringliteral">"]"</span>);
00723           <span class="keywordflow">if</span> (!currentCommand) {
00724                 currentCommand = recvBuffer;
00725                 currentCommand--;
00726           }     <span class="comment">//XXX DEBUG</span>
00727           currentCommand++;
00728           
00729           <span class="comment">//is this binary?</span>
00730           <span class="keywordtype">char</span> * mark=currentCommand;
00731       <span class="keywordflow">while</span> (*mark==<span class="charliteral">' '</span>) mark++;
00732           <span class="keywordflow">if</span> (!strncmp(mark, <span class="stringliteral">"BIN "</span>,4)) {
00733                 <span class="comment">//get the length</span>
00734                 <span class="keywordtype">char</span> * endLength;
00735                 binaryBufferLength = strtol(&amp;mark[4], &amp;endLength, 0);
00736                 <span class="keywordflow">if</span> (endLength == &amp;mark[4]) {
00737                   <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"UClient::read, error parsing bin data length.\n"</span>);
00738                   <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = 0;
00739                   <span class="keywordflow">return</span>;
00740                 }
00741 <span class="preprocessor">#if DEBUG</span>
00742 <span class="preprocessor"></span>        <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"%d bin data: %d\n"</span>, mtime(), binaryBufferLength);
00743 <span class="preprocessor">#endif</span>
00744 <span class="preprocessor"></span>                
00745                 <span class="comment">//Check if we have the whole binary.</span>
00746                 <span class="keywordflow">if</span> (binaryBufferLength &lt; <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - strlen(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>) - 1) {
00747           <span class="comment">//got eveything?</span>
00748                   <span class="keywordflow">if</span> (DEBUG)
00749                         <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"one shot hit!\n"</span>);
00750                   <span class="comment">//now update structures and notify listeners </span>
00751                   <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00752           <a class="code" href="classUMessage.html">UMessage</a> msg(*<span class="keyword">this</span>, currentTimestamp, currentTag, 
00753                        currentCommand, 
00754                        &amp;endline[1], binaryBufferLength);
00755                   <a class="code" href="classUAbstractClient.html#a30">notifyCallbacks</a>(msg);
00756                   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00757                   
00758                   <span class="comment">//Move the extra we received.</span>
00759                   memmove(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, 
00760                   &amp;endline[1 + binaryBufferLength], 
00761                   (<span class="keywordtype">int</span>) &amp;<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[<a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a>] - 
00762                   (<span class="keywordtype">int</span>) &amp;endline[1 + binaryBufferLength]);
00763                   <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = (int) &amp;<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[recvBufferPosition] - 
00764             (int) &amp;endline[1 + binaryBufferLength];
00765                   <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[recvBufferPosition] = 0;
00766                   <span class="comment">//Reenter loop.</span>
00767                   <span class="keywordflow">continue</span>;
00768                 }
00769                 
00770                 <span class="keywordflow">else</span> {  
00771                   <span class="comment">//We don t have the whole binary data. Copy what we have.</span>
00772                   binaryBuffer = (<span class="keywordtype">char</span> *) malloc(binaryBufferLength);
00773                   memcpy(binaryBuffer, 
00774                  &amp;endline[1], 
00775                  <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - strlen(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>) - 1);
00776                   binaryBufferPosition = <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> - strlen(recvBuffer) - 1;
00777                   endOfHeaderPosition =  strlen(recvBuffer) + 1;
00778                   <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = endOfHeaderPosition;
00779                   <span class="keywordflow">return</span>;
00780                 }
00781           }
00782           <span class="keywordflow">else</span> {        
00783                 <span class="comment">//Not binary.</span>
00784                 <span class="comment">//now update structures and notify listeners </span>
00785 <span class="preprocessor">#if DEBUG</span>
00786 <span class="preprocessor"></span>                  <a class="code" href="classUAbstractClient.html#a31">printf</a>(<span class="stringliteral">"%d notify\n"</span>, mtime());
00787 <span class="preprocessor">#endif</span>
00788 <span class="preprocessor"></span>                <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00789         <a class="code" href="classUMessage.html">UMessage</a> msg(*<span class="keyword">this</span>, currentTimestamp, currentTag, 
00790                        currentCommand, 
00791                      NULL, 0);
00792         <a class="code" href="classUAbstractClient.html#a30">notifyCallbacks</a>(msg);
00793                 <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00794                 <span class="comment">//prepare for next read, copy the extra</span>
00795                 <span class="keywordtype">int</span> len = (int) &amp;<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[recvBufferPosition] - (int) &amp;endline[1];
00796                 memmove(<a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>, &amp;endline[1], len);  <span class="comment">//copy beginning of next cmd</span>
00797                 <a class="code" href="classUAbstractClient.html#p5">recvBufferPosition</a> = len;
00798                 <a class="code" href="classUAbstractClient.html#p4">recvBuffer</a>[recvBufferPosition] = 0;
00799           }
00800         }
00801   }<span class="comment">// end while</span>
00802 }
00803 
<a name="l00804"></a><a class="code" href="classUAbstractClient.html#a19">00804</a> UCallbackID <a class="code" href="classUAbstractClient.html#a19">UAbstractClient::setWildcardCallback</a>(UCallbackWrapper &amp; callback) {
00805   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#b5">addCallback</a>(URBI_WILDCARD_TAG, callback);
00806 }
00807 
<a name="l00808"></a><a class="code" href="classUAbstractClient.html#a18">00808</a> UCallbackID <a class="code" href="classUAbstractClient.html#a18">UAbstractClient::setErrorCallback</a>(UCallbackWrapper &amp; callback) {
00809   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#b5">addCallback</a>(URBI_ERROR_TAG, callback);
00810 }
<a name="l00811"></a><a class="code" href="classUAbstractClient.html#a17">00811</a> UCallbackID <a class="code" href="classUAbstractClient.html#a17">UAbstractClient::setCallback</a>(UCallbackWrapper &amp; callback, <span class="keyword">const</span> <span class="keywordtype">char</span> * tag) {
00812   <span class="keywordflow">return</span> <a class="code" href="classUAbstractClient.html#b5">addCallback</a>(tag, callback);
00813 }
<a name="l00814"></a><a class="code" href="classUAbstractClient.html#b5">00814</a> UCallbackID <a class="code" href="classUAbstractClient.html#b5">UAbstractClient::addCallback</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tag, UCallbackWrapper &amp;w) {
00815   <a class="code" href="classUAbstractClient.html#b3">lockList</a>();
00816   UCallbackInfo ci(w);
00817   strncpy(ci.tag, tag, URBI_MAX_TAG_LENGTH-1);
00818   ci.<a class="code" href="classUMessage.html#o2">tag</a>[URBI_MAX_TAG_LENGTH-1]=0;
00819   ci.id = ++nextId;
00820   callbackList.push_front(ci);
00821   <a class="code" href="classUAbstractClient.html#b4">unlockList</a>();
00822   <span class="keywordflow">return</span> ci.id;
00823 }
00824 
00825 
00826 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> clamp(<span class="keywordtype">float</span> v)
00827 {
00828   <span class="keywordflow">if</span> (v &lt; 0)
00829     <span class="keywordflow">return</span> 0;
00830   <span class="keywordflow">if</span> (v &gt; 255)
00831     <span class="keywordflow">return</span> 255;
00832   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> char) v;
00833 }
00834 
00835 <span class="keywordtype">int</span> 
00836 convertYCrCbtoRGB(<span class="keyword">const</span> byte * sourceImage, 
00837                   <span class="keywordtype">int</span> bufferSize, 
00838                   byte * destinationImage)
00839 {
00840   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) sourceImage;
00841   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) destinationImage;
00842   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bufferSize - 2; i += 3) {
00843     <span class="keywordtype">float</span> y = in[i];
00844     <span class="keywordtype">float</span> cb = in[i + 1];
00845     <span class="keywordtype">float</span> cr = in[i + 2];
00846     <span class="comment">/*</span>
00847 <span class="comment">       out[i+2]=clamp(y+1.403*cb);</span>
00848 <span class="comment">       out[i+1]=clamp(y-0.344*cr-0.714*cb);</span>
00849 <span class="comment">       out[i]=clamp(y+1.77*cr);</span>
00850 <span class="comment">     */</span>
00851     out[i] = clamp(1.164 * (y - 16) + 1.596 * (cr - 128));
00852     out[i + 1] = clamp(1.164 * (y - 16) - 0.813 * (cr - 128) - 
00853                        0.392 * (cb - 128));
00854     out[i + 2] = clamp(1.164 * (y - 16) + 2.017 * (cb - 128));
00855   }
00856   <span class="keywordflow">return</span> 1;
00857 }
00858 
00859 
00860 <span class="keywordtype">int</span> 
00861 convertJPEGtoYCrCb(<span class="keyword">const</span> byte * source, <span class="keywordtype">int</span> sourcelen, byte * dest, 
00862                        <span class="keywordtype">int</span> &amp;size)
00863 {
00864   <span class="keywordtype">int</span> sz;
00865   <span class="keywordtype">void</span> *destination = <a class="code" href="uabstractclient_8cpp.html#a6">read_jpeg</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *) source, sourcelen, <span class="keyword">false</span>, sz);
00866   <span class="keywordflow">if</span> (!destination) {
00867     size = 0;
00868     <span class="keywordflow">return</span> 0;
00869   }
00870   <span class="keywordtype">int</span> cplen = sz &gt; size ? size : sz;
00871   memcpy(dest, destination, cplen);
00872   free(destination);
00873   size = sz;
00874   <span class="keywordflow">return</span> 1;
00875 }
00876 
00877 <span class="keywordtype">int</span> 
00878 convertJPEGtoRGB(<span class="keyword">const</span> byte * source, <span class="keywordtype">int</span> sourcelen, byte * dest, <span class="keywordtype">int</span> &amp;size)
00879 {
00880   <span class="keywordtype">int</span> sz;
00881   <span class="keywordtype">void</span> *destination = <a class="code" href="uabstractclient_8cpp.html#a6">read_jpeg</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *) source, sourcelen, <span class="keyword">true</span>, sz);
00882   <span class="keywordflow">if</span> (!destination) {
00883     size = 0;
00884     <span class="keywordflow">return</span> 0;
00885   }
00886   <span class="keywordtype">int</span> cplen = sz &gt; size ? size : sz;
00887   memcpy(dest, destination, cplen);
00888   free(destination);
00889   size = sz;
00890   <span class="keywordflow">return</span> 1;
00891 }
00892 
00893 <span class="keyword">struct </span>mem_source_mgr
00894 {
00895   <span class="keyword">struct </span>jpeg_source_mgr pub;
00896   JOCTET eoi[2];
00897 };
00898 
00899 <span class="keyword">static</span> <span class="keywordtype">void</span> init_source(j_decompress_ptr cinfo)
00900 {
00901 }
00902 
00903 <span class="keyword">static</span> <span class="keywordtype">boolean</span> fill_input_buffer(j_decompress_ptr cinfo)
00904 {
00905   mem_source_mgr *src = (mem_source_mgr *) cinfo-&gt;src;
00906   <span class="keywordflow">if</span> (src-&gt;pub.bytes_in_buffer != 0)
00907     <span class="keywordflow">return</span> TRUE;
00908   src-&gt;eoi[0] = 0xFF;
00909   src-&gt;eoi[1] = JPEG_EOI;
00910   src-&gt;pub.bytes_in_buffer = 2;
00911   src-&gt;pub.next_input_byte = src-&gt;eoi;
00912   <span class="keywordflow">return</span> TRUE;
00913 }
00914 
00915 <span class="keyword">static</span> <span class="keywordtype">void</span> term_source(j_decompress_ptr cinfo)
00916 {
00917 }
00918 
00919 <span class="keyword">static</span> <span class="keywordtype">void</span> skip_input_data(j_decompress_ptr cinfo, <span class="keywordtype">long</span> num_bytes)
00920 {
00921   mem_source_mgr *src = (mem_source_mgr *) cinfo-&gt;src;
00922   <span class="keywordflow">if</span> (num_bytes &lt;= 0)
00923     <span class="keywordflow">return</span>;
00924   <span class="keywordflow">if</span> (num_bytes &gt; src-&gt;pub.bytes_in_buffer)
00925     num_bytes = src-&gt;pub.bytes_in_buffer;
00926   src-&gt;pub.bytes_in_buffer -= num_bytes;
00927   src-&gt;pub.next_input_byte += num_bytes;
00928 }
00929 
00930 
00931 <span class="keyword">struct </span>urbi_jpeg_error_mgr {
00932   <span class="keyword">struct </span>jpeg_error_mgr pub;    <span class="comment">/* "public" fields */</span>
00933 
00934   jmp_buf setjmp_buffer;        <span class="comment">/* for return to caller */</span>
00935 };
00936 
00937 METHODDEF(<span class="keywordtype">void</span>)
00938 urbi_jpeg_error_exit (j_common_ptr cinfo)
00939 {
00940   <span class="comment">/* cinfo-&gt;err really points to a my_error_mgr struct, so coerce pointer */</span>
00941   urbi_jpeg_error_mgr *  myerr = ( urbi_jpeg_error_mgr *) cinfo-&gt;err;
00942 
00943   <span class="comment">/* Always display the message. */</span>
00944   <span class="comment">/* We could postpone this until after returning, if we chose. */</span>
00945   (*cinfo-&gt;err-&gt;output_message) (cinfo);
00946 
00947   <span class="comment">/* Return control to the setjmp point */</span>
00948   longjmp(myerr-&gt;setjmp_buffer, 1);
00949 }
00950 
00951 
<a name="l00954"></a><a class="code" href="uabstractclient_8cpp.html#a6">00954</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="uabstractclient_8cpp.html#a6">read_jpeg</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *jpgbuffer, <span class="keywordtype">int</span> jpgbuffer_size, <span class="keywordtype">bool</span> RGB, 
00955                        <span class="keywordtype">int</span> &amp;output_size)
00956 {
00957   <span class="keyword">struct </span>jpeg_decompress_struct cinfo;
00958   <span class="keyword">struct </span>urbi_jpeg_error_mgr jerr;
00959   cinfo.err = jpeg_std_error(&amp;jerr.pub);
00960   jerr.pub.error_exit = urbi_jpeg_error_exit;
00961   <span class="keywordflow">if</span> (setjmp(jerr.setjmp_buffer)) {
00962     <span class="comment">/* If we get here, the JPEG code has signaled an error.</span>
00963 <span class="comment">     * We need to clean up the JPEG object, close the input file, and return.</span>
00964 <span class="comment">     */</span>
00965     jpeg_destroy_decompress(&amp;cinfo);
00966     printf( <span class="stringliteral">"JPEG error!\n"</span>); 
00967     <span class="keywordflow">return</span> 0;
00968   }
00969   jpeg_create_decompress(&amp;cinfo);
00970   mem_source_mgr *source = (<span class="keyword">struct </span>mem_source_mgr *)
00971     (*cinfo.mem-&gt;alloc_small) ((j_common_ptr) &amp; cinfo, JPOOL_PERMANENT,
00972                                <span class="keyword">sizeof</span>(mem_source_mgr));
00973 
00974   cinfo.src = (jpeg_source_mgr *) source;
00975   source-&gt;pub.skip_input_data = skip_input_data;
00976   source-&gt;pub.term_source = term_source;
00977   source-&gt;pub.init_source = init_source;
00978   source-&gt;pub.fill_input_buffer = fill_input_buffer;
00979   source-&gt;pub.resync_to_restart = jpeg_resync_to_restart;
00980   source-&gt;pub.bytes_in_buffer = jpgbuffer_size;
00981   source-&gt;pub.next_input_byte = (JOCTET *) jpgbuffer;
00982   cinfo.out_color_space = (RGB ? JCS_RGB : JCS_YCbCr);
00983   jpeg_read_header(&amp;cinfo, TRUE);
00984   cinfo.out_color_space = (RGB ? JCS_RGB : JCS_YCbCr);
00985   jpeg_start_decompress(&amp;cinfo);
00986   output_size = cinfo.output_width * 
00987     cinfo.output_components        * 
00988     cinfo.output_height;
00989   <span class="keywordtype">void</span> *buffer = malloc(output_size);
00990 
00991   <span class="keywordflow">while</span> (cinfo.output_scanline &lt; cinfo.output_height) {
00992     <span class="comment">/* jpeg_read_scanlines expects an array of pointers to scanlines.</span>
00993 <span class="comment">     * Here the array is only one element long, but you could ask for</span>
00994 <span class="comment">     * more than one scanline at a time if that's more convenient.</span>
00995 <span class="comment">     */</span>
00996     JSAMPROW row_pointer[1];
00997     row_pointer[0] = (JOCTET *) &amp; ((<span class="keywordtype">char</span> *) buffer)[cinfo.output_scanline   * 
00998                                                     cinfo.output_components * 
00999                                                     cinfo.output_width];
01000     jpeg_read_scanlines(&amp;cinfo, row_pointer, 1);
01001   }
01002   jpeg_finish_decompress(&amp;cinfo);
01003   jpeg_destroy_decompress(&amp;cinfo);
01004 
01005   <span class="keywordflow">return</span> buffer;
01006 }
01007 
01008 
01009 <span class="keyword">template</span>&lt;<span class="keyword">class</span> S, <span class="keyword">class</span> D&gt; <span class="keywordtype">void</span> copy(S* src, D* dst, <span class="keywordtype">int</span> sc, <span class="keywordtype">int</span> dc, <span class="keywordtype">int</span> sr, <span class="keywordtype">int</span> dr, <span class="keywordtype">int</span> count, <span class="keywordtype">bool</span> sf, <span class="keywordtype">bool</span> df) {
01010   <span class="keywordtype">int</span> shift = 8*(<span class="keyword">sizeof</span>(S) - <span class="keyword">sizeof</span>(D));
01011   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;count;i++) {
01012     <span class="keywordtype">float</span> soffset = (float)i* ((float)sr /(float)dr);
01013     <span class="keywordtype">int</span> so = (int)soffset;
01014     <span class="keywordtype">float</span> factor = soffset-(float)so;
01015     S s1, s2;
01016     s1 = src[so*sc];
01017     <span class="keywordflow">if</span> (i != count - 1)
01018       s2 = src[(so+1)*sc]; 
01019     <span class="keywordflow">else</span>
01020       s2 = s1; <span class="comment">//nothing to interpolate with</span>
01021     <span class="keywordflow">if</span> (!sf) {
01022       s1 = s1 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(S)*8-1));
01023       s2 = s2 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(S)*8-1));   
01024     }
01025     <span class="keywordtype">int</span> v1 = (int) ((float)(s1)*(1.0-factor) + (float)(s2)*factor);
01026     <span class="keywordtype">int</span> v2;
01027     <span class="keywordflow">if</span> (sc==1)
01028       v2 = v1;
01029     <span class="keywordflow">else</span> {
01030       s1 = src[so*sc+1];
01031       <span class="keywordflow">if</span> (i != count - 1)
01032         s2 = src[(so+1)*sc+1];
01033       <span class="keywordflow">else</span>
01034         s2 = s1; <span class="comment">//nothing to interpolate with</span>
01035       <span class="keywordflow">if</span> (!sf) {
01036         s1 = s1 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(S)*8-1));
01037         s2 = s2 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(S)*8-1));   
01038       }
01039        v2 = (int) ((float)(s1)*(1.0-factor) + (float)(s2)*factor);
01040     }
01041     D d1, d2;
01042     <span class="keywordflow">if</span> (shift&gt;=0) {
01043       d1 = (D)(v1 &gt;&gt;shift);
01044       d2 = (D)(v2 &gt;&gt;shift);
01045     }
01046     <span class="keywordflow">else</span> {
01047       d1 = (D)(v1) *  (1&lt;&lt; (-shift));
01048       d2 = (D)(v2) * (1&lt;&lt; (-shift));
01049     }
01050     <span class="keywordflow">if</span> (!df) {
01051       d1 = d1 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(D)*8-1));
01052       d2 = d2 ^ (1&lt;&lt;(<span class="keyword">sizeof</span>(D)*8-1));    
01053     }
01054     <span class="keywordflow">if</span> (dc==2) {
01055       dst[i*2] = d1;
01056       dst[i*2+1] = d2;
01057     }
01058     <span class="keywordflow">else</span>
01059       dst[i] = (D) (((int)d1+(int)d2) /2);
01060   }
01061 }
01062 
01067 <span class="keywordtype">int</span>
<a name="l01068"></a><a class="code" href="uabstractclient_8h.html#a39">01068</a> <a class="code" href="uabstractclient_8h.html#a39">convert</a> (<span class="keyword">const</span> <a class="code" href="classUSound.html">USound</a> &amp;source, <a class="code" href="classUSound.html">USound</a> &amp;dest) {
01069   <span class="keywordflow">if</span> ( (source.<a class="code" href="classUSound.html#o5">soundFormat</a> != SOUND_RAW &amp;&amp; source.<a class="code" href="classUSound.html#o5">soundFormat</a> != SOUND_WAV) ||
01070        (dest.<a class="code" href="classUSound.html#o5">soundFormat</a> != SOUND_RAW &amp;&amp; dest.<a class="code" href="classUSound.html#o5">soundFormat</a> != SOUND_WAV))
01071     <span class="keywordflow">return</span> 1; <span class="comment">//conversion not handled yet</span>
01072   <span class="comment">//phase one: calculate required buffer size, set destination unspecified fields</span>
01073   <span class="keywordtype">int</span> schannels, srate, ssampleSize;
01074   USoundSampleFormat ssampleFormat;
01075   <span class="keywordflow">if</span> (source.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV) {
01076     wavheader * wh = (wavheader *)source.<a class="code" href="classUSound.html#o0">data</a>;
01077     schannels = wh-&gt;<a class="code" href="classUSound.html#o2">channels</a>;
01078     srate = wh-&gt;freqechant;
01079     ssampleSize = wh-&gt;bitperchannel;
01080     ssampleFormat = (ssampleSize&gt;8)?SAMPLE_SIGNED:SAMPLE_UNSIGNED;
01081   }
01082   <span class="keywordflow">else</span> {
01083     schannels = source.<a class="code" href="classUSound.html#o2">channels</a>;
01084     srate = source.<a class="code" href="classUSound.html#o3">rate</a>;
01085     ssampleSize = source.<a class="code" href="classUSound.html#o4">sampleSize</a>;
01086     ssampleFormat = source.<a class="code" href="classUSound.html#o6">sampleFormat</a>;
01087   }
01088   <span class="keywordflow">if</span> (!dest.<a class="code" href="classUSound.html#o2">channels</a>) dest.<a class="code" href="classUSound.html#o2">channels</a> = schannels;
01089   <span class="keywordflow">if</span> (!dest.<a class="code" href="classUSound.html#o3">rate</a>) dest.<a class="code" href="classUSound.html#o3">rate</a> = srate;
01090   <span class="keywordflow">if</span> (!dest.<a class="code" href="classUSound.html#o4">sampleSize</a>) dest.<a class="code" href="classUSound.html#o4">sampleSize</a> = ssampleSize;
01091   <span class="keywordflow">if</span> (!(int)dest.<a class="code" href="classUSound.html#o6">sampleFormat</a>) dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> = ssampleFormat;
01092   <span class="keywordflow">if</span> (dest.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV) dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> = (dest.<a class="code" href="classUSound.html#o4">sampleSize</a>&gt;8)?SAMPLE_SIGNED:SAMPLE_UNSIGNED; 
01093   <span class="keywordtype">int</span> destSize = (int) (( (<span class="keywordtype">long</span> long)(source.<a class="code" href="classUSound.html#o1">size</a>- ((source.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV)?44:0)) * (<span class="keywordtype">long</span> long)dest.<a class="code" href="classUSound.html#o2">channels</a> * (<span class="keywordtype">long</span> long)dest.<a class="code" href="classUSound.html#o3">rate</a> * (<span class="keywordtype">long</span> long)(dest.<a class="code" href="classUSound.html#o4">sampleSize</a>/8)) / ( (<span class="keywordtype">long</span> long)schannels*(<span class="keywordtype">long</span> long)srate*(<span class="keywordtype">long</span> long)(ssampleSize/8)));
01094   <span class="keywordflow">if</span> (dest.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV) destSize+= <span class="keyword">sizeof</span>(wavheader);
01095   <span class="keywordflow">if</span> (dest.<a class="code" href="classUSound.html#o1">size</a>&lt;destSize) 
01096     dest.<a class="code" href="classUSound.html#o0">data</a> = (<span class="keywordtype">char</span> *)realloc(dest.<a class="code" href="classUSound.html#o0">data</a>, destSize);
01097   dest.<a class="code" href="classUSound.html#o1">size</a> = destSize;
01098   <span class="comment">//write destination header if appropriate</span>
01099   <span class="keywordflow">if</span> (dest.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV) {
01100     wavheader * wh = (wavheader *)dest.<a class="code" href="classUSound.html#o0">data</a>;
01101     memcpy(wh-&gt;riff,<span class="stringliteral">"RIFF"</span>,4);
01102     wh-&gt;length = dest.<a class="code" href="classUSound.html#o1">size</a> - 8;
01103     memcpy(wh-&gt;wave, <span class="stringliteral">"WAVE"</span>, 4);
01104     memcpy(wh-&gt;fmt, <span class="stringliteral">"fmt "</span>, 4);
01105     wh-&gt;lnginfo = 16;
01106     wh-&gt;one = 1;
01107     wh-&gt;<a class="code" href="classUSound.html#o2">channels</a> = dest.<a class="code" href="classUSound.html#o2">channels</a>;
01108     wh-&gt;freqechant = dest.<a class="code" href="classUSound.html#o3">rate</a>;
01109     wh-&gt;bytespersec = dest.<a class="code" href="classUSound.html#o3">rate</a> * dest.<a class="code" href="classUSound.html#o2">channels</a> * (dest.<a class="code" href="classUSound.html#o4">sampleSize</a>/8);
01110     wh-&gt;bytesperechant = (dest.<a class="code" href="classUSound.html#o4">sampleSize</a>/8)*dest.<a class="code" href="classUSound.html#o2">channels</a>;
01111     wh-&gt;bitperchannel = dest.<a class="code" href="classUSound.html#o4">sampleSize</a>;
01112     memcpy(wh-&gt;data, <span class="stringliteral">"data"</span>, 4);
01113     wh-&gt;datalength = destSize - <span class="keyword">sizeof</span>(wavheader);
01114   }
01115   
01116   <span class="comment">//do the conversion and write to dest.data</span>
01117   <span class="keywordtype">char</span> * sbuffer = source.<a class="code" href="classUSound.html#o0">data</a>;
01118   <span class="keywordflow">if</span> (source.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV)
01119     sbuffer += <span class="keyword">sizeof</span>(wavheader);
01120   <span class="keywordtype">char</span> * dbuffer = dest.<a class="code" href="classUSound.html#o0">data</a>;
01121   <span class="keywordflow">if</span> (dest.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV)
01122     dbuffer += <span class="keyword">sizeof</span>(wavheader);
01123   <span class="keywordtype">int</span> elementCount = dest.<a class="code" href="classUSound.html#o1">size</a> - ((dest.<a class="code" href="classUSound.html#o5">soundFormat</a> == SOUND_WAV)?<span class="keyword">sizeof</span>(wavheader):0);
01124   elementCount /= (dest.<a class="code" href="classUSound.html#o2">channels</a> * (dest.<a class="code" href="classUSound.html#o4">sampleSize</a>/8));
01125   <span class="keywordflow">switch</span>( ssampleSize*1000 + dest.<a class="code" href="classUSound.html#o4">sampleSize</a>) {
01126   <span class="keywordflow">case</span> 8008:
01127     copy(sbuffer, dbuffer, schannels, dest.<a class="code" href="classUSound.html#o2">channels</a>, srate, dest.<a class="code" href="classUSound.html#o3">rate</a>, elementCount, ssampleFormat==SAMPLE_SIGNED, dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> == SAMPLE_SIGNED);
01128     <span class="keywordflow">break</span>;
01129   <span class="keywordflow">case</span> 16008:
01130     copy((<span class="keywordtype">short</span> *)sbuffer, dbuffer, schannels, dest.<a class="code" href="classUSound.html#o2">channels</a>, srate, dest.<a class="code" href="classUSound.html#o3">rate</a>, elementCount, ssampleFormat==SAMPLE_SIGNED, dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> == SAMPLE_SIGNED);
01131     <span class="keywordflow">break</span>;
01132   <span class="keywordflow">case</span> 16016:
01133     copy((<span class="keywordtype">short</span> *)sbuffer, (<span class="keywordtype">short</span> *)dbuffer, schannels, dest.<a class="code" href="classUSound.html#o2">channels</a>, srate, dest.<a class="code" href="classUSound.html#o3">rate</a>, elementCount, ssampleFormat==SAMPLE_SIGNED, dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> == SAMPLE_SIGNED);
01134     <span class="keywordflow">break</span>;
01135   <span class="keywordflow">case</span> 8016:
01136     copy((<span class="keywordtype">char</span> *)sbuffer, (<span class="keywordtype">short</span> *)dbuffer, schannels, dest.<a class="code" href="classUSound.html#o2">channels</a>, srate, dest.<a class="code" href="classUSound.html#o3">rate</a>, elementCount, ssampleFormat==SAMPLE_SIGNED, dest.<a class="code" href="classUSound.html#o6">sampleFormat</a> == SAMPLE_SIGNED);
01137     <span class="keywordflow">break</span>;
01138   }
01139   <span class="keywordflow">return</span> 0;
01140 }
01141 
<a name="l01142"></a><a class="code" href="classUMessage.html#a0">01142</a> <a class="code" href="classUMessage.html#a0">UMessage::UMessage</a>(<a class="code" href="classUAbstractClient.html">UAbstractClient</a> &amp; client, <span class="keywordtype">int</span> timestamp,   <span class="keywordtype">char</span> *tag, <span class="keywordtype">char</span> *message, 
01143                     <span class="keywordtype">void</span> *buffer, <span class="keywordtype">int</span> length)
01144   : client(client), timestamp(timestamp),  tag(tag),  stringValue(0), alocated(false) {
01145   <span class="keywordflow">while</span> (message[0] ==<span class="charliteral">' '</span>) message++;
01146   <span class="keywordflow">if</span> (strncmp(message,<span class="stringliteral">"BIN "</span>,4)) {
01147     <span class="comment">//non binary message</span>
01148     binaryType = BINARYMESSAGE_NONE;
01149 
01150     <span class="keywordflow">if</span> (message[0] == <span class="charliteral">'"'</span>) {
01151       <span class="comment">//string</span>
01152       type = MESSAGE_STRING;
01153       <a class="code" href="classUMessage.html#o6">stringValue</a> = strdup(&amp;message[1]);
01154       ((<span class="keywordtype">char</span> *)stringValue)[strlen(<a class="code" href="classUMessage.html#o6">stringValue</a>)-1] = 0;
01155       <span class="keywordflow">return</span>;
01156     }
01157 
01158     <span class="keywordflow">if</span> (message[0] == <span class="charliteral">'*'</span>) {
01159       <span class="comment">//system message</span>
01160       type = MESSAGE_SYSTEM;
01161       <a class="code" href="classUMessage.html#o7">systemValue</a> = message+1;
01162       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;2 &amp;&amp; message[i+1]; i++)
01163         <a class="code" href="classUMessage.html#o7">systemValue</a>++;
01164       <span class="keywordflow">return</span>;
01165     }
01166 
01167     <span class="keywordflow">if</span> (message[0] == <span class="charliteral">'!'</span>) {
01168       <span class="comment">//error message</span>
01169       type = MESSAGE_ERROR;
01170       <a class="code" href="classUMessage.html#o8">errorValue</a> = message+1;
01171       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;2 &amp;&amp; message[i+1]; i++)
01172         <a class="code" href="classUMessage.html#o8">errorValue</a>++;
01173       <span class="keywordflow">return</span>;
01174     }
01175     <span class="comment">//double?</span>
01176     <span class="keywordtype">int</span> count = sscanf(message, <span class="stringliteral">"%lf"</span>, &amp;<a class="code" href="classUMessage.html#o5">doubleValue</a>);
01177     <span class="keywordflow">if</span> (count)
01178       type = MESSAGE_DOUBLE;
01179     <span class="keywordflow">else</span> {
01180       type = MESSAGE_UNKNOWN;
01181       this-&gt;message = message;
01182     }
01183     <span class="keywordflow">return</span>;
01184   }
01185 
01186   <span class="comment">//binary message</span>
01187   type = MESSAGE_BINARY;
01188 
01189   <span class="comment">//trying to parse header to find type</span>
01190   <span class="keywordtype">char</span> type[64];
01191   memset(type, 0, 64);
01192   <span class="keywordtype">int</span> p1, p2, p3, p4, p5;
01193   <span class="keywordtype">int</span> count = sscanf(message,<span class="stringliteral">"BIN %d %63s %d %d %d %d"</span>, &amp;p1, type, &amp;p2, &amp;p3, &amp;p4, &amp;p5);
01194   <span class="comment">//DEBUG fprintf(stderr,"%s:  %d %s %d %d\n", message, p1, type, p2, p3);</span>
01195   <span class="keywordflow">if</span> (!strcmp(type, <span class="stringliteral">"jpeg"</span>)) {
01196     binaryType = BINARYMESSAGE_IMAGE;
01197     image.<a class="code" href="classUImage.html#o1">size</a> = p1;
01198     image.<a class="code" href="classUImage.html#o2">width</a> = p2;
01199     image.<a class="code" href="classUImage.html#o3">height</a> = p3;
01200     image.<a class="code" href="classUImage.html#o4">imageFormat</a> = IMAGE_JPEG;
01201     image.<a class="code" href="classUImage.html#o0">data</a> = (<span class="keywordtype">char</span> * )buffer;
01202     <span class="keywordflow">return</span>;
01203   }
01204  
01205   <span class="keywordflow">if</span> (!strcmp(type, <span class="stringliteral">"YCbCr"</span>)) {
01206     binaryType = BINARYMESSAGE_IMAGE;
01207     image.<a class="code" href="classUImage.html#o1">size</a> = p1;
01208     image.<a class="code" href="classUImage.html#o2">width</a> = p2;
01209     image.<a class="code" href="classUImage.html#o3">height</a> = p3;
01210     image.<a class="code" href="classUImage.html#o4">imageFormat</a> = IMAGE_YCbCr;
01211     image.<a class="code" href="classUImage.html#o0">data</a> = (<span class="keywordtype">char</span> * )buffer;
01212     <span class="keywordflow">return</span>;
01213   }
01214 
01215 
01216   <span class="keywordflow">if</span> (!strcmp(type, <span class="stringliteral">"raw"</span>)) {
01217     binaryType = BINARYMESSAGE_SOUND;
01218     sound.<a class="code" href="classUSound.html#o5">soundFormat</a> = SOUND_RAW;
01219     sound.<a class="code" href="classUSound.html#o0">data</a> = (<span class="keywordtype">char</span> *)buffer;
01220     sound.<a class="code" href="classUSound.html#o1">size</a> = p1;
01221     sound.<a class="code" href="classUSound.html#o2">channels</a> = p2;
01222     sound.<a class="code" href="classUSound.html#o3">rate</a> = p3;
01223     sound.<a class="code" href="classUSound.html#o4">sampleSize</a> = p4;
01224     sound.<a class="code" href="classUSound.html#o6">sampleFormat</a> = (USoundSampleFormat) p5;
01225     <span class="keywordflow">return</span>;
01226   }
01227 
01228   <span class="keywordflow">if</span> (!strcmp(type, <span class="stringliteral">"wav"</span>)) {
01229     binaryType = BINARYMESSAGE_SOUND;
01230     sound.<a class="code" href="classUSound.html#o5">soundFormat</a> = SOUND_WAV;
01231     sound.<a class="code" href="classUSound.html#o0">data</a> = (<span class="keywordtype">char</span> *)buffer;
01232     sound.<a class="code" href="classUSound.html#o1">size</a> = p1;
01233     sound.<a class="code" href="classUSound.html#o2">channels</a> = p2;
01234     sound.<a class="code" href="classUSound.html#o3">rate</a> = p3;
01235     sound.<a class="code" href="classUSound.html#o4">sampleSize</a> = p4;
01236     sound.<a class="code" href="classUSound.html#o6">sampleFormat</a> = (USoundSampleFormat) p5;
01237     <span class="keywordflow">return</span>;
01238   }
01239 
01240   <span class="comment">//unknown binary</span>
01241   binary.<a class="code" href="classUBinary.html#o1">message</a> = message;
01242   binaryType = BINARYMESSAGE_UNKNOWN;
01243   binary.<a class="code" href="classUBinary.html#o0">data</a> = buffer;
01244   binary.<a class="code" href="classUBinary.html#o2">size</a> = length;
01245   <span class="keywordflow">return</span>;
01246  }
01247 
01248 
<a name="l01249"></a><a class="code" href="classUMessage.html#a1">01249</a> <a class="code" href="classUMessage.html#a0">UMessage::UMessage</a>(<span class="keyword">const</span> <a class="code" href="classUMessage.html">UMessage</a> &amp;b, <span class="keywordtype">bool</span> alocate)
01250   :client(b.client)
01251 {
01252   alocated = alocate;
01253   <a class="code" href="classUMessage.html#o1">timestamp</a> = b.<a class="code" href="classUMessage.html#o1">timestamp</a>;
01254   <a class="code" href="classUMessage.html#o2">tag</a> = b.<a class="code" href="classUMessage.html#o2">tag</a>;
01255   <span class="keywordflow">if</span> (alocated)
01256     <a class="code" href="classUMessage.html#o2">tag</a> = strdup(<a class="code" href="classUMessage.html#o2">tag</a>);
01257   type = b.<a class="code" href="classUMessage.html#o3">type</a>;
01258   binaryType = b.<a class="code" href="classUMessage.html#o4">binaryType</a>;
01259   <span class="keywordflow">switch</span>(type) {
01260   <span class="keywordflow">case</span> MESSAGE_DOUBLE:
01261     <a class="code" href="classUMessage.html#o5">doubleValue</a> = b.<a class="code" href="classUMessage.html#o5">doubleValue</a>;
01262     <span class="keywordflow">break</span>;
01263   <span class="keywordflow">case</span> MESSAGE_STRING:
01264       <a class="code" href="classUMessage.html#o6">stringValue</a> = b.<a class="code" href="classUMessage.html#o6">stringValue</a>;
01265       <span class="keywordflow">if</span> (alocated)  
01266         <a class="code" href="classUMessage.html#o6">stringValue</a> = strdup(<a class="code" href="classUMessage.html#o6">stringValue</a>);
01267       <span class="keywordflow">break</span>;
01268   <span class="keywordflow">case</span> MESSAGE_SYSTEM:
01269     <a class="code" href="classUMessage.html#o7">systemValue</a> = b.<a class="code" href="classUMessage.html#o7">systemValue</a>;
01270     <span class="keywordflow">if</span> (alocated)
01271       <a class="code" href="classUMessage.html#o7">systemValue</a> = strdup(b.<a class="code" href="classUMessage.html#o7">systemValue</a>);
01272     <span class="keywordflow">break</span>;
01273   <span class="keywordflow">case</span> MESSAGE_ERROR:
01274     <a class="code" href="classUMessage.html#o8">errorValue</a> = b.<a class="code" href="classUMessage.html#o8">errorValue</a>;
01275     <span class="keywordflow">if</span> (alocated)
01276       <a class="code" href="classUMessage.html#o8">errorValue</a> = strdup(b.<a class="code" href="classUMessage.html#o8">errorValue</a>);
01277     <span class="keywordflow">break</span>;
01278   <span class="keywordflow">case</span> MESSAGE_UNKNOWN:
01279     <a class="code" href="classUMessage.html#o9">message</a> = b.<a class="code" href="classUMessage.html#o9">message</a>;
01280     <span class="keywordflow">if</span> (alocated)
01281       <a class="code" href="classUMessage.html#o9">message</a> = strdup(<a class="code" href="classUMessage.html#o9">message</a>);
01282     <span class="keywordflow">break</span>;
01283   <span class="keywordflow">case</span> MESSAGE_BINARY:
01284     <span class="keywordflow">switch</span> (binaryType) {
01285     <span class="keywordflow">case</span> BINARYMESSAGE_UNKNOWN:
01286       binary = b.<a class="code" href="classUMessage.html#o12">binary</a>;
01287       <span class="keywordflow">if</span> (alocated) {
01288         binary.<a class="code" href="classUBinary.html#o0">data</a> = malloc(binary.<a class="code" href="classUBinary.html#o2">size</a>);
01289         memcpy(binary.<a class="code" href="classUBinary.html#o0">data</a>, b.<a class="code" href="classUMessage.html#o12">binary</a>.<a class="code" href="classUBinary.html#o0">data</a>, binary.<a class="code" href="classUBinary.html#o2">size</a>);
01290       }
01291       <span class="keywordflow">break</span>;
01292     <span class="keywordflow">case</span> BINARYMESSAGE_SOUND:
01293       sound = b.<a class="code" href="classUMessage.html#o10">sound</a>;
01294       <span class="keywordflow">if</span> (alocated) {
01295         sound.<a class="code" href="classUSound.html#o0">data</a> = (<span class="keywordtype">char</span> *)malloc(sound.<a class="code" href="classUSound.html#o1">size</a>);
01296         memcpy(sound.<a class="code" href="classUSound.html#o0">data</a>, b.<a class="code" href="classUMessage.html#o10">sound</a>.<a class="code" href="classUSound.html#o0">data</a>, sound.<a class="code" href="classUSound.html#o1">size</a>);
01297       }
01298       <span class="keywordflow">break</span>;
01299     <span class="keywordflow">case</span> BINARYMESSAGE_IMAGE:
01300       image = b.<a class="code" href="classUMessage.html#o11">image</a>;
01301       <span class="keywordflow">if</span> (alocated) {
01302         image.<a class="code" href="classUImage.html#o0">data</a> = (<span class="keywordtype">char</span> *)malloc(image.<a class="code" href="classUImage.html#o1">size</a>);
01303         memcpy(image.<a class="code" href="classUImage.html#o0">data</a>, b.<a class="code" href="classUMessage.html#o11">image</a>.<a class="code" href="classUImage.html#o0">data</a>, image.<a class="code" href="classUImage.html#o1">size</a>);
01304       }
01305       <span class="keywordflow">break</span>;
01306     }
01307     <span class="keywordflow">break</span>;
01308   }
01309   
01310 }
01311 
<a name="l01312"></a><a class="code" href="classUMessage.html#a2">01312</a>  <a class="code" href="classUMessage.html#a2">UMessage::~UMessage</a>() {
01313    <span class="keywordflow">if</span> ( (type == MESSAGE_STRING) &amp;&amp; (<a class="code" href="classUMessage.html#o6">stringValue</a>!=0) )
01314      free((<span class="keywordtype">void</span> *)<a class="code" href="classUMessage.html#o6">stringValue</a>);
01315    <span class="keywordflow">if</span> (alocated) {
01316      free(<a class="code" href="classUMessage.html#o2">tag</a>);
01317       <span class="keywordflow">switch</span>(type) {
01318     
01319       <span class="keywordflow">case</span> MESSAGE_SYSTEM:
01320         <span class="keywordflow">if</span> (alocated)
01321           free(<a class="code" href="classUMessage.html#o7">systemValue</a>);        
01322         <span class="keywordflow">break</span>;
01323 
01324       <span class="keywordflow">case</span> MESSAGE_UNKNOWN:
01325         <span class="keywordflow">if</span> (alocated)
01326           free(<a class="code" href="classUMessage.html#o9">message</a>);
01327         <span class="keywordflow">break</span>;
01328 
01329       <span class="keywordflow">case</span> MESSAGE_BINARY:
01330         <span class="keywordflow">switch</span> (binaryType) {
01331         <span class="keywordflow">case</span> BINARYMESSAGE_UNKNOWN:
01332           <span class="keywordflow">if</span> (alocated)
01333             free(binary.<a class="code" href="classUBinary.html#o0">data</a>);
01334           <span class="keywordflow">break</span>;
01335      
01336         <span class="keywordflow">case</span> BINARYMESSAGE_SOUND:
01337           <span class="keywordflow">if</span> (alocated)
01338             free(sound.<a class="code" href="classUSound.html#o0">data</a>);
01339           <span class="keywordflow">break</span>;
01340         <span class="keywordflow">case</span> BINARYMESSAGE_IMAGE:
01341           <span class="keywordflow">if</span> (alocated)
01342             free(image.<a class="code" href="classUImage.html#o0">data</a>);
01343           <span class="keywordflow">break</span>;
01344         }
01345         <span class="keywordflow">break</span>;
01346       }
01347    }
01348  }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Sep 21 08:43:19 2005 for liburbi-cpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
