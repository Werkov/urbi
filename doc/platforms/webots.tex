\newenvironment{attribute}[4]
{
  \item \lstinline|#1|
    \begin{description}
    \item[Permissions] #2.
    \item[Type] #3.
      \ifx#4\empty\else
    \item[Range] #4.
      \fi
    \item[Description]
}{
    \end{description}
}

\chapter{\webots}
\label{sec:webots}

This chapter documents the use of \urbi in the \webots simulation
environment.

\section{Quick Start}

This section describes how to setup the software on your computer and
give you the basis to use \uwebots{}.

\subsection{Installation}

The setup process depends on your OS, please follow the corresponding
instructions.

\subsubsection{Linux}

To install \uwebots{} in your \webots{} on linux, you must download an
archive of the form
\texttt{urbi-for-webots-\var{version}-linux-x86-gcc4-release.tar.bz2}.
You may choose an other archive format than \texttt{.tar.bz2}, but you
will need to slightly adjust the following instruction accordingly.

The archive is structured to blend into the \webots hierarchy, as
follow:

\begin{itemize}
\item \texttt{urbi-for-webots-\var{version}/projects/default/controllers/urbi2.0/}\\ \urbi{} SDK and
  \webots{} controller.
\item \texttt{urbi-for-webots-\var{version}/projects/packages/urbi2.0/share/robot-name/}\\ Shared
  \us{} robot behaviors.
\item \texttt{urbi-for-webots-\var{version}/projects/packages/urbi2.0/controllers/robot-name/}\\
  Demonstration controllers for each robot.
\item \texttt{urbi-for-webots-\var{version}/projects/packages/urbi2.0/worlds/}\\ Demonstration
  worlds.
\end{itemize}

All you need to do is extract it into your \webots directory, minus the
\texttt{urbi-for-webots-\var{version}} containing directory, so as to
merge the packaged \texttt{project} directory with your \webots{}'
\texttt{project} directory.

This can be easily done with the following \texttt{tar} command:

\begin{lstlisting}[language=sh]
tar -xvjf urbi-for-webots.tar.bz2 -C /path/to/webots --strip-components 1
\end{lstlisting}

Otherwise, you can also merge the directory after extracting the archive:

\begin{lstlisting}[language=sh]
cp --archive urbi-for-webots/project /path/to/webots
\end{lstlisting}

You can check your installation works correctly by starting a test world:

\begin{lstlisting}[language=sh]
cd /path/to/webots
./webots projects/packages/urbi2.0/worlds/aibo-ball-tracking.wbt
\end{lstlisting}

You should see an \aibo{} looking at a moving ball.

\subsubsection{\macosx{}}

\uwebots{} is not available under \macosx{} anymore for now. We hope to
fix this very shortly.

%% You have to be administrator on your machine in order to install \urbi
%% for Webots.  Extract the zip file containing \urbi by double clicking
%% on it.  You obtain two folders: \file{usr} and \file{webots}.  Copy
%% the contents of the \file{webots} directory in the directory
%% containing Webots installation (if you did the default installation it
%% is in \file{/Applications/Webots}), and copy the contents of the
%% \file{usr} folder in the \file{/usr} system folder.

%% If, for instance, you extracted the zip file in your \file{Desktop}
%% folder, and that you have set the variable \env{WEBOTS\_HOME} to the
%% Webots installation path as explained in Webots documentation.  From a
%% shell terminal this gives you:

%% \begin{shell}
%% $ cd $HOME/Desktop
%% $ ls
%% usr webots
%% webots-urbiengine-sdk-webots-1.03-k1462-e247-l482-powerpc-apple-darwin8-gcc-4.0.1.zip
%% $ cp -r usr /
%% $ cp -r webots/* $WEBOTS_HOME/
%% \end{shell}

\subsubsection{Windows}

\uwebots{} is not available under windows anymore for now. We hope to
fix this very shortly.

%% \paragraph{Installation}

%% To install \urbi for Webots under windows, Webots must be installed on
%% your computer. If Webots is not installed, please first proceed to
%% Webots installation. Then double click on the ``\urbi Webots 1.0
%% Setup.exe'' and follow the instructions given by the installer:

%% \begin{enumerate}
%% \item The installer recommends to close all other running applications
%%   while installing \urbi for Webots. Click ``Next $>$'' to proceed.

%% \item Before installing \urbi for Webots, read and accept the Licence
%%   Agreement. Once you have read it, check ``I accept the agreement'' and
%%   click on ``Next $>$'' to proceed.

%% \item The installer will automatically detect your Webots installation
%%   path and install the \urbi controller, the worlds and data in the
%%   same location. For all the other files (\urbi for Webots SDK and
%%   \urbi for Webots Documentation) you have to provide a new
%%   location. This is what the installer is asking at this step. Choose
%%   a custom location if you don't want the default one,
%%   \verb+C:\Program Files\Gostai\Urbi Webots 1.0+, and click
%%   ``Next $>$'' to proceed.

%% \item In this step you can choose which features will be installed on
%%   your computer. Required features (``\urbi Webots'') cannot be
%%   unchecked. These are the \urbi controller and the Urbi for Webots
%%   worlds and data. They will be installed in your Webots installation
%%   directory. Optional features are the ``\urbi Software Development
%%   Kit'', useful if you want to develop your own UObjects and plug them
%%   in \urbi, and the ``\urbi Documentation''. Optional features will be
%%   installed in the location you provided at Step 3).  Check the
%%   checkbox near the features you want to install, and click ``Next $>$''
%%   to proceed to next step.

%% \item You can customize the location where shortcuts to \urbi files
%%   will be installed in you Start Menu. You can choose not to put any
%%   shortcuts just by checking ``Don't create a start menu folder''. Click
%%   ``Next $>$'' to proceed to next step.

%% \item \urbi source code files have a ``.u'' extension. By default the
%%   installer associate all ``.u'' files with \urbi. If you don't want
%%   these files to be associated unckeck the corresponding
%%   checkbox. Then click ``Next $>$'' to proceed to next step.

%% \item The installer prints a summary of the installation options for
%%   you to verify that it is correct. Then click ``Install'' to install
%%   \urbi for webots on your computer.

%% \item The installer display the README file. Click ``Next $>$'' to
%%   proceed to next step.

%% \item You have finished to install \urbi for Webots. Click ``Finish'' to
%%   close the installer.
%% \end{enumerate}

\subsection{Evaluation mode}

If you don't provide a valid license file to the \urbi controller, it
will be launched in \dfn{evaluation mode}. The only difference with
the normal version is that the controller will exit after five
minutes, thus letting you test all the features of the registered
version during this amount of time. When you launch \webots and \urbi
without a valid license file you can see a message in \webots log that
tells you that the license is invalid or missing:

\begin{center}
  \includegraphics{img/webots/no-license-webots-log-msg}
\end{center}


\subsection{License setup}

In order to run Urbi for \webots unlimitedly you must have a licence
file.  The Urbi for \webots licensing system is based on the \webots
licensing system.  In \webots there are two licensing system available:
\begin{itemize}
\item a license file \file{webots.key};
\item an USB dongle.
\end{itemize}

\subsubsection{Urbi licensing with \webots.key license}

To get an \urbi license using this type of licensing, please send us a
copy of your \file{webots.key} license, we will generate the \urbi
license using this file.

Once you have your \file{urbi.key} file, put the \file{webots.key}
file in the folder \file{webots/ressources/} (warning: it is mandatory
to have a copy of the webots.key in this folder, if you don't have it,
\urbi won't find the \file{webots.key} file and you will get a
licensing error message) and place the \file{urbi.key} file in the
same folder as the urbi controller. By default in
\file{webots/projects/default/controllers/urbi/}.


\subsubsection{Urbi licensing with USB dongle}

To obtain an Urbi license if you use this type of licensing, please
send us your \webots USB dongle number (available in the help/about
\webots menu). We will then generate an Urbi license using this number.

Install your \file{urbi.key} file in the same folder as the Urbi
controller.  By default in
\file{webots/projects/default/controllers/urbi/}.

\subsection{License problem}

If you have a valid license but still get the licensing error message,
check that you have followed correctly the setup instructions. Note
that you can specify the location of the \file{urbi.key} license to
the Urbi controller, in the \file{.wbt} files, within the
\code{controllerArgs} field. Just add \option{-l} and the absolute
path of your license file to the field line. For instance (with a
license file urbi.key located in \file{C:/mylicensefolder/})

\begin{shell}
controllerArgs "-f -l C:/mylicensefolder/urbi.key  -p 54000 32"
\end{shell}

Contact Gostai if you still have some problems with the license, and
we will resolve the problem with you.

\subsection{Your first run}

This section describes basic use of the \urbi engine for \webots.

\subsubsection{\urbi worlds}

We provide a set of example worlds with several robots you will be
able to control through \urbi. They are located in the directory:
\file{WEBOTS\_DIRECTORY/projects/packages/urbi/worlds/}.  Open the
world named \file{aibo\_ers7\_urbi\_soccer.wbt}. The image bellow is a
screenshot of this world. You can see an aibo in a soccer field, with
a pink ball in front of it.


\begin{center}
  \includegraphics[width=\linewidth]{img/webots/aibo-soccer}
\end{center}

If you look in \webots scene tree, you will see that the aibo (real
name is ERS7) is a CustomRobot node, and that it uses urbi as
controller.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/scene-tree}
\end{center}

Let's see how this controller let you control the robot.


\subsubsection{\urbi controller}

You have two ways to control your robot through the \urbi
controller. The first way is by remotely sending commands to the \urbi
controller. The \urbi controller act as a server, and let you connect
to it through the network, and then send \urbi commands to this server.
The second way is by writing \urbi scripts that will be loaded at
controller start up.


\subsubsection{Send commands with a client software}

In order to connect to the \urbi controller and then send commands, you
need to use a client software that allows you to connect on some
address on the network and let you send data through this connection.
The simplest program which do this is the \command{telnet} program,
available on all platform (Windows, Linux and MacOs). You can also use
one of the program available at Urbiforge (http://www.urbiforge.com)
in the Tool section.  The \urbi controller launched with the
aibo\_er7\_urbi\_soccer world is waiting for connections coming on
your computer, on port 54000. So to connect on it you will have to
specify the address of your computer ('localhost') and the right port
(54000).


\paragraph{Telnet}

\subparagraph{Windows}

To launch \command{telnet} under windows click on the start menu, and
then on run.

\begin{center}
  \includegraphics[scale=.6]{img/webots/click-run-windows}
\end{center}

Type \command{cmd} and click OK. This will launch a dos command prompt.

\begin{center}
  \includegraphics{img/webots/run-cmd-windows}
\end{center}

In the dos command prompt type \samp{telnet localhost 54000}.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/telnet-windows}
\end{center}

This launchs \command{telnet}. It connects to the \urbi controller,
and the \urbi controller sends you the \urbi banner. On windows the
text is badly displayed because of some character conversion
problem. It is still usable even if it is not really convenient.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/telnet-urbi-windows}
\end{center}

\subparagraph{Linux and MacOs}

Open a new shell and type \command{telnet localhost 54000}.  This
launch \command{telnet}. It connects to the \urbi controller, and the
\urbi controller send you the \urbi banner.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/telnet-urbi-linux}
\end{center}

\subparagraph{Use telnet to send commands}

Now that you are connected to the \urbi controller, you can send
commands to it and make your robot move and interact with its
environment. For example try typing the following commands in
\command{telnet}:

\begin{urbiunchecked}
headPan = 50 time: 5s;
headPan = -50 time: 5s;
headPan = 0 time: 5s;
\end{urbiunchecked}

And you will see the head of the aibo move left, right, and then to
the center.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/telnet-some-urbi-cmd}
\end{center}

\subsubsection{Load \urbi programs at controller start}

\paragraph{By adding the file as argument of the \urbi controller}

It is possible to write some \us program and load it at controller
startup.  To do this just write \us code in some file, and then
specify its path in the \code{controllerArgs} \webots node.  For
example create a new text file \file{test.u} and write in it:

\begin{urbiunchecked}
robot.sit (),
\end{urbiunchecked}

Then edit the \webots world \file{aibo\_ers7\_urbi\_soccer.wbt}, and
add the path of your file \file{test.u} on the line of the
\code{controllerArgs} node.


\begin{shell}
controllerArgs "-f -p 54000 32 [HERE ADD YOUR SCRIPT FILES]"
\end{shell}

For exemple let say that you created your file in
\begin{itemize}
\item \file{C:/Program Files/webots/projects/packages/urbi/data/aibo/}
  (under Windows)
\item \file{/Applications/webots/projects/packages/urbi/data/aibo/}
  (under Macos)
\item \file{/usr/local/webots/projects/packages/urbi/data/aibo/}
  (under Linux)
\end{itemize}

Then you can specify the path to your file in a absolute form:
\begin{itemize}
\item \file{C:/Program Files/webots/projects/packages/urbi/data/aibo/test.u}
  (under Windows)
\item \file{/Applications/webots/projects/packages/urbi/data/aibo/test.u}
  (under Macos)
\item \file{/usr/local/webots/projects/packages/urbi/data/aibo/test.u}
  (under Linux)
\end{itemize}

Or you can specify its path relativelly to the \urbi controller
location.  Let say that you are using the \urbi controller located
here:
\begin{itemize}
\item \file{C:/Program Files/webots/projects/default/controllers/urbi/urbi}
  (under Windows)
\item
  \file{/Applications/webots/projects/default/controllers/urbi/urbi}
  (under Macos)
\item \file{/usr/local/webots/projects/default/controllers/urbi/urbi}
  (under Linux).
\end{itemize}

Then the path to your file relatively to the Urbi controller is:
\file{../../../packages/urbi/data/aibo/test.u} (under
Windows|Linux|Macos).  Add this path to the controllerArgs line and it
gives:

\begin{shell}
# Under Windows, absolute path version:
controllerArgs "-f -p 54000 50 \"C:/Program Files/webots/projects/packages/urbi/data/aibo/test.u\""
(note the use of \" \" about the path, which are mandatory if the path
contains spaces. Here between Program and Files)

# Under MacOs, absolute path version:
controllerArgs "-f -p 54000 50 /Applications/webots/projects/packages/urbi/data/aibo/test.u"

# Under Linux, absolute path version:
controllerArgs "-f -p 54000 50 /usr/local/webots/projects/packages/urbi/data/aibo/test.u"

# Relative path version (os independant)
controllerArgs "-f -p 54000 50 ../../../packages/urbi/data/aibo/test.u"
\end{shell}

NB: If you have some spaces in your file path, you have to add
backslashed double quotes in order to have \webots and Urbi understand
the path correctly.

Now when you launch \webots and you open the world
\file{aibo\_ers7\_urbi\_soccer.wbt} you can check that the
\code{controllerArgs} was correctly updated.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/scene-tree-add-loaded-file}
\end{center}

And if you look at the world view, you can see that the controller has
executed the \urbi code you specified: the aibo has sat.

\begin{center}
  \includegraphics[width=.8\linewidth]{img/webots/aibo-sat}
\end{center}



\paragraph{By loading the file in \urbi.ini}

By default, we don't specify files on the \webots \code{controllerArg}
line. We specify directories.  At startup, the \urbi controller will
go through these directories and try to find a file named
\file{urbi.ini}. This is a special file containing \us code
which is always loaded at start up by the \urbi controller. So another
way to load your custom \urbi code at start up is to use the command
\lstinline|load|.  Take the \file{test.u} file we created in the previous
section and move it to the folder containing the \file{urbi.ini}
file. Then open \file{urbi.ini} and add at the end of the file:

\begin{urbiunchecked}
load ("test.u");
\end{urbiunchecked}
Now launch \webots and open the world using the \urbi controller loading
the \urbi.ini you just updated, and you will see that your code has
been loaded too.


\section{Built-{}in robots and worlds}

This section deals with the robots and worlds provided with the the
engine.


\subsection{Understanding the \urbi for \webots hierarchy}

 Urbi for \webots is bundled with a lot of files. Here is a description of
those files.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|>{\ttfamily`}l<{'}|p{.5\linewidth}|}\hline
      \multicolumn{1}{|c|}{\textbf{Directory}}
      &
      \multicolumn{1}{c|}{\textbf{Description}}
      \\
      \hline
      webots/resources/webots.key & Webots license key \\
      \hline
      \multicolumn{2}{|c|}{Inside \file{webots/projects/default/}}\\
      \hline
      controllers & Contains the \urbi controller. \\
      controllers/urbi &      \\
      controllers/urbi/urbi &       Controller's binary \\
      controllers/urbi/urbi.key &   \urbi for Webots license key \\
      \hline
      \multicolumn{2}{|c|}{Inside \file{webots/projects/packages/urbi}}\\
      \hline
      data &  Data directory (\urbi scripts and misc. multimedia files) \\
      data/aibo &     Main Aibo robots directory \\
      data/aibo/ers7 &        Aibo ERS-7 directory \\
      data/aibo/ers210 &      Aibo ERS-210 directory \\
      data/aibo/ers210 &      Aibo ERS-220 directory \\
      data/e-puck &   E-puck robots directory \\
      data/kiki &     Kiki robots directory \\
      data/pioneer2 & Pioneer2 robots directory \\
      data/ustd &     Ustd directory (please see Ustd dedicated documentation for more information) \\
      worlds &        \urbi for Webots worlds directory \\
      worlds/aibo\_ers210\_urbi.wbt & Main world for the Aibo ERS-210. \\
      worlds/aibo\_ers7\_urbi.wbt &   Main world for the Aibo ERS-7. \\
      worlds/aibo\_ers7\_urbi\_soccer.wbt &   Soccer world for the Aibo ERS-7. \\
      worlds/aibo\_ers7\_urbi\_supervisor.wbt &       Supervisor world for the Aibo ERS-7 (see the supervisor section). \\
      worlds/e-puck\_urbi.wbt &       Main world for the e-puck. \\
      worlds/kiki\_urbi.wbt & Main world for the kiki example robot. \\
      worlds/pioneer2\_urbi.wbt &     Main world for the Pioneer 2. \\
      worlds/textures &       World's textures directory. \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Directory hierarchy}
  \end{table}

It is important to notice the data's directory hierarchy, each path
follows the following rule:

\begin{lstlisting}
data/\var{robotName}
\end{lstlisting}

If several versions of the robots are available, the following
rule is applied:

\begin{lstlisting}
data/\var{robotName}/\var{version}
\end{lstlisting}

In these directories, standard files are:

\begin{table}[htbp]
\begin{center}
\begin{tabular}{ll}\hline
  File &        Description \\
  \file{CLIENT.INI} &  Client initialization script (required). \\
  \file{config.u} &    Configuration file (used to customize the robot). \\
  \file{\var{robot}.ini} & Robot hardware layout. \\
  \file{urbi.INI} &    Server initialization script (required). \\
\hline
\end{tabular}
\end{center}

\caption{Standard robot's files}
\end{table}

\subsection{Worlds special features}

This section describes the special features of some worlds.  The
worlds referenced in the previous section as the ``main'' world have
no specificities.


\subsubsection{The soccer world (balltracking)}

Launch \webots and load the soccer world
(\file{aibo\_ers7\_urbi\_soccer.wbt}).


Connect to the \urbi server and use the following command:

\begin{urbiunchecked}
unfreeze balltracking;
\end{urbiunchecked}

This will activate the balltracking of the ERS-7 robot.  Now, you can
use \kbd{shift} and the mouse to move the ball, the ERS-7 will move
its head to follow the ball.


\subsubsection{The supervisor world}

Launch \webots and load the supervisor world
(\file{aibo\_ers7\_urbi\_supervisor.wbt}).

It is crucial to understand that this world launches two \urbi
servers.  The robot's server on the port 54001 and the supervisor
server on the port 54002.

A supervisor is a kind of robot in \webots which can be used to control
the world. It is used, for example, in the \webots soccer example to
give the ball's position.

If you create a supervisor node which is linked to an \urbi
controller, this will allow you to control the world through \urbi.

Warning: don't forget to give different ports for each robot you add
in a \webots world. If this is not the case, some controllers will not
work.

After having started the simulation of the supervisor world, execute
the following lines:


\begin{urbiunchecked}
// Create a moving label.
l = new Label("\urbi for Webots");
l.size = 0.04;
l.r = 125 sin:10s ampli:125,
l.x = 0.2 sin:10s ampli:0.1,

// Manipulate the floor.
fl = new ManipulateNode("FLOOR");
fl.ty = -1 sin:10s ampli:0.5,
\end{urbiunchecked}

The first part of the script creates a label and defines a movement
with the \lstinline|sin| modifier. The second part moves the floor.

For a complete documentation of these nodes, please read the following
sections.

\subsection{Robots specific functions}

Many functions are directly available in \us to generate high-level
behaviour. Those features will be described in the next section.


\subsubsection{Aibo specific functions}

The following table sums up the Aibo's functions.

\begin{itemize}
\item \lstinline|robot.walk(\var{duration})|\\
  Walk for duration milliseconds (walk backward if duration is negative).
\item \lstinline|robot.stopwalk()|\\
  Interrupt the walk.
\item \lstinline|robot.turn(\var{duration})|\\
  Turn counter-clockwise for \var{duration} seconds (turn backward if
  duration is negative).
\item \lstinline|robot.stopturn()|\\
  Interrupt the turn.
\item \lstinline|robot.initial()|\\
  Initial position sitting down (stretch and lay).
\item \lstinline|robot.stretch()|\\
  Stretching like in the morning.
\item \lstinline|robot.lay()|\\
  Laying (sitting down).
\item \lstinline|robot.sit()|\\
  Sit on the back.
\item \lstinline|robot.beg()|\\
  Stand up with knees bent.
\item \lstinline|robot.stand()|\\
  Stand up.
\end{itemize}

The following slots are variables.
\begin{itemize}
\item \lstinline|robot.walkspeed|\\
  Speed of walk, the smaller the faster: period of a step. Defaults to
  1s.
\item \lstinline|robot.turnspeed|\\
  Speed of turn, the smaller the faster: period of a step. Defaults to
  1s.
\end{itemize}

More high-level behaviours are available in \file{ustd}, please read
the corresponding documentation to obtain more information.


\section{Making your own \urbi for \webots controllers}

\subsection{Create from an existing world}

As soon as you will want to go further, you will have to create your
own \urbi for \webots based controllers. Here is how to proceed:

\begin{enumerate}

\item Create a new directory in your \file{data} directory (say
  \file{foo}). This directory should be named as your new robot.

\item Copy into your \file{foo} directory the content of the
  \file{kiki} directory.

\item Edit the \nolinkurl{kiki.ini} file and rename it into your
  robot's name (i.e. \file{foo.ini} in this example).

\item Edit the \file{URBI.INI} file and change the line:

\begin{urbiunchecked}
load("kiki.ini");
\end{urbiunchecked}

by:

\begin{urbiunchecked}
// The name should match with the file you've just renamed.
load("foo.ini");
\end{urbiunchecked}

\item Copy the kiki world file (\file{worlds/kiki\_urbi.wbt} should be
  copied into \file{worlds/foo\_urbi.wbt} for example).

  Edit your new world file and check that the field
  \code{ControllerArgs} contains the directory you've just created. It
  should be, for example: \samp{-p 54000 50
    ../../../packages/urbi/data/foo}.  The Controller field should
  keep its value to \command{urbi}.
\end{enumerate}

Your robot is now ready to be controlled by \urbi. During the next
part, you'll learn how to customize the robot you have created.


\subsection{Customize}

To handle each robots' specificities, \webots uses a set of devices
which is fully supported by \urbi for \webots. Those devices are
created in a special file which is called like your robot in its data
directory.  With the previous example, it would have been the
\file{data/foo/foo.ini} file. This file should be like the following
piece of code:

\begin{urbiunchecked}
system.name = "/gostai/webots/kiki";
system.type = "webots";


wheelL = new DifferentialWheels("kiki", true);
alias wheelL.val wheelL.speed;
wheelR = new DifferentialWheels("kiki", false);
group wheels {wheelL, wheelR};

alias wheelR.val wheelR.speed;
eyeL = new DistanceSensor("ir0");
eyeR = new DistanceSensor("ir1");

// Standard groups
group software {};
group hardware {wheelL, wheelR, eyeL, eyeR};
group objects {software, hardware};

// Standard aliases
// etc.
\end{urbiunchecked}

The first line is your robot's name, you may edit this to any value.
The second line must keep its value.

After this, you need to create your robot's devices. It's simple,
follow the rule: \texttt{\var{devicename} = new
  \var{devicetype}("\var{name of the device's node in the world
    file}"); }

The node name can be retrieved easily from the \webots world tree
editor.

One exception is the \code{DifferentialWheel} device.  There are
always two lines. The first has its second argument set to \code{true}
and will create the left wheel. The second with its second argument
set to \code{false} create the right wheel.

The last step is editing the groups to add your new devices. The
hardware group should contain all the devices your robot uses. You may
also create subgroup to ease robot's programming.


\subsection{Urbi controller options}

The Urbi controller can take several options which modify its
behaviour.  You specify the controller options in the
\code{controllerArgs} field of the \webots world (\file{.wbt}) files.
The \code{controllerArgs} must be as follow:

\begin{shell}
controllerArgs [options] period [path1 path2 ...]
\end{shell}

\begin{description}
\item[period] base \urbi interval in milliseconds. You have to set the
  same period for the Urbi controller and for the \webots worlds. The
  period in the \webots world is defined in the field
  \code{basicTimeStep}.

\item[path] items are absolute or relative path elements searched in
  order to find Urbi files when 'load' is called.

\item[options]
  \begin{options}
  \item[-f] enable fast mode: the server will run as fast as possible
    and emulate the period specified.  Don't set \option{-f} option
    when there is ``runRealTime TRUE'' in the \webots world.  Always
    set \option{-f} otherwise.
  \item[-l \var{license\_key}] specify the license key to use
  \item[-p \var{port}] specify the TCP port \urbi will listen to.
  \end{options}
\end{description}


\section{Available UObjects}

\subsection{Robot devices UObjects}

\subsubsection{Accelerometer}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Accelerometer (string \var{NodeName}, string
    \var{ComponentName})}] Construct a new Accelerometer object.  The
  ``NodeName'' attribute is the value of the name field, in the
  Accelerometer node in \webots.  The ``ComponentName'' is the name of
  the Accelerometer component this object represent.  Because you need
  3 Accelerometer UObject to represent the \webots Accelerometer
  device. Each Accelerometer UObject represent one of the component of
  the \webots Accelerometer device.  ``ComponentName'' can take 3
  values: ``x'', ``y'' or ``z''.
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}

  This attribute let you enable or disable the Accelerometer device.
  By default it is set to 1, which means that the Accelerometer is
  enabled. If you set it to 0 it will disable it. NB: If you enable or
  disable one of the Accelerometer UObject component, then all the
  associated Accelerometer UObject components will also be enabled or
  disabled (ex: if you disable the y Accelerometer component, then the
  x and z Accelerometer components will also be disabled).

  To enable and disable the device we use the following \webots
  functions:

\begin{cxx}
void accelerometer_enable (DeviceTag sensor, unsigned short ms);
void accelerometer_disable (DeviceTag sensor);
\end{cxx}

    The frequency given to the enable function is the frequency of the
    \urbi controller (given in the ``controllerArgs'' field in the .wbt
    file).
\end{attribute}

\begin{attribute}{val}
  {readable}
  {float}
  {}
  The value of the component this UObject represent. So
  it is one of the 3 component of the \webots Accelerometer
  device. Either x, y or z.


  Retrieved with the following \webots functions:


\begin{cxx}
const float *accelerometer_get_values (DeviceTag sensor);
float accelerometer_value_x (float *array);
float accelerometer_value_y (float *array);
float accelerometer_value_z (float *array);
\end{cxx}
\end{attribute}

\end{itemize}

\subsubsection{Camera}

The camera UObject lets you control a \webots camera device. When your
robot possess a camera, and it use \urbi as a controller, you won't
see the camera image displayed on your computer screen unless you
create this camera UObject. You can create only one camera Urbi Object
by \webots camera device. Once you have created the camera, the camera
image will be displayed in the place defined by the .wbt world.


\paragraph{Constructor}

\noindent
\begin{description}
\item[{Camera (string \var{NodeName})}] Construct a new camera
  object. The ``NodeName'' attribute is the value of the name field,
  in the camera node in \webots.
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the camera
  device.  By default it is set to 1, which means that the camera is
  enabled. If you set it to 0 it will disable it.  To enable and
  disable the device we use the following \webots functions:

\begin{cxx}
void camera_enable (DeviceTag camera, unsigned short ms);
void camera_disable (DeviceTag camera);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable}
  {binary}
  {}
  The current image acquired by the camera. The format of
  the image can be RGB, JPEG or YCbCr, and is determined by the
  ``format'' attribute.  To retrieve the camera image we use the
  following \webots function:


\begin{cxx}
unsigned char *camera_get_image (DeviceTag camera);
\end{cxx}
\end{attribute}

\begin{attribute}{format}
  {readable, writable}
  {float}
  {\{0,1,2\}}
  The format of the camera image for the ``val''
  attribute. Set format to:

  \begin{description}
  \item[0] for JPEG;
  \item[1] for YCbCr;
  \item[2] for RGB;
  \end{description}
\end{attribute}

\begin{attribute}{rgb}
  {readable}
  {binary}
  {}
  The current image acquired by the camera with format RGB.
\end{attribute}

\begin{attribute}{jpeg}
  {readable}
  {binary}
  {}
  The current image acquired by the camera with format JPEG.
\end{attribute}

\begin{attribute}{ycbcr}
  {readable}
  {binary}
  {}
  The current image acquired by the camera with format YCbCr.
\end{attribute}

\begin{attribute}{jpegfactor}
  {readable, writeable}
  {float}
  {[0;100]}
  Compression factor in JPEG mode.
\end{attribute}

\begin{attribute}{width}
  {readable}
  {float}
  {}
  Image width. Retrieved with the following \webots function:
\begin{cxx}
unsigned short camera_get_width (DeviceTag camera);
\end{cxx}
\end{attribute}

\begin{attribute}{height}
  {readable}
  {float}
  {}
  Image height. Retrieved with the following \webots function:
\begin{cxx}
unsigned short camera_get_height (DeviceTag camera);
\end{cxx}
\end{attribute}

\begin{attribute}{xfov}
  {readable, writeable}
  {float}
  {}
  Image horizontal focal view.  Retrieved and set with
  the following \webots function:
\begin{cxx}
float camera_get_fov (DeviceTag camera);
void camera_set_fov (DeviceTag camera, float fov);
\end{cxx}
\end{attribute}

\begin{attribute}{yfov}
  {readable, writeable}
  {float}
  {}
  Image vertical focal view. Calculated from the value of
  the horizontal focal view with the formula: yfov = xfov * height /
  width.
\end{attribute}

\begin{attribute}{near}
  {readable}
  {float}
  {}
  Distance of the camera to the near OpenGL clipping
  plane.  Retrieved with the following \webots function:
\begin{cxx}
float camera_get_near (DeviceTag camera);
\end{cxx}
\end{attribute}

\begin{attribute}{far}
  {readable}
  {float}
  {}
  Distance of the camera to the far OpenGL clipping
  plane.  Retrieved with the following \webots function:
\begin{cxx}
float camera_get_far (DeviceTag camera);
\end{cxx}
\end{attribute}
\end{itemize}

\subsubsection{Differential Wheels}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{DifferentialWheels (string \var{NodeName}, boolean \var{isLeft})}]
  Construct a new differential wheels object. You have to set true or
  false in the isLeft field to set whether the wheel you are
  constructing is the left or right wheel.  NB: DifferentialWheels
  goes by pair, so you must create the two DifferentialWheels objects
  for them to behave correctly.

  Example:

\begin{urbiunchecked}
wheelL = new DifferentialWheels("e-puck", true);
wheelR = new DifferentialWheels("e-puck", false);
\end{urbiunchecked}
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{encoder}
  {readable, writeable}
  {float}
  {}
  Encoders are counters incremented each time a wheel
  turns. The amount added to the encoder is computed from the angle
  the wheel have been rotated and from the ``encoderResolution''
  parameter of the DifferentialWheels node. For convenience we also
  provide an ``encoderFactor'' which allows you to change easily the
  unit of the encoder on the Urbi side.  Hence, if the
  ``encoderResolution'' is 100, the ``encoderFactor'' is -{}1 and the
  wheel made a whole revolution, the corresponding encoder will have
  its value incremented by about 100 * -{}1 * 6.28 = -{}628.  Setting
  encoders value will not make the wheels rotate to reach the
  specified value, instead, it will simply reset the encoders with the
  specified value.  Retrieved and set with the following \webots
  functions:
\begin{cxx}
int differential_wheels_get_left_encoder (void);
int differential_wheels_get_right_encoder (void);
void differential_wheels_set_encoders (int left, int right);
\end{cxx}
\end{attribute}

\begin{attribute}{speed}
  {Permissions: readable, writeable}
  {float}
  {}
  Current speed of the wheels. The speed unit is defined
  by the ``speedUnit'' field of the \webots DifferentialWheels node. The
  default value is 0.1 radian per seconds. For convenience we also
  provide an ``speedFactor'' which allows you to change easily the unit
  of the speed on the Urbi side.  With a ``speedFactor'' of 10, a speed
  value of 20 will make the wheel rotate at a speed of 10 * 20 * 0.1 =
  20 radian per seconds.  Set with the following \webots function:
\begin{cxx}
void differential_wheels_set_speed(short left, short right);
\end{cxx}
\end{attribute}

\begin{attribute}{speedFactor}
  {readable, writeable}
  {float}
  {}
  Convenient variable to set the speed unit. See ``speed''
  attribute.
\end{attribute}

\begin{attribute}{encoderFactor}
  {readable, writeable}
  {float}
  {}
  Convenient variable to set the encoder unit. See
  ``encoder'' attribute
\end{attribute}

\end{itemize}

\subsubsection{Distance Sensor}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{DistanceSensor (string NodeName)}] Construct a new Distance
  Sensor object, corresponding to the DistanceSensor node in
  \webots. The ``NodeName'' attribute is the value of the name field,
  in the DistanceSensor node in \webots
\end{description}

\paragraph{Attributes}

\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the
  DistanceSensor device.  By default it is set to 1, which means that
  the DistanceSensor is enabled. If you set it to 0 it will disable
  it.

  To enable and disable the device we use the following \webots
  functions:
\begin{cxx}
void distance_sensor_enable (DeviceTag sensor, unsigned short ms);
void distance_sensor_disable (DeviceTag sensor);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable, writeable}
  {float}
  {}
  Distance returned by the sensor. If you want to change
 the unit of the distance sensor you can use the ``factor'' attribute,
 because the ``val'' attribute is multiplied by the ``factor'' attribute
 before being returned: ``val'' = ``val'' * ``factor''.

 Retrieved with the following \webots function:

\begin{cxx}
unsigned short distance_sensor_get_value  (DeviceTag sensor);
\end{cxx}
\end{attribute}

\begin{attribute}{factor}
  {readable, writeable}
  {float}
  {}
  Factor used to compute the distance sensor's value.
\end{attribute}
\end{itemize}

\subsubsection{Emitter}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Emitter (string NodeName)}] Construct a new Emitter
  component. The ``NodeName'' attribute is the value of the name
  field, in the Emitter node in \webots.

\end{description}

\paragraph{Functions}

\noindent
\begin{description}
\item[{send (UrbiVariable)}] Adds to the emitters's queue a packet
  corresponding to the data of the UrbiVariable, plus some
  informations on the type of the variable. Then the enqueued data
  packets will be sent to potential receivers (and removed from the
  emitter's queue) at the rate specified by the baudRate field of the
  Emitter node. On success this function returns 0. If the queue is
  currently full, 1 is returned and the packet will not be
  enqueued. The queue is considered to be full when the sum of bytes
  of all the enqueued packets exceeds the buffer size specified by the
  bufferSize field.  NB: You can send every type of \urbi variables
  with the send function EXCEPT UObjects variables.


  Example:


\begin{urbiunchecked}
var1 = "hello world";
emitter.send (var1);
// will send 13 bytes:
// '"','h','e','l','l','o',' ','w','o','r','l','d','"'
// note that the enclosing quotes ("") are also send, in order for the
// receiver to be able to recognize that the received data is a string
var2=BIN 11;hello world
emitter.send (var2),
// will send 20 bytes: 5 bytes for the BIN header, 2 bytes for the
// size, 1 byte for the ';', and 11 bytes for the actual data (hello
// world) (the BIN header size can augment if you set some information
// in the BIN header variable, like in images variables for example).
\end{urbiunchecked}

  Note that if you set the ``rawMode'' attribute to true, then the
  comportment of the send () function will change. When ``rawMode'' is
  true, you can only send BIN variables with the send () function, and
  only the data in the BIN variable is send.


\begin{urbiunchecked}
var2=BIN 11;hello world
emitter.rawMode = true;
emitter.send (var2);
/// Will send 11 bytes:
// 'h','e','l','l','o',' ','w','o','r','l','d'
// ie only the bytes that are in the data of the BIN variable.
\end{urbiunchecked}

Please note that since no type information is included in the send
data, an \urbi receiver won't be able to parse the data received and
won't be able to recreate the corresponding \urbi variable.

This function use the following \webots functions:

\begin{cxx}
int emitter_send_packet  (DeviceTag emitter, const void *data, int size);
\end{cxx}
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{bufferSize}
  {readable, writeable}
  {float}
  {}
  Size (in bytes) of the emission buffer. This
  corresponds to the value specified by the bufferSize field of the
  Emitter node. The buffer size indicates the maximal amount of data
  bytes that the emitter's queue can hold in total.

  Retrieved with the following \webots function:

\begin{cxx}
int emitter_get_buffer_size  (DeviceTag emitter);
\end{cxx}
\end{attribute}

\begin{attribute}{channel}
  {readable, writeable}
  {float}
  {}
  Emission channel. Change it to modifies the channel
  field of the corresponding Emitter node. Normally, an emitter can
  send data only to receivers that use the same channel. However, the
  value -{}1 can be used for broadcasting to all channels. By
  switching the channel number an emitter can selectively send data to
  different receivers.

  Retrieved and set with the following \webots functions:
\begin{cxx}
void emitter_set_channel  (DeviceTag emitter, int channel);
int emitter_get_channel (DeviceTag emitter);
\end{cxx}
\end{attribute}

\begin{attribute}{range}
  {readable, writeable}
  {float}
  {}
  Emission range. Change it to modifies the range field of
 the corresponding Emitter node. If the range is larger than the
 maxRange field of the Emitter node then the current range will be set
 to maxRange.

 Retrieved with the following \webots function:

\begin{cxx}
void emitter_set_range  (DeviceTag emitter, float range);
float emitter_get_range (DeviceTag emitter);
\end{cxx}
\end{attribute}

\begin{attribute}{rawMode}
  {readable, writeable}
  {float}
  {}
  Set this attribute to true to enable sending BIN
 variables in raw mode (ie only the data in BIN variables is
 send). Please see ``receive ()'' function for more information.
\end{attribute}
\end{itemize}

\subsubsection{Gps}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Gps (string \var{NodeName}, string \var{ComponentName})}]
  Construct a new Gps object.  The ``NodeName'' attribute is the value
  of the name field, in the Gps node in \webots.  The ``ComponentName''
  is the name of the Gps component this object represent.  Because you
  need 3 Gps UObject to represent the \webots Gps device. Each Gps
  UObject represent one of the component of the \webots Gps device.
  ``ComponentName'' can take 3 values: ``x'', ``y'' or ``z''.
\end{description}

\paragraph{Attributes}

\noindent
\begin{description}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the Gps
  device.  By default it is set to 1, which means that the Gps is
  enabled. If you set it to 0 it will disable it. NB: If you enable or
  disable one of the Gps UObject component, then all the associated
  Gps UObject components will also be enabled or disabled (ex: if you
  disable the y Gps component, then the x and z Gps components will
  also be disabled).

  To enable and disable the device we use the following \webots
  functions:

\begin{cxx}
void gps_enable  (DeviceTag sensor, unsigned short ms);
void gps_disable (DeviceTag sensor);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable}
  {float}
  {}
  The value of the component this UObject represent. So it
 is one of the 3 component of the \webots Gps device. Either x, y or z.


 Retrieved with the following \webots functions:


\begin{cxx}
const float *gps_get_matrix  (DeviceTag sensor);
float gps_position_x (float *matrix);
float gps_position_y (float *matrix);
float gps_position_z (float *matrix);
\end{cxx}
\end{attribute}

\begin{attribute}{angle}
  {readable}
  {float}
  {}
  Euler angles associated to the UObject component. If the
 component of this UObject is x or z, then the Euler angle can be
 interpreted as inclinometer angle value along either the local X or
 the local Z axis. If the component is y, then Euler angle can be
 interpreted as a compass angle value. NB: the angles are given in
 degrees !


          Retrieved with the following \webots functions:


\begin{cxx}
void gps_euler (const float *matrix, float *euler);
const float *gps_get_matrix  (DeviceTag sensor);
\end{cxx}
\end{attribute}

\end{description}

\subsubsection{Gripper}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Gripper (string \var{NodeName})}] Construct a new Gripper
  component. The ``NodeName'' attribute is the value of the name
  field, in the Gripper node in \webots.

\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{val}
  {readable, writeable}
  {float}
  {}
  Position of the Gripper device.

  Retrieved and set with the following \webots functions:

\begin{cxx}
float gripper_get_position  (DeviceTag gripper);
void gripper_set_position  (DeviceTag gripper, float position);
\end{cxx}
\end{attribute}

\begin{attribute}{resistivity}
  {readable}
  {float}
  {}
  the resistivity of the Gripper device.

  Retrieved with the following \webots function:

\begin{cxx}
float gripper_get_resistivity  (DeviceTag gripper);
\end{cxx}
\end{attribute}

\end{itemize}

\subsubsection{Keyboard}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Keyboard ()}] Construct a new Keyboard object. This object is
  used to retrieve the key codes corresponding to keys pressed on the
  keyboard.
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the Keyboard
  device.  By default it is set to 1, which means that the Keyboard is
  enabled. If you set it to 0 it will disable it.


  To enable and disable the device we use the following \webots functions:
\begin{cxx}
void robot_keyboard_enable(unsigned short ms);
void robot_keyboard_disable();
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable}
  {float}
  {}
  Key code corresponding to the key currently pressed on
  the keyboard. If no key is currently pressed, ``val'' equal 0.

  Retrieved with the following \webots function:
\begin{cxx}
int robot_keyboard_get_key();
\end{cxx}
\end{attribute}
\end{itemize}

\subsubsection{Led}

\paragraph{Constructor}

\begin{description}
\item[{Led (string \var{NodeName})}] Construct a new Led object. The
  ``NodeName'' attribute is the value of the name field, in the Led
  node in \webots
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{val}
  {readable, writeable}
  {float}
  {}
  Value of the led. Usually leds have two possible values,
  0 for Off and 1 for On, but it is also possible to use other values
  depending on the \webots model.

  Set with the following \webots function:
\begin{cxx}
void led_set (DeviceTag device, unsigned char value);
\end{cxx}
\end{attribute}

\end{itemize}

\subsubsection{Light Sensor}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{LightSensor (string \var{NodeName})}] Construct a new Light
  Sensor object. The ``NodeName'' attribute is the value of the name
  field, in the LightSensor node in \webots.

\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the
  LightSensor device.  By default it is set to 1, which means that the
  LightSensor is enabled. If you set it to 0 it will disable it.

  To enable and disable the device we use the following \webots functions:

\begin{cxx}
void light_sensor_enable (DeviceTag sensor, unsigned short ms);
void light_sensor_disable (DeviceTag sensor);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable}
  {float}
  {}
  Light value measured by the sensor. The values measured
  are computed from the lookup table defined in the corresponding
  \webots node.

  Retrieved with the following \webots function:
\begin{cxx}
unsigned short light_sensor_get_value  (DeviceTag sensor);
\end{cxx}
\end{attribute}

\end{itemize}

\subsubsection{Plunger}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Plunger (string \var{NodeName}, float \var{offValue}, float
    \var{onValue})}] Construct a new Plunger object. The ``NodeName''
  attribute is the value of the name field, in the Servo node in
  \webots. In \webots plunger objects do not exist. They are emulated by
  Servo with on and off modes represented by the min and max values of
  the Servo (we remind the reader that a plunger is a device with two
  states: On / Off). In Urbi Plungers usually varies from 0 to 1. So
  the offValue and onValue you have to pass to the constructor are the
  values corresponding to On and Off in \webots. NB: all values must be
  given in degree (while in \webots they are in radian) !
\end{description}

\paragraph{Attributes}

\begin{itemize}
\begin{attribute}{val}
  {readable, writeable}
  {float}
  {}
  The value of the plunger. When you set this value, the
  value that will be given to \webots is computed as follow: val *
  ((onValue -{} offValue) + offValue).  NB: all values must be given in
  degree (while in \webots they are in radian) !

  Retrieved and set with the following \webots function:
\begin{cxx}
float servo_get_position  (DeviceTag servo);
void servo_set_position  (DeviceTag servo, float position);
\end{cxx}
\end{attribute}
\end{itemize}

\subsubsection{Receiver}

\paragraph{Constructor}

\begin{description}
\item[{Receiver (string \var{NodeName})}] Construct a new Receiver
  component. The ``NodeName'' attribute is the value of the name
  field, in the Receiver node in \webots.
\end{description}

\paragraph{Functions}

\noindent
\begin{description}
\item[{receive ()}] Returns an \urbi variable corresponding to the
  data of the packet at the head of the reception queue. An \urbi
  receiver can only receive data from an \urbi emitter, because the
  \urbi emitter send the data corresponding to \urbi variables given
  to its emit () function, plus some informations on the type of the
  variable. The receiver then parse the received data to recreate the
  \urbi variable.  If the \urbi emitter is in rawMode, the Receiver
  won't be able to parse the received values.  So you have to set the
  receiver rawMode also. In raw mode, the receiver returns BIN
  variables containing the data received.  Please refers to \webots
  documentation for more information on the Receiver device.

  This function use the following \webots functions:

\begin{cxx}
const void *receiver_get_data  (DeviceTag receiver);
\end{cxx}

\item[{next ()}] Deletes the head packet. The next packet in the
  queue, if any, becomes the new head packet.

  This function use the following \webots functions:

\begin{cxx}
void receiver_next_packet  (DeviceTag receiver);
\end{cxx}
\end{description}

\paragraph{Attributes}

\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the Receiver
  device.  By default it is set to 1, which means that the Receiver is
  enabled. If you set it to 0 it will disable it.

  To enable and disable the device we use the following \webots functions:

\begin{cxx}
void receiver_enable  (DeviceTag receiver, unsigned short ms);
void receiver_disable (DeviceTag receiver);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{channel}
  {readable, writeable}
  {float}
  {}
  Reception channel. Normally, receiver can only receive
  data packets from emitters that use the same channel, however, the
  value -{}1 can be used to listen simultaneously to all channels.

  Retrieved and set with the following \webots functions:
\begin{cxx}
void receiver_set_channel  (DeviceTag receiver, int channel);
int receiver_get_channel (DeviceTag receiver);
\end{cxx}
\end{attribute}

\begin{attribute}{dataSize}
  {readable}
  {float}
  {}
  Number of data bytes present in the head packet of the
  reception queue. Since it is \urbi variables that are sent, the
  receiver need informations on the type of the variable to be able to
  retrieve it correctly. So dataSize is usually greater than the actual
  data size.

  Retrieved with the following \webots function:

\begin{cxx}
int receiver_get_data_size  (DeviceTag receiver);
\end{cxx}
\end{attribute}

\begin{attribute}{emitterDirection}
  {readable}
  {list of 3 float values}
  {}
  Normalized vector that indicates the direction of the
  emitter with respect to the receiver's coordinate system. The three
  vector components indicate respectively the x, y, and z-{}direction
  of the emitter.

  Retrieved with the following \webots function:
\begin{cxx}
const float *receiver_get_emitter_direction  (DeviceTag receiver);
\end{cxx}
\end{attribute}

\begin{attribute}{queueLength}
  {readable}
  {float}
  {}
  Number of data packets currently present in the
  receiver's queue.

  Retrieved with the following \webots function:
\begin{cxx}
int receiver_get_queue_length  (DeviceTag receiver);
\end{cxx}
\end{attribute}

\begin{attribute}{rawMode}
  {readable, writeable}
  {float}
  {}
  Set this attribute to true to enable receiving data in
  raw mode.  In raw mode the ``receive ()'' function will return BIN
  variables containing the data received. Use this mode when you the
  emitter emit non Urbi data.
\end{attribute}

\begin{attribute}{signalStrength}
  {readable}
  {float}
  {}
  Simulated signal strength at the time the last packet
  was transmitted.  This signal strength is equal to the inverse of the
  squared distance between the emitter and the receiver. In other
  words: s = 1 / r\^{}2, where s is the signal strength and r is the
  distance between emitter and receiver.

  Retrieved with the following \webots function:
\begin{cxx}
float receiver_get_signal_strength  (DeviceTag receiver);
\end{cxx}
\end{attribute}
\end{itemize}

\subsubsection{RobotName}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{RobotName ()}] Construct a new RobotName object. This object is
  used to retrieve the name of the robot associated to the \urbi
  controller.
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{val}
  {readable}
  {string}
  {}
  Name of the robot associated to the \urbi controller.

  Retrieved with the following \webots function:
\begin{cxx}
const char *robot_get_name();
\end{cxx}
\end{attribute}

\end{itemize}

\subsubsection{Servo}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{Servo (string \var{NodeName}, boolean \var{ForceFeedback})}]
  Construct a new Servo object. The ``NodeName'' attribute is the
  value of the name field, in the Servo node in \webots. The
  ``ForceFeedback'' attribute is a boolean that enable, when set to
  true, the measurement of the force applied to the joint. The value
  measured is available in the ``force'' attribute.  NB: all values
  must be given in degree (while in \webots they are in radian) !
\end{description}

\paragraph{Attributes}
\noindent
\begin{itemize}
\begin{attribute}{val}
  {readable, writeable}
  {float}
  {}
  Value of the servo. NB: all values must be given in
  degree (while in \webots they are in radian) !

  Retrieved and set with the following \webots functions:
\begin{cxx}
float servo_get_position  (DeviceTag servo);
void servo_set_position  (DeviceTag servo, float position);
\end{cxx}
\end{attribute}

\begin{attribute}{PGain}
  {writable}
  {float}
  {}
  changes the value of the P parameter of the
 P-{}controller. P is a parameter used to compute the current servo
 velocity Vc from the current position Pc and target position Pt, such
 that Vc = P * (Pt -{} Pc).  With a small P a long time is needed to
 reach the target position while a too large P can make the system
 unstable.  The default value of P is specified by controlP field of
 the corresponding \webots Servo node.


 Set with the following \webots function:

\begin{cxx}
void servo_set_control_p  (DeviceTag servo, float p);
\end{cxx}
\end{attribute}

\begin{attribute}{force}
  {readable}
  {float}
  {}
  Motor force measurement. ``force'' is equal to the amount
  of motor force that is currently being deployed by the servo in order
  to achieve the desired motion or hold the current position.  The
  measurement of this force is only available if you set the
  forceFeedback parameter to true in the constructor of Servo.

  Retrieved with the following \webots function:
\begin{cxx}
float servo_get_motor_force_feedback  (DeviceTag servo);
\end{cxx}
\end{attribute}
\end{itemize}

\subsubsection{Touch Sensor}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{TouchSensor (string \var{NodeName})}] Construct a new
  TouchSensor object. The ``NodeName'' attribute is the value of the
  name field, in the Touchsensor node in \webots
\end{description}

\paragraph{Attributes}

\noindent
\begin{itemize}
\begin{attribute}{load}
  {readable, writeable}
  {float}
  {\{0,1\}}
  This attribute let you enable or disable the
  TouchSensor device.  By default it is set to 1, which means that the
  TouchSensor is enabled. If you set it to 0 it will disable it.

  To enable and disable the device we use the following \webots
  functions:
\begin{cxx}
void touch_sensor_enable (DeviceTag sensor, unsigned short ms);
void touch_sensor_disable (DeviceTag sensor);
\end{cxx}

The frequency given to the enable function is the frequency of the
\urbi controller (given in the ``controllerArgs'' field in the .wbt
file).
\end{attribute}

\begin{attribute}{val}
  {readable, writable}
  {float}
  {}
  Value returned by the sensor, computed according to the
  lookup table in the TouchSensor node.

  Retrieved with the following \webots function:
\begin{cxx}
unsigned short touch_sensor_get_value  (DeviceTag sensor);
\end{cxx}
\end{attribute}

\end{itemize}

\subsection{Supervisor devices UObjects}

The supervisor UObjects are only available from a supervisor robot
(i.e. from the controller of a supervisor node in \webots).

This extended API allows \urbi to control the world and the whole
simulation.


\subsubsection{Label}
\paragraph{Constructor}
\noindent
\begin{description}
\item[{Label (string \var{text})}] Construct a new Label object and
  set its displayed text to ``text''.
\end{description}

\paragraph{Attributes}

\noindent
\begin{description}
\item[txt] Displayed text.
\item[x] X value.
\item[y] Y value.
\item[r] R component of the text's color.
\item[g] G component of the text's color.
\item[b] B component of the text's color.
\item[a] alpha component of the text's color.
\item[size] Text's size.
\end{description}

\subsubsection{Manipulate Node}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{ManipulateNode (string \var{nameOfWebotsManipulatedNode})}]
  Construct a new ManipulateNode object. ManipulateNode can only
  manipulate solid objects. Give the name of the manipulated object to
  the constructor of ManipulateNode.

Example:

\begin{urbiunchecked}
floor = new ManipulateNode("FLOOR");
\end{urbiunchecked}
\end{description}

\paragraph{Attributes}

\noindent
\begin{description}
\item[tx] Translation X value.
\item[ty] Translation Y value.
\item[tz] Translation Z value.
\item[ax] X angle value.
\item[ay] Y angle value.
\item[az] Z angle value.
\end{description}

\subsubsection{Simulation Controller}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{SimulationController ()}] Construct a new Simulation Controller
  object.
\end{description}

\paragraph{Functions}

\noindent
\begin{description}
\item[physicsReset ()] Send a request to the simulator process,
  asking to stop the movement of all physics enabled solids in the
  world. It means that for any Solid node containing a Physics node,
  the linear and angular velocities of the corresponding body is reset
  to 0, hence the inertia is stopped. This function is especially
  useful when resetting a robot at an initial position from which no
  initial inertia is required.  This function resets the seed of the
  random number generator used in \webots, so that noise based
  simulations can be be reproduced identically after calling this
  function.

\item[revert ()] Send a request to the simulator process, asking to
  reload the current world immediately. As a result of reloading the
  current world, the supervisor process and all the robot processes
  are terminated and restarted. You might want to save some data in a
  file from you supervisor program to be able to reload it when the
  supervisor controller restarts.

\item[quit ()] Send a request to the simulator process, asking to
  terminate and quit immediately. As a result of terminating the
  simulator process, all the controller processes, including the
  calling supervisor controller process will terminate.
\end{description}

\subsection{Other UObjects}

\subsubsection{UBinaryReader}

\paragraph{Constructor}

\noindent
\begin{description}
\item[{UBinaryReader ()}] Construct a new UBinaryReader.
\end{description}

\paragraph{Functions}

\noindent
\begin{description}
\item[{int set (UBinary \var{b})}] Set the UBinary you want to
  parse. You have to call the 'set' function before calling the 'read'
  function.  Return 0 in case of success, and 1 in case of error.

\item[{UList read (String \var{format})}] Read formated binary data
  from the UBinary, and return a list corresponding to the data which
  was read.

  \var{format} is a list of type identifiants separated by \samp{,}.

  The type identifiants describe a type, and are of the form
  \samp{\var{Type}[:n]} where \var{Type} can be:
  \begin{description}
  \item[i8]   8 bit integer
  \item[i16] 16 bit integer
  \item[i32] 32 bit integer
  \item[i64] 64 bit integer
  \item[u8]   8 bit unsigned integer
  \item[u16] 16 bit unsigned integer
  \item[u32] 32 bit unsigned integer
  \item[u64] 64 bit unsigned integer
  \item[f32] 32 bit float
  \item[f64] 64 bit float
  \item[c]    8 bit character
  \end{description}
  and where \samp{n} specify the number of times the UBinaryReader
  should read a value of this type.

  \samp{n} is optional (that is the meaning of the enclosing \samp{[}
  \samp{]} which are not part of the syntax).

  The function returns a list of values corresponding to the data
  read.  In case of character data, if you specify the \samp{n}
  parameter, then the characters are concateneted and put in a string.

  ex:
\begin{urbiunchecked}
p = new UBinaryReader();
a = BIN 10;abcdefghij   /// Create an UBinary which contains abcdefghij
p.set (a);              /// Set the UBinary in the reader.
p.read ("c,i8");        /// we read: a character then an 8 bits integer
[00175588] ["a", 98]    /// a is for the 'a' and 98 for the 'b' (8 bit ascii
                        /// code is 98)
p.index = 0;            /// Set the reading cursor to the begining.
p.read ("c,c:3,i8:2,i16"),
[00161064] ["a", "bcd", 101, 102, 26727]
p.index = 4;            /// Set the reading cursor to read the 5th character
p.read ("c:5"),
[00169480] ["efghi"]
\end{urbiunchecked}

  In case of error, the function stop reading, and return a list
  containing the values that were successfully read until the error
  occur. The function then set the reading cursor 'index' to -{}1, and
  set an error message in the 'error' attribute.
\end{description}

\paragraph{Attributes}

\noindent
\begin{description}
\item[index] Index of the reading cursor. When you read from an
  UBinary with the 'read' function, this index is automatically
  updated so that the next read will occur where the previous read
  stopped.

  You can change the position of the reading cursor by assigning a new
  value to 'index'. Note that the begining of the UBinary is
  associated to a value of 0 for 'index'.

  'index' cannot be greater than the UBinary size.

  When a reading error occur, 'index' is set to -1, and you have to
  change it's value manually to continue reading.

\item[size] The size of the UBinary currently read.

\item[error] In case of error, this attribute contains a readable
  error message corresponding to the error.
\end{description}


\section{Develop your own UObjects}

This section describes how to create new UObjects and integrate them
in your \urbi controller to use them from .


\subsection{Code your UObjects}

To create your own UObjects, please refer to the online documentation
on Gostai website: \url{http://www.gostai.com/doc/en/uobject/}.


\subsection{Compile}

\subsubsection{Windows}

Currently we only support compilation with Mingw under windows. We
recommend that you use DevCpp (which uses Mingw compiler) to compile
your projects.  We provide a sample DevCpp project in
\file{URBI\_DIRECTORY/doc/sample}.  The directory contains two files:
\begin{files*}
\item[sample.dev] the DevCpp project file
\item[helloworld.cpp] a sample UObject which prints \samp{Hello
    World!} at initialisation. You may replace this file with your own
  UObject files.
\end{files*}

If you do not want to use this sample project, you have to do the
following: compile your UObject files and link with the libraries we
provide. This to generate an executable that you will name urbi.exe.
Here is the list of option that you have to provide to your compiler:
\begin{itemize}
\item Include path: \file{URBI\_DIRECTORY/SDK/include}. By default it
  is \verb+c:\Program Files\GOSTAI\Urbi Webots 1.0\SDK\include+.

\item Library path:
  \begin{files*}
  \item[URBI\_DIRECTORY/SDK/lib] By default it is
    \verb+c:\Program Files\GOSTAI\Urbi Webots 1.0\SDK\lib+.

  \item[WEBOTS\_DIRECTORY/lib] By default it is
    \verb+c:\Program Files\Webots\lib+.
  \end{files*}

\item Library to link with:
  \begin{files*}
  \item[liburbicore.a] you have to specify that you want all the
    symbol of the library to be included, so you have to add the
    option \option{-whole-archive} to the link line. You may write it
    as follow: \samp{-Wl,-whole-archive -lurbicore
      -Wl,-no-whole-archive}.

  \item[libjpeg.a] you MUST link with the static libjpeg that we
    provide in \file{URBI\_DIRECTORY/SDK/lib}
  \item[libeay32.dll]
  \item[libController.dll]
  \item[ws2\_32.dll]
  \item[libgdi32.dll]
  \item[Iphlpapi.dll]
  \item[libboost\_thread-mt.a]
  \end{files*}
\end{itemize}
We distribute separately some version of boost 1.34.1 library. You can
download them for Mingw here: \url{http://www.gostai.com/boost/}.
Again we strongly advise you to use the sample DevCpp that we provide.


\subsubsection{Linux and MacOs}

To compile under Linux use umake. Please refer to the documentation on
Gostai website: \url{http://www.gostai.com/doc/en/umake/}.  With a
default install of \webots and \urbi for \webots, you just have to be in
the directory containing your source UObject files and type the
command:

\begin{shell}
$ umake-engine -C webots -o urbi
\end{shell}

Important: since release 1.5 you also need to link with boost 1.34.1
library.  In particular you need to link with
\file{libboost\_thread}. Under Linux we provide binaries for boost
library 1.34.1 on this page: \url{http://www.gostai.com/boost/}. The
binary available under Linux are compiled with GCC 4.1 and GCC 3.3. If
you use a different compiler you have to compile yourself the
libraries. Please go to: \url{http://www.boost.org/} to download a
source tarball and install it.  We don't provide any tarballs for
Mac. You can get the binaries using the install system MacPorts:
\url{http://www.macports.org} or by compiling Boost 1.34.1 from the
sources.


\subsection{Use the generated executable}

To use the executable you have generated (either \command{urbi.exe} on
Windows or \command{urbi} on Linux) simply replace the \urbi
controller in \file{webots/projects/default/controllers/urbi/} by your
executable. That's it! Launch \webots, connect to the \urbi server,
allocate a new object of type your UObject and use it.
