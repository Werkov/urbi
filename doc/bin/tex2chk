#! /usr/bin/perl -w

=head1 NAME

  tex2chk - extract urbiscript test files from the LaTeX documentation.

=head1 SYNOPSIS

  tex2chk [OPTIONS...] FILE...

=head1 DESCRIPTION

Read LaTeX files, and extract chk files for each urbiscript
environment listing.  The label is used to name the created chk
file.  If there is no label, FILE:LINE is used to name the file.

lstlisting has a notion of split listing, using the attribute "name"
to decide how pieces must be glued together (this is used when
numbering).  Listings with the same "name" are glued togeter.  This
is especially needed when a listing uses objects defined in earlier
listings.

Unnamed snippets are merged by default, unless the (second one) has
the attribute [firstnumber=1].

=head1 OPTIONS

General options:

=over 4

=item B<-l>, B<--no-lines>

Don't generate the special //#line lines.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

=cut

use strict;
use File::Basename;
use File::Path qw(mkpath rmtree);
use IO::File;

# Tests with a name.
my %by_name;

# All the tests.
my %chk;

# The prefix for the log messages.
my $me = basename($0);

# move-if-changed.
my $move_if_change = $ENV{move_if_change} || "move-if-change";

# The name of the previous test.
my $previous_label = undef;

# Whether we should generate the synclines.
my $synclines = 1;

# Verbosity level.  Ignored.
my $verbose = 2;

# A regexp that matches 0 or more repetitions of either a
# non-backtracking word with no parens/braces, or a braced group, or a
# parenthezied group.
#
# Note that since it is greedy and non-backtracking, it might eat too
# much.  Use $braced instead.
my $balanced;
$balanced =
  qr{
       (?:
          (?> [^(){}\[\]]+ )         # Non-parens/braces without backtracking
        |
          \( (??{ $balanced }) \)     # Group with matching parens
        |
          \{ (??{ $balanced }) \}     # Group with matching braces
        |
          \[ (??{ $balanced }) \]     # Group with matching brackets
       )*
    }x;

# Same as above, but allow backtracking on non-braced parts, so that
# we don't eat places where we want to catch operators.
my $braced =
  qr{
      (?:
          \{ $balanced \}
        | \( $balanced \)
        | \[ $balanced \]
        | [^(){}\[\]]+        # Non-parens/braces with backtracking
      )*
    }x;

# The (Boolean) operators in urbiscript.  Beware of operators "nested"
# in other operators: we must not cut "===" into "==" as operator, and
# "=" as lhs or rhs.
my $operators =
  qr{
      (?<![!=])
      (?:
         [!=]={1, 2} # ==, ===, !=, !==.
       | [<>]=?      # <, <=, >, >=.
       | =?~=        # =~=, ~=.
      )
      (?![=])
    }x;


=head1 FUNCTIONS

=over 4

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  map { print STDERR "$me: " . "  " x $level . "$_\n" } @message
    if $level <= $verbose;
}

=item C<strip($string)>

Return C<$string> stripped from leading/trailing spaces.

=cut

sub strip ($)
{
  local ($_) = @_;
  s/^\s+//;
  s/\s+$//g;
  $_;
}


=item C<line(\%lst)>

Issue an urbiscript //#line for test $lst.

=cut

sub lineno (\%)
{
  my ($lst) = @_;
  my $line = $$lst{_line};
  my $file = $$lst{_file};
  "syncline << \"$file:$line\";\n"
  . "[01234567:syncline] \"$file:$line\"\n"
  . ($synclines ? "//#line $line \"$file\"\n" : "")
}


=item C<register($file, $line, \%lst)>

Register a listing.

=cut

sub register ($$\%)
{
  my ($file, $line, $lst) = @_;
  # If this listing has a name which is already used, append to
  # this existing listing.
  my $name = $$lst{name};
  if ($name)
    {
      if ($by_name{$name})
        {
          $by_name{$name}{_contents} .=
            "\n\n"
            . lineno(%$lst)
            . $$lst{_contents};
          return;
        }
      else
        {
          $by_name{$name} = $lst;
        }
    }

  my $label = $$lst{label};
  if ($chk{$label})
    {
      # Collision.
      verbose 0,
        "warning: label `$label' defined twice",
        "  $chk{$label}{_location}: first definition",
        "  $file:$line: second definition";
    }
  # By default, fuse the test cases.  Unless we use "[firstnumber=1]"
  # and there is a preceding one.
  elsif (!defined $previous_label
         || (exists $$lst{firstnumber}
             && $$lst{firstnumber} eq "1"))
    {
      $chk{$label} = $lst;
      $previous_label = $label;
    }
  else
    {
      # Extension of the previous listing.
      $chk{$previous_label}{_contents} .=
        "\n";

      # Do not issue a syncline if the content to append starts with a
      # result.  This happens for instance in slides where the input
      # is on lhs, and the result on rhs.  In which case, our
      # (verbose) synclines would insert an intermediate output (the
      # syncline) that would cause some misaligned results.
      $chk{$previous_label}{_contents} .=
        "\n"
        . lineno(%$lst)
        unless $$lst{_contents} =~ /^\n*\[\d{8}\]/s;

      $chk{$previous_label}{_contents} .=
        $$lst{_contents};
    }
}

=item C<assert_name($op)>

Map an operator name to its (alphabetical) suffix for assert.  For
instance C<==> maps to C<eq>.

=cut

sub assert_name($)
{
  my ($op) = @_;
  my %op =
    (
     '!='  => 'ne',
     '!==' => 'mne',
     '<'   => 'lt',
     '<='  => 'le',
     '=='  => 'eq',
     '===' => 'meq',
     '>'   => 'gt',
     '>='  => 'ge',
    );
  "assert_" . $op{$op};
}

=item C<process_listing($file, $line, $lst)>

Process the lstlisting environment C<$lst>, which was found in
C<$file> at C<$line>.  C<$lst> is the full environment, from its
C<\begin> to its C<\end>.

=cut

sub process_listing ($$$)
{
  my ($file, $line, $lst) = @_;
#  print STDERR "[[[$lst]]]\n";

  my $loc = sprintf "%s:%04d", $file, $line;
  my %res;
  $res{'_file'} = $file;
  $res{'_line'} = $line;
  $res{'_location'} = $loc;

  $lst =~
     /
       \\begin{(\w+)}            # $1 environment type.
       (?:\[((?:[^\[\]]|\[[^\]]*\])*)\])?  # $2 optional options.
                    # Optional argument may include `[...]'.
       \n
       (.*)\n                 # $3 contents
       \\end{\w+}
     /xs;

  my $env = $1;
  my $options = $2;
  my $content = $3;

  $res{'_contents'} =
    ($env eq 'urbiassert') ? "assert {\n$content\n};" : "$content";

#  print STDERR "$2\n";

  # assert_eq is clearer when there are failures, but it is not nice
  # looking in the documentation.  Beware of === and !== that contain
  # ==.
  #
  # Be also woried about precedence.  1 < 2 == true should not be
  # cut on `<'.  I don't feel like parsing urbi in Perl...
  $res{'_contents'} =~
    s{^(\s*)                 # $1 indentation
       assert
       \s*\(
       ($braced)             # $2 lhs
       \s*
       (?<![!=])
       (<|<=|>|>=|!=|==|===|!==)     # $3 operator
       (?![=])\s*}
     { $1 . assert_name($3) . '(' . strip ($2) . ", "}gmsex;

  # Decode and normalize the options.
  if ($options)
  {
    foreach my $opt (split (/\s*,\s*/, $options))
    {
      $opt =~ /(\w+)\s*=\s*(.*)/;
      $res{$1} = $2;
    }
  }

  # If there is no label defined, use the location.
  if (defined $res{label})
  {
    # Get rid of the "lst:" prefix from the labels.
    $res{label} =~ s/^lst://;
    # float-new -> new, since we're in float/ anyway.
    (my $base = $file) =~ s,.*/,,;
    $base =~ s,\..*,,;
    $res{label} =~ s/^$base-//;
  }
  else
  {
    $res{label} = $res{_location};
    # Remove the directory part of the file.
    $res{label} =~ s,^.*/,,;
    $res{label} =~ s/\.tex//;
  }

  # escapeinside: meta-character to tell lstlisting to delegate the
  # processing to LaTeX.  Must be ignored for test extraction.
  if (defined $res{escapeinside})
  {
    $res{'_contents'} =~ s/[$res{escapeinside}]//g;
  }

  # Make dislikes colon in file names.
  $res{label} =~ s/:/-/g;

  # Clean up the contents.
  $res{_contents} =~ s/:hide\]/\]/g;

  return %res;
}


=item C<process_file($file)>

C<$file> is a complete path, including the C<$ENV{srcdir}> part.

=cut

sub process_file ($)
{
  my ($file) = @_;
  my $in = new IO::File $file
      or die "cannot open $file";

  # The last part of the file name, i.e., without the $ENV{srcdir}
  # part.  (../../doc/tests/specs/boolean/boolean-24.chk ->
  # doc/tests/specs/boolean/boolean-24.chk with srcdir = ../../doc).
  my $base = $file;
  $base =~ s,^$ENV{srcdir},doc,
    if defined $ENV{srcdir};

  local $_;
  my $test;
  my $line;
  # The current environment: urbiassert or urbiscript or undef.
  my $environment;
  while ($_ = $in->getline)
  {
    if (!defined $environment
        && /^\\begin{(urbiassert|urbiscript)}/)
      {
        $environment = $1;
        # Issue a #line for the first line of Urbi, not the LaTeX line.
        $line = $in->input_line_number + 1;
        $test = $_;
      }
    elsif (defined $environment
           && /^\\end{$environment}/)
      {
       $test .= $_;
        my %res = process_listing $base, $line, $test;
        register ($base, $line, %res);
        $environment = undef;
      }
    elsif (defined $environment)
      {
        $test .= $_;
      }
  }
}


=item C<dump_chk($dir)>

Generate all the *chk files and their associated test.mk.  Remove the
old test files that remain in C<$dir>.  Remove them *after* having
generated the new ones: removing them all beforehand kills the
timestamps and will rerun test cases uselessly.

=cut

sub dump_chk ($)
{
  my ($dir) = @_;

  # The test files that currently exist.
  my %old_file = map { $_ => 1 } <$dir/*.chk>;

  # The created test files.
  my %file;

  # Generate the files.
  for my $k (keys %chk)
  {
    my %c = %{$chk{$k}};
    my $file = "$dir/$c{label}.chk";
    $file{$file} = 1;
    my $out = new IO::File ">$file.tmp"
        or die "cannot create $file.tmp: $!";
    print $out lineno(%c);
    print $out "$c{_contents}\n";
    system ("$move_if_change --color -I '^//' $file.tmp $file") == 0
      or die "$move_if_change failed: $?";
  }

  # Remove the old test files.
  unlink grep { !$file{$_} } keys %old_file;

  # Generate the Makefile.
  my $local_mk = "$dir/test.mk";
  my $mk = new IO::File ">$local_mk"
      or die "cannot create $local_mk: $!";

  my @file = keys %file;
  # Do not include the ../.. stuff in the Makefile.
  map { s,^$ENV{srcdir}/,, } @file
    if defined $ENV{srcdir};

  # Output in order.  It would be nice to have a combinaison between
  # alphabetical and numerical, so that abc-2 < abc-10.
  @file = sort @file;
  print $mk join ("\t\\\n  ", "TESTS += ", @file), "\n";
}


=item C<translate($input)>

Read the LaTeX file C<$input>, and generate the corresponding
directory (*.chk files, and test.mk).

=cut

sub translate ($)
{
  my ($input) = @_;
  process_file $input;
  # The directory we will output the tests in.
  my $dir = $input;
  $dir =~ s,^$ENV{srcdir},$&/tests,
    if defined $ENV{srcdir};
  $dir =~ s/\.tex$//;

  if (! -d $dir)
    {
      mkpath $dir
        or die "cannot mkpath $dir: $!";
    }
  dump_chk $dir;
}


=item C<help($verbose)>

Generate the B<--help> message.  Generates the full man page when
C<$verbose>.

=cut

sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Generate Urbi *.chk files from LaTeX files",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

=item C<getopt>

Process the command line options.

=cut

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "h|help"        => sub { help ($verbose) },
    "l|no-lines"    => sub { $synclines = 0 },
    "q|quiet"       => sub { --$verbose },
    "v|verbose"     => sub { ++$verbose },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;
}

## ------ ##
## Main.  ##
## ------ ##

getopt;
map { translate $_; } @ARGV;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
