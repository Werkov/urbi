#! /usr/bin/perl -w

=head1 NAME

=head1 SYNOPSIS

  git-version-gen [OPTIONS...]

=head1 DESCRIPTION

Read a LaTeX file, and extract chk files for each urbiscript
environment listing.  The label is used to name the created chk
file.  If there is no label, FILE:LINE is used to name the file.

lstlisting has a notion of split listing, using the attribute "name"
to decide how pieces must be glued together (this is used when
numbering).  Listings with the same "name" are glued togeter.  This
is especially needed when a listing uses objects defined in earlier
listings.

Another means to glue together urbiscript snippets is to use the
attribute firstnumber=last in the snippet that should be fused with
the previous one.

=head1 OPTIONS

General options:

=over 4

=item B<-l>, B<--no-lines>

Don't generate the special //#line lines.

=back

=head1 FUNCTIONS

=over 4

=cut

use strict;
use English;
use IO::File;
use File::Path qw(mkpath rmtree);

# All the tests.
my %chk;

# Those with a name.
my %by_name;

# The name of the previous test.
my $previous_label = undef;

# move-if-changed.
my $move_if_change = $ENV{move_if_change} || "move-if-change";

# Whether we should generate the synclines.
my $synclines = 1;

# Verbosity level.  Ignored.
my $verbose = 2;

# A regexp that matches 0 or more repetitions of either a
# non-backtracking word with no parens/braces, or a braced group, or a
# parenthezied group.
#
# Note that since it is greedy and non-backtracking, it might eat too
# much.  Use $braced instead.
my $balanced;
$balanced =
  qr{
       (?:
          (?> [^(){}\[\]]+ )         # Non-parens/braces without backtracking
        |
          \( (??{ $balanced }) \)     # Group with matching parens
        |
          \{ (??{ $balanced }) \}     # Group with matching braces
        |
          \[ (??{ $balanced }) \]     # Group with matching brackets
       )*
    }x;

# Same as above, but allow backtracking on non-braced parts, so that
# we don't eat places where we want to catch operators.
my $braced =
  qr{
      (?:
          \{ $balanced \}
        | \( $balanced \)
        | \[ $balanced \]
        | [^(){}\[\]]+        # Non-parens/braces with backtracking
      )*
    }x;

# The (Boolean) operators in urbiscript.  Beware of operators "nested"
# in other operators: we must not cut "===" into "==" as operator, and
# "=" as lhs or rhs.
my $operators =
  qr{
      (?<![!=])
      (?:
         [!=]={1, 2} # ==, ===, !=, !==.
       | [<>]=?      # <, <=, >, >=.
       | =?~=        # =~=, ~=.
      )
      (?![=])
    }x;


# strip $STRING
# -------------
# Kill leading/trailing spaces.
sub strip ($)
{
  local ($_) = @_;
  s/^\s+//;
  s/\s+$//g;
  $_;
}

# lineno
# ------
# Issue an urbiscript //#line for test $lst.
sub lineno (\%)
{
  my ($lst) = @_;
  my $line = $$lst{_line};
  my $file = $$lst{_file};
  "syncline << \"$file:$line\";\n"
  . "[01234567:syncline] \"$file:$line\"\n"
  . ($synclines ? "//#line $line \"$file\"\n" : "")
}

# register ($FILE, $LINE, \%LST)
# ------------------------------
# Register a listing.
sub register ($$\%)
{
  my ($file, $line, $lst) = @_;
  # If this listing has a name which is already used, append to
  # this existing listing.
  my $name = $$lst{name};
  if ($name)
    {
      if ($by_name{$name})
        {
          $by_name{$name}{_contents} .=
            "\n\n"
            . lineno(%$lst)
            . $$lst{_contents};
          return;
        }
      else
        {
          $by_name{$name} = $lst;
        }
    }

  my $label = $$lst{label};
  if ($chk{$label})
    {
      # Collision.
      print STDERR
        "warning: label `$label' defined twice\n",
        "  $chk{$label}{_location}: first definition\n",
        "  $file:$line: second definition\n";
    }
  elsif (exists $$lst{firstnumber}
         && $$lst{firstnumber} eq "last")
    {
      # Extension of the previous listing.
      die "$file:$line: [firstnumber=last] used without preceding listing\n"
        unless defined $previous_label;
      $chk{$previous_label}{_contents} .=
        "\n\n"
        . lineno(%$lst)
        . $$lst{_contents};
    }
  else
    {
      $chk{$label} = $lst;
      $previous_label = $label;
    }
}

sub assert_name($)
{
  my ($op) = @_;
  my %op =
    (
     '!='  => 'ne',
     '!==' => 'mne',
     '<'   => 'lt',
     '<='  => 'le',
     '=='  => 'eq',
     '===' => 'meq',
     '>'   => 'gt',
     '>='  => 'ge',
    );
  "assert_" . $op{$op};
}

sub process_listing ($$$)
{
  my ($file, $line, $lst) = @_;
#  print STDERR "[[[$lst]]]\n";

  my $loc = "$file:$line";
  my %res;
  $res{'_file'} = $file;
  $res{'_line'} = $line;
  $res{'_location'} = $loc;

  $lst =~
     /
       \\begin{(\w+)}            # $1 environment type.
       (?:\[((?:[^\[\]]|\[[^\]]*\])*)\])?  # $2 optional options.
                    # Optional argument may include `[...]'.
       \n
       (.*)\n                 # $3 contents
       \\end{\w+}
     /xs;

  my $env = $1;
  my $options = $2;
  my $content = $3;

  $res{'_contents'} =
    ($env eq 'urbiassert') ? "assert {\n$content\n};" : "$content";

#  print STDERR "$2\n";

  # assert_eq is clearer when there are failures, but it is not nice
  # looking in the documentation.  Beware of === and !== that contain
  # ==.
  #
  # Be also woried about precedence.  1 < 2 == true should not be
  # cut on `<'.  I don't feel like parsing urbi in Perl...
  $res{'_contents'} =~
    s{^(\s*)                 # $1 indentation
       assert
       \s*\(
       ($braced)             # $2 lhs
       \s*
       (?<![!=])
       (<|<=|>|>=|!=|==|===|!==)     # $3 operator
       (?![=])\s*}
     { $1 . assert_name($3) . '(' . strip ($2) . ", "}gmsex;

  # Decode and normalize the options.
  if ($options)
  {
    foreach my $opt (split (/\s*,\s*/, $options))
    {
      $opt =~ /(\w+)\s*=\s*(.*)/;
      $res{$1} = $2;
    }
  }

  # If there is no label defined, use the location.
  if (defined $res{label})
  {
    # Get rid of the "lst:" prefix from the labels.
    $res{label} =~ s/^lst://;
    # float-new -> new, since we're in float/ anyway.
    (my $base = $file) =~ s,.*/,,;
    $base =~ s,\..*,,;
    $res{label} =~ s/^$base-//;
  }
  else
  {
    $res{label} = $res{_location};
    # Remove the directory part of the file.
    $res{label} =~ s,^.*/,,;
    $res{label} =~ s/\.tex//;
  }

  # Make dislikes colon in file names.
  $res{label} =~ s/:/-/g;

  # Clean up the contents.
  $res{_contents} =~ s/:hide\]/\]/g;

  return %res;
}

# process_file $FILE
# ------------------
# $FILE is a complete path, including the $ENV{srcdir} part.
sub process_file ($)
{
  my ($file) = @_;
  my $in = new IO::File $file
      or die "cannot open $file";

  # The last part of the file name, i.e., without the $ENV{srcdir}
  # part.  (../../doc/tests/specs/boolean/boolean-24.chk ->
  # doc/tests/specs/boolean/boolean-24.chk with srcdir = ../../doc).
  my $base = $file;
  $base =~ s,^$ENV{srcdir},doc,
    if defined $ENV{srcdir};

  local $_;
  my $test;
  my $line;
  # The current environment: urbiassert or urbiscript or undef.
  my $environment;
  while ($_ = $in->getline)
  {
    if (!defined $environment
        && /^\\begin{(urbiassert|urbiscript)}/)
      {
        $environment = $1;
        # Issue a #line for the first line of Urbi, not the LaTeX line.
        $line = $in->input_line_number + 1;
        $test = $_;
      }
    elsif (defined $environment
           && /^\\end{$environment}/)
      {
       $test .= $_;
        my %res = process_listing $base, $line, $test;
        register ($base, $line, %res);
        $environment = undef;
      }
    elsif (defined $environment)
      {
        $test .= $_;
      }
  }
}

# dump_chk $DIR
# -------------
# Generate all the *chk files and their associated test.mk.  Remove
# the old test files that remain in $DIR.  Remove them *after* having
# generated the new ones: removing them all beforehand kills the
# timestamps and will rerun test cases uselessly.
sub dump_chk ($)
{
  my ($dir) = @_;

  # The test files that currently exist.
  my %old_file = map { $_ => 1 } <$dir/*.chk>;

  # The created test files.
  my %file;

  # Generate the files.
  for my $k (keys %chk)
  {
    my %c = %{$chk{$k}};
    my $file = "$dir/$c{label}.chk";
    $file{$file} = 1;
    my $out = new IO::File ">$file.tmp"
        or die "cannot create $file.tmp: $!";
    print $out lineno(%c);
    print $out "$c{_contents}\n";
    system ("$move_if_change --color -I '^//' $file.tmp $file") == 0
      or die "$move_if_change failed: $?";
  }

  # Remove the old test files.
  unlink grep { !$file{$_} } keys %old_file;

  # Generate the Makefile.
  my $local_mk = "$dir/test.mk";
  my $mk = new IO::File ">$local_mk"
      or die "cannot create $local_mk: $!";

  my @file = keys %file;
  # Do not include the ../.. stuff in the Makefile.
  map { s,^$ENV{srcdir}/,, } @file
    if defined $ENV{srcdir};

  # Output in order.  It would be nice to have a combinaison between
  # alphabetical and numerical, so that abc-2 < abc-10.
  @file = sort @file;
  print $mk join ("\t\\\n  ", "TESTS += ", @file), "\n";
}


=item C<translate($input)>

Read the LaTeX file C<$input>, and generate the corresponding
directory (*.chk files, and test.mk).

=cut

sub translate ($)
{
  my ($input) = @_;
  process_file $input;
  # The directory we will output the tests in.
  my $dir = $input;
  $dir =~ s,^$ENV{srcdir},$&/tests,
    if defined $ENV{srcdir};
  $dir =~ s/\.tex$//;

  if (! -d $dir)
    {
      mkpath $dir
        or die "cannot mkpath $dir: $!";
    }
  dump_chk $dir;
}

=item C<help>

Generate the B<--help> message.  Generates the full man page when
C<$verbose>.

=cut

sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Generate Urbi *.chk files from LaTeX files",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "h|help"        => sub { help ($verbose) },
    "l|no-lines"    => sub { $synclines = 0 },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;
}

## ------ ##
## Main.  ##
## ------ ##

getopt;
map { translate $_; } @ARGV;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:

