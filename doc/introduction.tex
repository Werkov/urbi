\chapter{Introduction}

\section{\urbi and UObjects}

\urbi makes easier the orchestration of independent, concurrent,
components.  It was first designed for robotics: it provides all the
needed features to coordinate the execution of various components
(actuators, sensors, software devices that provide features such as
text-to-speech, face recognition and so forth).  Traditional languages
such as \Cxx are definitely very adequate to program the local,
low-level, handling of these hardware or software devices; indeed one
needs efficiency, small memory footprint, and access to low-level
hardware details.  Yet, when it comes to orchestration and to
coordination between components, in a word, when it comes to
\emph{addressing concurrency}, such languages are no longer adequate.

Rather, one has to select a middleware infrastructure in order to be
able to use remote components as if they were local, to allow
concurrent execution, to make synchronous or asynchronous requests and
so forth.  The \dfn{UObject} architecture provides exactly this: a
common API which allows conforming components to be used seamlessly in
highly concurrent settings.  Components need not be designed with
UObjects in mind, rather, UObjects are typically ``shells'' around
``regular'' components.

As a quite magical feature that comes for free, components with an
UObject interface are naturally supported by the \us programming
language.  This can be a tremendous help: one can interact with these
components (making queries, changing them, observing their state,
monitoring various kinds of events and so forth), which provides a
huge speed-up during development.

Finally, note that, although made with robots in mind, the UObject
architecture is well suited to tame any heavily concurrent
environment, such as video games.

\section{\urbi and \us}

\us is a programming language primarily designed for robotics. It's a
dynamic, prototype-based, object-oriented scripting language. It
supports and emphasizes parallel and event-based programming, which
are very popular paradigms in robotics, by providing core primitives
and language constructs.

Its main features are:
\begin{itemize}
\item designed to be syntactically close to \Cxx. If you know \C or
  \Cxx, you can easily write \us programs.
\item fully integrated with \Cxx. You can bind \Cxx classes in \us
  seamlessly. \us is also integrated with many other languages such as
  \java, \matlab or \python.
\item object-oriented. It supports encapsulation, inheritance and
  inclusion polymorphism. Dynamic dispatching is available through
  monomethods --- just as \Cxx, \Cs or \java.
\item parallelism at the core of its semantics. It provides you with
  natural constructs to run and control high numbers of interacting
  concurrent tasks.
\item event-based programming. Triggering events and reacting to them
  is absolutely straightforward.
\item \us supports functional programming, inspired from languages
  such as \lisp or \caml. This includes first class functions and
  pattern matching.
\item client/server architecture.  The interpreter accepts multiple
  connections from different sources (human users, robots, other
  servers \ldots) and enables them to interact.
\item distributed architecture.  You can run objects in different
  processes, potentially remote computers across the network.
\end{itemize}

\section{Outline}

This multi-part document provides a complete guide to Urbi.

\newenvironment{partDescription}[2]
{%
  \item[\autoref{#1} --- \nameref{#1}]~\\%
  #2
  \begin{description}%
    \let\itemOrig\item%
    \renewcommand{\item}[1][]{\itemOrig[~~\autoref{##1} --- \nameref{##1}]~\\}%
  }{%
  \end{description}%
}

\begin{description}
\input{tutorial/abstract}
\input{uobject/abstract}
\input{guide/abstract}
\input{specs/abstract}
\input{platforms/abstract}
\input{tables/abstract}
\end{description}

%% Redefine this environment so that next time the */abstract.tex
%% files are read, they create the part instead of referencing to it.

\renewenvironment{partDescription}[2]
{%
  \chapter*{About This Part}
  #2
  \begin{description}%
    \let\itemOrig\item%
    \renewcommand{\item}[1][]{\itemOrig[~~\autoref{##1} --- \nameref{##1}]~\\}%
  }{%
  \end{description}%
}


%% \paragraph{Thanks}
%% The \us language what first designed and implemented by
%% Jean-Christophe Baillie, together with Matthieu Nottale.  Because
%% \urbi was widely acclaimed by its users, Jean-Christophe founded
%% Gostai, a France-based Company that develops software for robotics
%% with a strong emphasis on personal robotics.
%%
%% \us SDK 1 was further developped by Akim Demaille, Guillaume
%% Deslandes, Quentin Hocquet, Thomas Moulard, and Benoît Sigoure.
%%
%% The \us SDK 2 project was started and developped by Akim Demaille,
%% Quentin Hocquet, Matthieu Nottale, and Benoît Sigoure.  Samuel Tardieu
%% provided an immense help during the year 2008, in particular for the
%% concurrency and event support.
%%
%% The maintenance is currently carried out by Akim Demaille, Quentin
%% Hocquet, and Matthieu Nottale.  Jean-Christophe Baillie is still
%% deeply involved in the development of \us, he regularly submits ideas,
%% and occasionnally even code!

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "urbi-sdk"
%%% ispell-dictionary: "american"
%%% ispell-personal-dictionary: "urbi.dict"
%%% End:
