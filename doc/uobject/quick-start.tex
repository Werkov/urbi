\chapter{Quick Start}
\label{sec:uob:quick}

This chapter presents \urbi SDK with a specific focus on its
middleware features.  It is self-contained in order to help readers
quickly grasp the potential of \urbi used as a middleware.  References
to other sections of this document are liberally provided to point the
reader to the more complete documentation; they should be ignored
during the first reading.

\section{\urbi as Middleware}

\urbi SDK is meant to make easier the orchestration of independent,
concurrent, components.  It was first designed for robotics: it
provides all the needed features to coordinate the execution of
various components (actuators, sensors, software devices that provide
features such as text-to-speech, face recognition and so forth).
Traditional languages such as \Cxx are definitely very adequate to
program the local, low-level, handling of these hardware or software
devices; indeed one needs efficiency, small memory footprint, and
access to low-level hardware details.  Yet, when it comes to
orchestration and to coordination between components, in a word, when
it comes to \emph{address concurrency}, such languages are no longer
an adequate model.

Rather, one has to select a middleware infrastructure in order to be
able to use remote components as if they were local, to allow
concurrent execution, to make synchronous or asynchronous requests and
so forth.  The \dfn{UObject} architecture provide exactly this: a
common API which allows conforming components to be used seamlessly in
highly concurrent settings.  Components need not be designed with
UObjects in mind, rather, UObjects are typically ``shells'' around
``regular'' components.

As a quite magical feature that comes for free, components with an
UObject interface are naturally supported by the \us programming
language.  This can be a tremendous help: one can interact with these
components (making queries, changing them, observing their state,
monitoring various kinds of events and so forth), which provides a
huge speed-up during development.

Finally, note that, although made with robots in mind, the UObject
architecture is well suited to tame any heavily concurrent
environment, such as video games.

\subsection{The \urbi Architecture}

%  * Description approche Urbi, philosophie (orchestration etc) => un
%  exemple de code Urbiscript qui orchestre 3 UObject de mani√®re simple
%  mais non triviale, avec at, \&, events, tags et qui servira de fil
%  conducteur au quickstart (le but du quickstart est de refaire cet
%  exemple initial).


\section{UObject Basics}

As a simple running example, consider a (very) basic factory.  Raw
material delivered to the factory is pushed into some assembly machine,
which takes some time.

As a firth component of this factory, the core engine of the factory
is implemented as follows.  This class is pure regular \Cxx, it uses
no \urbi feature at all.

\newcommand{\factoryDir}{\uobjectsDir/factory/factory.uob}
\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/factory.hh}
\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/factory.cc}

\subsection{Wrapping into an UObject}

By \dfn{binding} a UObject, we mean using the UObject API to declare
objects to the \urbi world.  These objects have member variables (also
known as \dfn{attributes}) and/or member functions (also known as
\dfn{methods}) all of them or some of them being declared into the
\urbi world.

One could modify the \lstinline|Factory| class to make it a UObject,
yet we rather recommend wrapping pure \Cxx classes into a UObject.  It
is strongly suggested to aggregate the native \Cxx objects in the
UObject --- rather than trying to derive from it.  By convention, we
prepend a ``U'' to the name of the base class, hence the
\lstinline|UFactory| class.

\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/ufactory.hh}

The implementation of \lstinline|UFactory| is quite straightforward.
It uses some of the primitives used in the binding process
(\autoref{sec:uob:api:bind}):
\begin{itemize}
\item \lstinline|UStart(\var{class})| declares classes that are
  UObjects; eventually, such classes will appear in \us as
  \lstinline|uobjects.\var{class}|.  Use it once.

\item \lstinline|UBindFunction(\var{class}, \var{function})| declares
  a \var{function}.  Eventually bound in the \us world as
  \lstinline|uobjects.\var{class}.\var{function}|.

\item Similarly, \lstinline|UBindVar(\var{class}, \var{variable})|
  declares a \var{variable}.
\end{itemize}

\urbi relies on the prototype model for object-oriented programming,
which is somewhat different from the traditional \Cxx class-based
model (\autoref{sec:tut:value}).  This is reflected by the presence of 
\emph{two} different constructors:
\begin{itemize}
\item \lstinline|UFactory::UFactory|, the \Cxx constructor which is
  invoked for every single instance of the UObject.  It is always
  invoked by the \urbi system when instantiating a UObject,
  \emph{including} the prototype itself.  It sole argument is its name
  (an internal detail you need not be aware of), and its main purpose
  is to register attributes and functions, especially the
  \lstinline|UFactory::init| function.

\item \lstinline|UFactory::init|, the \urbi constructor invoked each
  time a new clone of \lstinline|UFactory| is made, i.e., for every
  instance except the first one.
  
  Functions and variables that do not make sense for the initial
  prototype (which might not be fully functional) should be bound
  here, rather that in the \Cxx constructor.
\end{itemize}

The following listing is abundantly commented, and is easy to grasp.

\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/ufactory.cc}

\subsection{Running Components}
%  * Compilation et branchement de UObject (urbi-launch): expliquer les
%  deux modes: distant / pluge'
%
%  * Cycle complet de lancement d'une appli Urbi: lancement d'urbi,
%  execution d'urbi.ini, chargement dynamique des UObjects


As a first benefit from using the \urbi environment, this source code
is already runnable!  No \lstinline|main| function is needed, the
\urbi system provides one for you.

Of course, beforehand, we need to compile this UObject into some
loadable module.  The \urbi modules are \dfn{shared objects}, i.e.,
libraries that can be loaded on demand (and unloaded) during the
execution of the program.  Their typical file names depend on the
architecture: \file{ufactory.so} on most Unix, \file{ufactory.dylib}
on Mac OS X, and \file{ufactory.dll} on Windows.

To abstract away from these differences, we will simply use the base
name, \file{ufactory} with the \urbi tool chain.

There are several options to compile our sample factory as a UObject,
for instance you can use directly your regular compiler tool chain.
You may also use the \file{umake-*} family of programs ().


\subsection{Asynchronicity}
%  * Asynchronisme dans UObject: notifychange, timers


\section{Using \us}

\subsection{The \us Scripting Language}
%  * Introduction a` Urbiscript (rappeler que c'est avant tout un
%  langage comme les autres, avec if/for/while, etc), puis passer
%  rapidement aux elements clefs de la prog evenementielle dans Urbi:
%  at/whenever


\subsection{Concurrency}
%  * Parallelisme explicite: \&
%
%  * Tags et controle d'execution
%
%  * Channels et liburbi (les principes, renvoyer a` la doc liburbi pour
%  l'API)
%
%  * All together, on reprend l'exemple du de'but et on de'taille le code
%  des UObjects utilise's, puis le code urbiscript.


\section{Conclusion}
%  * Conclusion note: expliquer qu'on peut embedder l'engine Urbi dans
%  une appli native C++ (tout le monde le demande), qu'on peut faire
%  des bridges ge'ne'riques avec d'autres archis a` composants (citer
%  CORBA), donner le lien pour te'le'charger, le lien vers la doc du
%  langage urbiscript, vers la doc de UObject, etc.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  SDK middleware UObject API UObjects basicstyle prepend UFactory
% LocalWords:  UStart uobjects UBindFunction UBindVar Asynchronicity
