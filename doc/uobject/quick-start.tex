\newenvironment{todo}{%
  \begin{quote}\itshape%
  }{%
  \end{quote}%
}

\chapter{Quick Start}
\label{sec:uob:quick}

This chapter presents \urbi SDK with a specific focus on its
middleware features.  It is self-contained in order to help readers
quickly grasp the potential of \urbi used as a middleware.  References
to other sections of this document are liberally provided to point the
reader to the more complete documentation; they should be ignored
during the first reading.

\section{\urbi as Middleware}

\urbi SDK is meant to make easier the orchestration of independent,
concurent, components.  It was first designed for robotics: it
provides all the needed features to coordonate the execution of
various components (actuators, sensors, software devices that provide
features such as text-to-speach, face recognition and so forth).
Traditional languages such as \Cxx are definitely very adequate to
program the local, low-level, handling of these hardward or software
devices; indeed one needs efficiency, small memory footprint, and
access to low-level hardware details.  Yet, when it comes to
orchestration and to coordination between components, in a word, when
it comes to \emph{address concurrency}, such languages are no longer
an adequate model.

Rather, one has to select a middleware infrastructure in order to be
able to use remote components as if they were local, to allow
concurrent execution, to make synchronous or asynchronous requests and
so forth.  The \dfn{UObject} architecture provide exactly this: a
common API which allows conformant components to be used seemlessly in
highly concurrent settings.  Components need not be designed with
UObjects in mind, rather, UObjects are typically ``shells'' around
``regular'' components.

As a quite magical feature that comes for free, components with an
UObject interface are naturally supported by the \us programming
language.  This can be a tremendous help: one can interact with these
components (making queries, changing them, observing their state,
monitoring various kinds of events and so forth), which provides a
huge speed-up during development.

Finally, note that, although made with robots in mind, the UObject
architecture is well suited to tame any heavily concurrent
environment, such as video games.

\subsection{The \urbi Architecture}

\begin{todo}
  * Description approche Urbi, philosophie (orchestration etc) => un
  exemple de code Urbiscript qui orchestre 3 UObject de mani√®re simple
  mais non triviale, avec at, \&, events, tags et qui servira de fil
  conducteur au quickstart (le but du quickstart est de refaire cet
  exemple initial).
\end{todo}

\section{UObject Basics}

As a simple running example, consider a (very) basic factory.  Raw
material delivered to the factory is push into some assembly machine,
which takes some time.

As a firth component of this factory, consider the following
implementation of the core engine of the factory.
\newcommand{\factoryDir}{\uobjectsDir/factory/factory.uob}
\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/factory.hh}
\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/factory.cc}

\subsection{Wrapping into an UObject}

By \dfn{binding} a UObject, we mean using the UObject API to declare
objects to the Urbi world.  These objects have member variables (also
known as \dfn{attributes}) and/or member functions (also known as
\dfn{methods}) all of them or some of them being declared into the
Urbi world.

One could modify the \lstinline|Factory| class to make it a UObject,
yet we rather recommend wrapping pure \Cxx classes into a UObject.  It
is strongly suggested to aggregate the native \Cxx objects in the
UObject --- rather than trying to derive from it.

\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/ufactory.hh}

The implementation of \lstinline|UFactory| is quite straightforward.
It uses some of the primitives used in the binding process
(\autoref{sec:uob:api:bind}):
\begin{itemize}
\item \lstinline|UStart(\var{class})| declares classes that are
  UObjects; eventually, such classes will appear in \us as
  \lstinline|uobjects.\var{class}|.  Use it once.

\item \lstinline|UBindFunction(\var{class}, \var{function})| declares
  a \var{function}.  Eventually bound in the \us world as
  \lstinline|uobjects.\var{class}.\var{function}|.

\item Similarly, \lstinline|UBindVar(\var{class}, \var{variable})|
  declares a \var{variable}.
\end{itemize}

\urbi relies on the prototype model for object-oriented programming,
which is somewhat different from the traditional \Cxx class-based
model (\autoref{sec:tut:value}).  This is reflected by the presence of 
\emph{two} different constructors:
\begin{itemize}
\item \lstinline|UFactory::UFactory|, the \Cxx constructor which is
  invoked for every single instance of the UObject.  It is always
  invoked by the \urbi system when instantiating a UObject,
  \emph{including} the prototype itself.  It sole argument is its name
  (an internal detail you need not be aware of), and its main purpose
  is to register attributes and functions, especially the
  \lstinline|UFactory::init| function.

\item \lstinline|UFactory::init|, the \urbi constructor invoked each
  time a new clone of \lstinline|UFactory| is made, i.e., for every
  instance except the first one.
  
  Functions and variables that do not make sense for the initial
  prototype (which might not be fully functional) should be bound
  here, rather that in the \Cxx constructor.
\end{itemize}

The following listing is abundantly commented, and is easy to grasp.

\lstinputlisting[language=C++,basicstyle=\ttfamily\footnotesize]{\factoryDir/ufactory.cc}

\subsection{Asynchronicity}
\begin{todo}
  * Asynchronisme dans UObject: notifychange, timers
\end{todo}

\subsection{Running Components}
\begin{todo}
  * Compilation et branchement de UObject (urbi-launch): expliquer les
  deux modes: distant / pluge'

  * Cycle complet de lancement d'une appli Urbi: lancement d'urbi,
  execution d'urbi.ini, chargement dynamique des UObjects
\end{todo}

\section{Using \us}

\subsection{The \us Scripting Language}
\begin{todo}
  * Introduction a` Urbiscript (rappeler que c'est avant tout un
  langage comme les autres, avec if/for/while, etc), puis passer
  rapidement aux elements clefs de la prog evenementielle dans Urbi:
  at/whenever
\end{todo}

\subsection{Concurrency}
\begin{todo}
  * Parallelisme explicite: \&

  * Tags et controle d'execution

  * Channels et liburbi (les principes, renvoyer a` la doc liburbi pour
  l'API)

  * All together, on reprend l'exemple du de'but et on de'taille le code
  des UObjects utilise's, puis le code urbiscript.
\end{todo}

\section{Conclusion}
\begin{todo}
  * Conclusion note: expliquer qu'on peut embedder l'engine Urbi dans
  une appli native C++ (tout le monde le demande), qu'on peut faire
  des bridges ge'ne'riques avec d'autres archis a` composants (citer
  CORBA), donner le lien pour te'le'charger, le lien vers la doc du
  langage urbiscript, vers la doc de UObject, etc.
\end{todo}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
