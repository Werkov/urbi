Installation on Linux
#####################

Download and unpack the kernel-2.0-<arch>-<os>-<compiler>.tar.gz.
Unpack the file. Set the environment variable URBI_ROOT to the
directory pointing to the directory it created.

Note that if you rename the kernel-2.0-<arch>-<or>-<compiler>
directory to /usr/local/gostai, you only have to set your PATH
to /usr/local/gostai/bin, LD_LIBRARY_PATH and URBI_ROOT settings
are not necessary.

Installation on Windows
#######################

Uncompress the kernel-2.0-<arch>-<os>-<compiler>.zip file.

Running urbi-console
####################

Urbi console is the quickest way to test your urbi installation: it is
a simple urbi server with which you can interact directly. It can also
accept network connections.

On Linux:

  * Set your PATH to contain $URBI_ROOT/bin
  * Set your LD_LIBRARY_PATH to find:
    - The kernel library: $URBI_ROOT/gostai/core/i686-pc-linux-gnu/engine
    - The kernel auxiliary library: $URBI_ROOT/lib
  * Launch urbi-console: $URBI_ROOT/bin/urbi-console -i

  The commands could be:

  export LD_LIBRARY_PATH
  LD_LIBRARY_PATH="$URBI_ROOT/gostai/core/i686-pc-linux-gnu/engine:$LD_LIBRARY_PATH"
  LD_LIBRARY_PATH="$URBI_ROOT/lib:$LD_LIBRARY_PATH"
  LD_LIBRARY_PATH="$URBI_ROOT/lib:$LD_LIBRARY_PATH"
  $URBI_ROOT/bin/urbi-console -i

The -i option passed to urbi-console enables you to send urbi commands
through the standard input and thus experiment very quickly with
urbi. By specifying "-p port", you can also accept network
connections. Many other options are available, try "urbi-console
--help" to list them.

On Window, just start the "urbi-console.bat" script, it already includes
the "-i -p 54000" command line arguments.

Building an uobject
###################

UObjects are nothing but dynamic libraries (.so under unix, .dll under
windows). Under Unix simply compile your C++ source file a shared
library; you only need specify where to find UObject headers:
$URBI_ROOT/include.

You can then use your uobject with the urbi-launch binary. You only
need set the URBI_ROOT variable to point to $kernel_unpack_dir, so as
urbi-launch can find your Urbi installation. urbi-launch can then use
your shared library to:
* Spawn a new Urbi server with the uobject plugged in.
* Plug the uobject on a running server
* Start as a remote and connect to a running server

For instance, to build the sensor example uobject and start a fresh
Urbi server with the sensor plugged in, the commands could be:

g++  -shared -fPIC -I $URBI_ROOT/include sensor.cc -o sensor.so
$URBI_ROOT/bin/urbi-launch --start ./sensor.so

Note that any additional argument to urbi-launch is passed to the
server. Thus, by adding -i, you can interact directly with the server,
and find your sensor uobject in uobjects.sensor.
