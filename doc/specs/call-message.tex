%% Copyright (C) 2009-2010, Gostai S.A.S.
%%
%% This software is provided "as is" without warranty of any kind,
%% either expressed or implied, including but not limited to the
%% implied warranties of fitness for a particular purpose.
%%
%% See the LICENSE file for more information.

\section{CallMessage}
Capturing a method invocation: its target and arguments.

\subsection{Examples}
\subsubsection{Evaluating an argument several times}
\label{sec:std-callmsg-examples-several}

The following example implements a lazy function which takes an integer
\var{n}, then arguments.  The \var{n}-th argument is evaluated twice using
\refSlot{evalArgAt}.

\begin{urbiscript}[firstnumber=1]
function callTwice
{
  var n = call.evalArgAt(0);
  call.evalArgAt(n);
  call.evalArgAt(n)
} |;

// Call twice echo("foo").
callTwice(1, echo("foo"), echo("bar"));
[00000001] *** foo
[00000002] *** foo

// Call twice echo("bar").
callTwice(2, echo("foo"), echo("bar"));
[00000003] *** bar
[00000004] *** bar
\end{urbiscript}


\subsubsection{Strict Functions}

Strict functions do support \lstinline|call|.

\begin{urbiscript}
function strict(x)
{
  echo("Entering");
  echo("Strict: " + x);
  echo("Lazy:   " + call.evalArgAt(0));
} |;

strict({echo("1"); 1});
[00000011] *** 1
[00000013] *** Entering
[00000012] *** Strict: 1
[00000013] *** 1
[00000014] *** Lazy:   1
\end{urbiscript}


\subsection{Slots}

\begin{urbiscriptapi}
\item[args]
  The list of unevaluated arguments.
\begin{urbiscript}
function args { call.args }|
assert
{
  args == [];
  args() == [];
  args({echo(111); 1}) == [Lazy.new(closure() {echo(111); 1})];
  args(1, 2) == [Lazy.new(closure () {1}),
                 Lazy.new(closure () {2})];
};
\end{urbiscript}


\item[argsCount]
  Return the number of arguments.  Do not evaluate them.
\begin{urbiscript}
function argsCount { call.argsCount }|;
assert
{
  argsCount == 0;
  argsCount() == 0;
  argsCount({echo(1); 1}) == 1;
  argsCount({echo(1); 1}, {echo(2); 2}) == 2;
};
\end{urbiscript}

\item[code]
  The body of the called function as a \refObject{Code}.
\begin{urbiscript}
function code { call.getSlot("code") }|
assert (code == getSlot("code"));
\end{urbiscript}

\item[evalArgAt](<n>)%
  Evaluate the \var{n}-th argument, and return its value.  \var{n}
  must evaluate to an non-negative integer.  Repeated invocations
  repeat the evaluation, see
  \autoref{sec:std-callmsg-examples-several}.
\begin{urbiscript}
function sumTwice
{
  var n = call.evalArgAt(0);
  call.evalArgAt(n) + call.evalArgAt(n)
}|;

function one () { echo("one"); 1 }|;

sumTwice(1, one, one + one);
[00000008] *** one
[00000009] *** one
[00000010] 2
sumTwice(2, one, one + one);
[00000011] *** one
[00000012] *** one
[00000011] *** one
[00000012] *** one
[00000013] 4

sumTwice(3, one, one);
[00000014:error] !!! evalArgAt: invalid index: 3
sumTwice(3.14, one, one);
[00000015:error] !!! evalArgAt: invalid index: 3.14
\end{urbiscript}

\item[evalArgs]
  Call \lstinline|evalArgAt| for each argument, return the list of
  values.
\begin{urbiscript}
function twice
{
  call.evalArgs + call.evalArgs
}|;
twice({echo(1); 1}, {echo(2); 2});
[00000011] *** 1
[00000012] *** 2
[00000011] *** 1
[00000012] *** 2
[00000013] [1, 2, 1, 2]
\end{urbiscript}

\item[message]
  The name under which the function was called.
\begin{urbiscript}
function myself { call.message }|
assert(myself == "myself");
\end{urbiscript}

\end{urbiscriptapi}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% ispell-dictionary: "american"
%%% ispell-personal-dictionary: "../urbi.dict"
%%% fill-column: 76
%%% End:
