\section{Object}

All objects in \us must have \refObject{Object} in their
parents. \refObject{Object} is done for this purpose so that it come
with many primitives that are mandatory for all object in \us.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Orderable}
\item \refObject{Global}
\end{itemize}

\subsection{Methods}

\begin{itemize}
\item \lstinline|acceptVoid|\\

\item \lstinline|addProto(\var{proto})|\\
  Add the prototype \var{proto} as a parent into the list of
  \lstinline|this|.

\begin{urbiscript}
var Dummy = Object.new | Dummy.addProto(Orderable) | {};
assert(Dummy.protos == [Orderable, Object]);
\end{urbiscript}

\item \lstinline|allProto|\\
  Return a list with \lstinline|this|, all parents of
  \lstinline|this|, the parents of the parents of
  \lstinline|this|,\ldots
\begin{urbiscript}[firstnumber=last]
assert(123.allProtos.size == 12);
\end{urbiscript}

\item \lstinline|allSlotNames|\\
  Return a list with the slot names of \lstinline|this| and of all
  parents in the hierarchy of \lstinline|this|.

\item \lstinline|apply|\\

\item \lstinline|as|\\

\item \lstinline|asBool|\\
  Whether \lstinline|this| is ``true''.  Depends on the type of
  \lstinline|this|:
  \begin{itemize}
  \item \lstinline|false|, \lstinline|nil|\\
    return \lstinline|false|.
  \item  \lstinline|void|\\
    raise an error.
  \item lstinline|Float|\\
    Return true iff non null (\refObject{Float}).
  \item \lstinline|Dictionary|, \lstinline|List|,  \lstinline|String|\\
    Return \lstinline|true| iff non-empty (\refObject{Dictionary},
    \refObject{List}, \refObject{String}).
  \item otherwise\\
    Return true.
  \end{itemize}
\begin{urbiscript}[firstnumber=last]
assert(Global.asBool == true);
assert(nil.asBool ==    false);
void.asBool;
[00000421:error] !!! unexpected void
\end{urbiscript}

\item \lstinline|bounce|\\

\item \lstinline|bounce_named|\\

\item \lstinline|callMessage|\\

\item \lstinline|clone|\\

\item \lstinline|cloneSlot(\var{from}, \var{to})|\\
  Set the new slot \var{to} using a clone of \var{from}. This can only
  be used into the same object.

\begin{urbiscript}[firstnumber=last]
var foo = Object.new |;
cloneSlot("foo", "bar") |;
assert(!(foo === bar));
\end{urbiscript}

\item \lstinline|copySlot(\var{from}, \var{to})|\\
  Same as \lstinline|cloneSlot|, but the slot aren't cloned, so the
  two slot are the same.

\begin{urbiscript}[firstnumber=last]
var moo = Object.new |;
cloneSlot("moo", "loo") |;
assert(!(moo === loo));
\end{urbiscript}

\item \lstinline|createSlot(\var{name})|\\
  Create an empty slot (which actually means it is bound to
  \lstinline|void|) named \var{name}.  Raise an error if \var{name}
  was already defined.
\begin{urbiscript}[firstnumber=last]
do (Object.new)
{
  assert(!hasSlot("foo"));
  assert(createSlot("foo").isVoid);
  assert(hasSlot("foo"));
}|;
\end{urbiscript}

\item \lstinline|dump(\var{depth})|\\
  Describe \lstinline|this|: its prototypes and slots.  The argument
  \var{depth} specifies how recursive the description is: the greater,
  the more detailed.  This method is mostly useful for debugging
  low-level issues, for a more human-readable interface, see also
  \lstinline|Object.inspect|.
\begin{urbiscript}[firstnumber=last]
do (2) { var this.attr = "foo"; this.attr->prop = "bar" }.dump(0);
[00015137] *** Float_0x240550 {
[00015137] ***   /* Special slots */
[00015137] ***   protos = Float
[00015137] ***   value = 2
[00015137] ***   /* Slots */
[00015137] ***   attr = String_0x23a750 <...>
[00015137] ***     /* Properties */
[00015137] ***     prop = String_0x23a7a0 <...>
[00015137] ***   }
do (2) { var this.attr = "foo"; this.attr->prop = "bar" }.dump(1);
[00020505] *** Float_0x240550 {
[00020505] ***   /* Special slots */
[00020505] ***   protos = Float
[00020505] ***   value = 2
[00020505] ***   /* Slots */
[00020505] ***   attr = String_0x23a750 {
[00020505] ***     /* Special slots */
[00020505] ***     protos = String
[00020505] ***     /* Slots */
[00020505] ***     }
[00020505] ***     /* Properties */
[00020505] ***     prop = String_0x239330 {
[00020505] ***       /* Special slots */
[00020505] ***       protos = String
[00020505] ***       /* Slots */
[00020505] ***       }
[00020505] ***   }
\end{urbiscript}

\item \lstinline|eachBg|\\

\item \lstinline$each|$\\

\item \lstinline|getLazyLocalSlot|\\

\item \lstinline|getPeriod|\\

\item \lstinline|getProperty|\\

\item \lstinline|getSlot(\var{name})|\\
  Return the value associated to \var{name}.

\begin{urbiscript}[firstnumber=last]
assert(!Object.getSlot("getSlot").isVoid);
\end{urbiscript}

\item \lstinline|hasProperty|\\

\item \lstinline|hasLocalSlot(\var{slot})|\\
  Whether \lstinline|this| features a slot \var{slot}, locally, not
  from some ancester.  See also \lstinline|Object.hasSlot|.

\begin{urbiscript}[firstnumber=last]
class Base         { var this.base = 23; } |;
class Derive: Base { var this.derive = 43 } |;
assert(Derive.hasLocalSlot("derive"));
assert(!Derive.hasLocalSlot("base"));
\end{urbiscript}

\item \lstinline|hasSlot(\var{slot})|\\
  Whether \lstinline|this| has the slot \var{slot}, locally, or from
  some ancester.  See also \lstinline|Object.hasLocalSlot|.

\begin{urbiscript}[firstnumber=last]
assert(Derive.hasSlot("derive"));
assert(Derive.hasSlot("base"));
assert(!Base.hasSlot("derive"));
\end{urbiscript}

\item \lstinline|id|\\

\item \lstinline|inspect(\var{deep} = false)|\\
  Describe \lstinline|this|: its prototypes and slots, and there
  properties.  If \var{deep}, all the slots are described, not only
  the local slots. See also \lstinline|Object.dump|.
\begin{urbiscript}[firstnumber=last]
do (2) { var this.attr = "foo"; this.attr->prop = "bar"}.inspect;
[00001227] *** Inspecting 2
[00001227] *** ** Prototypes:
[00001227] ***   0
[00001227] *** ** Local Slots:
[00001228] ***   2.attr : String
[00001228] ***     Properties:
[00001228] ***      prop : String = bar
\end{urbiscript}

\item \lstinline|isA(\var{obj})|\\
  Return true if \lstinline|this| has \var{obj} in his parents, false
  otherwise.

\begin{urbiscript}[firstnumber=last]
assert(Float.isA(Orderable));
assert(!(String.isA(Float)));
\end{urbiscript}

\item \lstinline|isNil|\\
  Return true if \lstinline|this| is nil, false otherwise.

\begin{urbiscript}[firstnumber=last]
assert(nil.isNil);
assert(!(0.isNil));
\end{urbiscript}

\item \lstinline|isProto|\\
  Return true if \lstinline|this| is a prototype, false otherwise;

\begin{urbiscript}[firstnumber=last]
assert(Float.isProto);
assert(!(42.isProto));
\end{urbiscript}

\item \lstinline|isVoid|\\
  Return true if \lstinline|this| is \lstinline|void|.

\begin{urbiscript}[firstnumber=last]
assert(void.isVoid);
assert(!(42.isVoid));
\end{urbiscript}

\item \lstinline|locateSlot(\var{slot})|\\
  Return \lstinline|nil| if \lstinline|this| don't have the slot
  \lstinline|slot|. Otherwise it returns the first lowest owner of
  \lstinline|slot| of \lstinline|this|.

\begin{urbiscript}[firstnumber=last]
assert(locateSlot("init"), Channel);
assert(locateSlot("doesNotExist").isNil);
\end{urbiscript}

\item \lstinline|print|\\

\item \lstinline|protos|\\
  Return the list of prototypes of \lstinline|this|.
\begin{urbiscript}[firstnumber=last]
assert(12.protos == [0]);
\end{urbiscript}

\item \lstinline|properties(\var{slotName})|\\
  Return a dictionary of the properties of slot \var{slotName}.
  Return an empty dictionary if the slot has not property, raise an
  error if the slot does not exists.
\begin{urbiscript}[firstnumber=last]
2;
[00001228] 2
2.properties("foo");
[00238495:error] !!! lookup failed: foo
do (2) { var foo = "foo" }.properties("foo");
[00238501] Dictionary {}
do (2) { var foo = "foo" ; foo->bar = "bar" }.properties("foo");
[00238502] Dictionary {"bar" => "bar"}
\end{urbiscript}

\item \lstinline|removeProperty|\\

\item \lstinline|removeProto(\var{proto})|\\
  Remove \var{proto} from the list of prototypes of \lstinline|this|.

\item \lstinline|removeSlot(\var(slot))|\\
  Remove \var{slot} from the list of slots of \lstinline|this|.

\item \lstinline|setConstSlot|\\
  Like \lstinline|setSlot| but the created slot is const.

\begin{urbiscript}[firstnumber=last]
assert(setConstSlot("fortyTwo", 42) == 42);
fortyTwo = 51;
[00000000:error] !!! cannot modify const slot
\end{urbiscript}

\item \lstinline|setProperty|\\

\item \lstinline|setProtos|\\

\item \lstinline|setSlot(\var{name}, \var{value})|\\
  Create a slot \var{name} mapping to \var{value}. Raise an error if
  \var{name} was already defined.

\begin{urbiscript}[firstnumber=last]
assert(Object.setSlot("theObject", Object), Object);
assert(Object.theObject === Object);
assert(theObject === Object);
\end{urbiscript}

\item \lstinline|slotNames|\\
  Returns the list of slot owned by \lstinline|this|.

\item \lstinline|tasks|\\
  Returns the list of the current running tasks;

\item \lstinline|type|\\

\item \lstinline|uid|\\
  Returns ths unique id of \lstinline|this|.

\item \lstinline|unacceptvoid|\\

\item \lstinline|uobject_init|\\

\item \lstinline|updateSlot(\var{name}, \var{value})|\\
  Map the existing slot named \var{name} to \var{value}. Raise an
  error if \var{name} was not defined.
\begin{urbiscript}[firstnumber=last]
assert(Object.setSlot("one", 1)    == 1);
assert(Object.updateSlot("one", 2) == 2);
assert(Object.one                  == 2);
\end{urbiscript}

\item \lstinline|'&&'(\var{that})|\\
  Short-circuiting logical and. If \lstinline|this| evaluates to true
  evaluate and return \var{that}, otherwise return \lstinline|this|
  without evaluating \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(0 && "foo" == 0);
assert(2 && "foo" == "foo");

assert(""    && "foo" == "");
assert("foo" && "bar" == "bar");
\end{urbiscript}

\item \lstinline/'||'(\var{that})/\\
  Short-circuiting logical or. If \lstinline|this| evaluates to false
  evaluate and return \var{that}, otherwise return \lstinline|this|
  without evaluating \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(0 || "foo" == "foo");
assert(2 ||  1/0 ==  2);

assert(""    || "foo" == "foo");
assert("foo" || 1/0 ==   "foo");
\end{urbiscript}

\item \lstinline|'!'|\\
  Logical negation. If \lstinline|this| evaluates to false return
  \lstinline|true| and vice-versa.
\begin{urbiscript}[firstnumber=last]
assert(!1 == false);
assert(!0 == true);

assert(!"foo" == false);
assert(!"" ==    true);
\end{urbiscript}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
