\section{Boolean}

There is no object \lstinline|Boolean| in \us, but two specific
objects \lstinline|true| and \lstinline|false|.  They are the result
of all comparison statement.


\subsection{Prototypes}

The objects \lstinline|true| and \lstinline|false| have the following
prototype.

\begin{itemize}
\item \refObject{Singleton}
\end{itemize}

\subsection{Construction}

There are no constructors, use \lstinline|true| and \lstinline|false|.
Since they are singletons, \lstinline|clone| will return themselves,
not new copies.

\begin{urbiscript}
assert(true);
assert(!false);
assert(2 < 6 === true);
assert(true.new === true);
assert(6 < 2 === false);
\end{urbiscript}

\subsection{Methods}

\begin{itemize}
\item \lstinline|'&&'(\var{that})|\\
  Short-circuiting logical and. If \lstinline|this| is
  \lstinline|true| evaluate and return \var{that}.  If
  \lstinline|this| is \lstinline|false|, return itself without
  evaluating \var{that}.
\begin{urbiscript}[firstnumber=last]
assert_eq(true && 2, 2);
assert_eq(false && 1 / 0, false);
\end{urbiscript}

\item \lstinline|'||'(\var{that})|\\
  Short-circuiting logical or. If \lstinline|this| is
  \lstinline|false| evaluate and return \var{that}.  If
  \lstinline|this| is \lstinline|true|, return itself without
  evaluating \var{that}.
\begin{urbiscript}[firstnumber=last]
assert_eq(true || 1/0, true);
assert_eq(false || 2, 2);
\end{urbiscript}

\item \lstinline|'!'|\\
  Logical negation. If \lstinline|this| is \lstinline|false| return
  \lstinline|true| and vice-versa.
\begin{urbiscript}[firstnumber=last]
assert_eq(!true, false);
assert_eq(!false, true);
\end{urbiscript}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
