\section{Dictionary}

A \dfn{dictionary} is an \dfn{associative array}, also known as a
\dfn{hash} in some programming languages.  They are arrays whose
indexes are strings.

In a way objects are dictionaries: one can use \lstinline|setSlot|,
\lstinline|updateSlot|, and \lstinline|getSlot|.  This is unsafe since
slots also contains value and methods that object depend upon to run
properly.

\subsection{Example}

The following session demonstrates the features of the Dictionary
objects.

\begin{urbiscript}[firstnumber=1]
var d = Dictionary.new("one", 1, "two", 2);
[00000001] Dictionary {"one" => 1, "two" => 2}
for (var p : d)
  echo (p.first + " -> " + p.second);
[00000003] *** one -> 1
[00000002] *** two -> 2
"three" in d;
[00000004] false
d["three"];
[00000005:error] !!! missing key: three
d["three"] = d["one"] + d["two"] | {};
"three" in d;
[00000006] true
d.getWithDefault("four", 4);
[00000007] 4
\end{urbiscript}


\subsection{Prototypes}

\begin{itemize}
\item \refObject{Object}
\item \refObject{RangeIterable}
\end{itemize}

\subsection{Construction}

The Dictionary constructor takes arguments by pair (key, value).

\begin{urbiscript}[firstnumber=last]
Dictionary.new("one", 1, "two", 2);
[00000000] Dictionary {"one" => 1, "two" => 2}
\end{urbiscript}

\subsection{Slots}

\begin{itemize}
\item \lstinline|asBool|\\
  Negation of \lstinline|Dictionary.empty|.
\begin{urbiassert}[firstnumber=last]
Dictionary.new.asBool == false;
Dictionary.new.set("key", "value").asBool == true;
\end{urbiassert}

\item \lstinline|asList|\\
  Return the contents of the dictionary as a \refObject{Pair} list
  (\var{key}, \var{value}).  Since Dictionary derives from
  \refObject{RangeIterable}, it is easy to iterate over a Dictionary
  using a range-\lstinline|for| (\autoref{sec:lang:for:each}).  No
  particular order is ensured.

\begin{urbiscript}[firstnumber=last]
assert(Dictionary.new("one", 1, "two", 2).asList
       == [Pair.new("one", 1), Pair.new("two", 2)]);
{
  var res = [];
  for| (var entry: Dictionary.new("one", 1, "two", 2))
    res << entry.second;
  assert(res == [1, 2]);
};
\end{urbiscript}

\item \lstinline|clear|\\
  Empty the dictionary.

\begin{urbiassert}[firstnumber=last]
Dictionary.new("one", 1).clear.empty();
\end{urbiassert}

\item \lstinline|empty|\\
  Whether the dictionary is empty.

\begin{urbiassert}[firstnumber=last]
Dictionary.new.empty;
!Dictionary.new.set("key", "value").empty;
\end{urbiassert}

\item \lstinline|erase(\var{key})|\\
  Remove the mapping for \lstinline|\var{key}|.

\begin{urbiscript}[firstnumber=last]
Dictionary.new("one", 1, "two", 2).erase("two");
[00386250] Dictionary {"one" => 1}
\end{urbiscript}

\item \lstinline|get(\var{key})|\\
  Return the value associated to \lstinline|\var{key}|.  A
  Dictionary.KeyError exception is thrown if the key is missing.

% FIXME: the following excpetion test should be rewritte when (if) we
% introduce the throw assertion.
\begin{urbiscript}[firstnumber=last]
assert(Dictionary.new("one", 1, "two", 2).get("one") == 1);
try
{
  Dictionary.new("one", 1, "two", 2).get("three");
  echo("never reached");
}
catch (var e if e.isA(Dictionary.KeyError))
{
  assert(e.key == "three")
};
\end{urbiscript}


\item \lstinline|getWithDefault(\var{key}, \var{default-value})|\\
  Return the value associated to  \lstinline|\var{key}| if it exists,
  \lstinline|\var{default-value}| otherwise.

\begin{urbiscript}[firstnumber=last]
do (Dictionary.new("one", 1, "two", 2))
{
  assert(getWithDefault("one",  -1) == 1);
  assert(getWithDefault("three", 3) == 3);
}|;
\end{urbiscript}


\item \lstinline|has(\var{key})|\\
  Whether the dictionary has a mapping for \lstinline|\var{key}|.

\begin{urbiscript}[firstnumber=last]
do (Dictionary.new("one", 1))
{
  assert(has("one"));
  assert(!has("zero"));
}|;
\end{urbiscript}

\item \lstinline|init(\var{key1}, \var{value1}, ...)|~\\
  Insert the mapping from \lstinline|\var{key1}| to
  \lstinline|\var{value1}| and so forth.

\begin{urbiscript}[firstnumber=last]
Dictionary.clone.init("one", 1, "two", 2);
[00000000] Dictionary {"one" => 1, "two" => 2}
\end{urbiscript}

\item \lstinline|keys()|\\
  The list of all the keys.  No particular order is ensured.  Since
  \refObject{List} features the same function, uniform iteration over
  a List or a Dictionary is possible.
\begin{urbiscript}[firstnumber=last]
{
  var d = Dictionary.new("one", 1, "two", 2);
  assert(d.keys == ["one", "two"]);
  assert({
           var res = [];
           for (var k: d.keys)
             res << d[k];
           res
         }
         == [1, 2]);
};
\end{urbiscript}

\item \lstinline|set(\var{key}, \var{value})|\\
  Map \lstinline|\var{key}| to \lstinline|\var{value}| and return
  \lstinline|this| so that invocations to \lstinline|set| can be
  chained.  The possibly existing previous mapping is overridden.

\begin{urbiscript}[firstnumber=last]
Dictionary.new.set("one", 2).set("one", 1);
[00000000] Dictionary {"one" => 1}
\end{urbiscript}

\item \lstinline|size|\\
  Number of element in the dictionary.

\begin{urbiscript}[firstnumber=last]
{
  var d = Dictionary.new;
  assert(d.size == 0);
  d["a"] = 0;
  assert(d.size == 1);
  d["b"] = 1;
  assert(d.size == 2);
  d["a"] = 2;
  assert(d.size == 2);
};
\end{urbiscript}

\item \lstinline|[]=(\var{key}, \var{value})|\\
  Syntactic sugar for \lstinline|set(\var{key}, \var{value})|, but
  returns \var{value}.

\begin{urbiscript}[firstnumber=last]
{
  var d = Dictionary.new("one", "2");
  assert((d["one"] = 1) == 1);
  assert(d["one"] == 1);
};
\end{urbiscript}

\item \lstinline|[](\var{key})|\\
  Syntactic sugar for \lstinline|get(\var{key})|.

\begin{urbiassert}[firstnumber=last]
Dictionary.new("one", 1)["one"] == 1;
\end{urbiassert}

\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% ispell-personal-dictionary: "../urbi.dict"
%%% End:
