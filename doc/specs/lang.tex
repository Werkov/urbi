\chapter{\us language specifications}
\label{sec:lang}

\section{Syntax}
\subsection{Comments}

\dfn{Comments} are used to document the code, they are ignored by the
\us interpreter. Both \Cxx comment types are supported.

\begin{itemize}
\item A \lstinline|//| introduces a comment that lasts until the end
  of the line.
\item A \lstinline|/*| introduces a comment that lasts until
  \lstinline|*/| is encountered. Comments nest, contrary to \C/\Cxx:
  if two \lstinline|/*| are encountered, the
  comment will end after two \lstinline|*/|, not one.
\end{itemize}

\autoref{lst:comments} illustrates this.

\begin{urbiscript}[caption=Comments,label=lst:comments,float=\floatpos]
// C++ style comment
/* C style comment */
/* These comments /* do */ nest */
\end{urbiscript}

\subsection{Identifiers}
\label{sec:us-syn-id}

% FIXME: New is  still special, but will be removed.
\dfn{Identifiers} in \us are composed of one or more alphanumeric or
underscore (\lstinline|_|) characters, not starting
by a digit, i.e., identifiers match the
\lstinline|[a-zA-Z_][a-zA-Z0-9_]*| regular expression (see
\autoref{lst:identifiers}).  Additionally, identifiers must not match any of
the \us reserved words documented in \autoref{sec:syn-key}. The only
exception to this rule is \lstinline|new|, which can be used as the
method identifier in a method call, as shown in
\autoref{lst:identifiers-keywords}.  Identifiers can also be written
between simple quotes (\lstinline|'|), in which case they may contain
any character, as in \autoref{lst:escape-identifiers}.

\begin{urbiscript}[caption=Identifiers,label=lst:identifiers,float=\floatpos]
var x;
var foobar51;
obj.met_hod();
// Invalid.
// var 3x;
// obj.3x();
\end{urbiscript}

\begin{urbiscript}[caption=Identifiers cannot be keywords,
  label=lst:identifiers-keywords,float=\floatpos]
// Invalid because "if" is a keyword.
// var if;
// obj.if();
// However, keywords can be escaped with simple quotes
var 'if';
obj.'if'();
\end{urbiscript}

\begin{urbiscript}[caption=Escaping identifiers with simple quotes,
  label=lst:escape-identifiers,float=\floatpos]
// Identifiers can be escaped with simple quotes
var '%x';
var '1 2 3';
obj.'[]';
\end{urbiscript}

\subsection{Keywords}
\label{sec:syn-key}

\dfn{Keywords} are reserved words that cannot be used as identifiers,
for instance.  They are listed in \autoref{tab:keywords}.  Keywords
can be escaped, and thus used as identifier by surrounding them with
simple quotes (\lstinline|'|), as shown in
\autoref{lst:escape-keyword}.

\renewcommand{\baselinestretch}{.85}
\begin{table}[\floatpos]
  \centering
  \begin{tabular}{|c|c||c|c|}
    \hline
    Keyword                       & Remark                                  &
    Keyword                       & Remark                                  \\
    \hline
    \lstinline"and"               & Synonym for  operator                   &
    \lstinline"long"              & Unused                                  \\
    \lstinline"and_eq"            & Synonym for  operator                   &
    \lstinline"loop"              & \lstinline|loop&| and
                                    \lstinline-loop|- flavors               \\
    \lstinline"asm"               & Unused                                  &
    \lstinline"loopn"             & Deprecated, use \lstinline|for|         \\
    \lstinline"at"                &                                         &
    \lstinline"mutable"           & Unused                                  \\
    \lstinline"auto"              & Unused                                  &
    \lstinline"namespace"         & Unused                                  \\
    \lstinline"bitand"            & Synonym for \lstinline|&| operator      &
    \lstinline"new"               &                                         \\
    \lstinline"bitor"             & Synonym for \lstinline-|- operator      &
    \lstinline"not"               & Synonym for \lstinline|!| operator      \\
    \lstinline"bool"              & Unused                                  &
    \lstinline"not_eq"            & Synonym for \lstinline|!=| operator     \\
    \lstinline"break"             &                                         &
    \lstinline"object"            &                                         \\
    \lstinline"call"              &                                         &
    \lstinline"onleave"           &                                         \\
    \lstinline"case"              &                                         &
    \lstinline"or"                & Synonym for \lstinline-||- operator     \\
    \lstinline"catch"             & Unused                                  &
    \lstinline"or_eq"             & Synonym for \lstinline-|=- operator     \\
    \lstinline"char"              & Unused                                  &
    \lstinline"private"           & Ignored                                 \\
    \lstinline"class"             &                                         &
    \lstinline"protected"         & Ignored                                 \\
    \lstinline"closure"           &                                         &
    \lstinline"public"            & Ignored                                 \\
    \lstinline"compl"             & Synonym for \lstinline|~|               &
    \lstinline"register"          & Unused                                  \\
    \lstinline"const"             & Unused                                  &
    \lstinline"reinterpret_cast"  & Unused                                 \\
    \lstinline"const_cast"        & Unused                                  &
    \lstinline"return"            &                                         \\
    \lstinline"continue"          &                                         &
    \lstinline"short"             & Unused                                  \\
    \lstinline"default"           & Unused                                  &
    \lstinline"signed"            & Unused                                  \\
    \lstinline"delete"            &                                         &
    \lstinline"sizeof"            & Unused                                  \\
    \lstinline"do"                &                                         &
    \lstinline"static"            & Deprecated                              \\
    \lstinline"double"            & Unused                                  &
    \lstinline"static_cast"       & Unused                                  \\
    \lstinline"dynamic_cast"      & Unused                                  &
    \lstinline"stopif"            &                                         \\
    \lstinline"else"              &                                         &
    \lstinline"struct"            & Unused                                  \\
    \lstinline"emit"              &                                         &
    \lstinline"switch"            &                                         \\
    \lstinline"enum"              & Unused                                  &
    \lstinline"template"          & Unused                                  \\
    \lstinline"event"             &                                         &
    \lstinline"this"              &                                         \\
    \lstinline"every"             &                                         &
    \lstinline"throw"             & Unused                                  \\
    \lstinline"explicit"          & Unused                                  &
    \lstinline"timeout"           &                                         \\
    \lstinline"export"            & Unused                                  &
    \lstinline"try"               & Unused                                  \\
    \lstinline"extern"            & Unused                                  &
    \lstinline"typedef"           & Unused                                  \\
    \lstinline"external"          &                                         &
    \lstinline"typeid"            & Unused                                  \\
    \lstinline"float"             & Unused                                  &
    \lstinline"typename"          & Unused                                  \\
    \lstinline"for"               & \lstinline|for&| and \lstinline-for|- flavors&
    \lstinline"union"             & Unused                                  \\
    \lstinline"foreach"           & Deprecated, use \lstinline|for|    &
    \lstinline"unsigned"          & Unused                                  \\
    \lstinline"freezeif"          &                                         &
    \lstinline"using"             & Unused                                  \\
    \lstinline"friend"            & Unused                                  &
    \lstinline"var"               &                                         \\
    \lstinline"from"              &                                         &
    \lstinline"virtual"           & Unused                                  \\
    \lstinline"function"          &                                         &
    \lstinline"volatile"          & Unused                                  \\
    \lstinline"goto"              & Unused                                  &
    \lstinline"waituntil"         &                                         \\
    \lstinline"if"                &                                         &
    \lstinline"wchar_t"           & Unused                                  \\
    \lstinline"in"                &                                         &
    \lstinline"whenever"          &                                         \\
    \lstinline"inline"            & Unused                                  &
    \lstinline"while"             & \lstinline|while&| and
                                    \lstinline-while|- flavors              \\
    \lstinline"int"               & Unused                                  &
    \lstinline"xor"               & Synonym for \lstinline|^| operator      \\
    \lstinline"internal"          & Deprecated                              &
    \lstinline"xor_eq"            & Synonym \lstinline|^=| operator         \\
    \hline
  \end{tabular}
  \caption{Keywords}
  \label{tab:keywords}
\end{table}
\renewcommand{\baselinestretch}{1}

\begin{urbiscript}[caption=Escaping keywords,label=lst:escape-keyword,float=\floatpos]
var 'if' = 21;
[00000000] 21
'if' * 2;
[00000000] 42
\end{urbiscript}

\subsection{Literals}
\subsubsection{Durations}

\dfn{Durations} (see \autoref{sec:us-syn-lit-float}) are floats
followed by a
% FIXME: formulation
time unit. They are simply equivalent to the same float, expressed in
seconds. For instance, \lstinline|1s 1ms|, which stands for ``one
second and 1 millisecond'', is strictly equivalent to
\lstinline|1.0001|. Available units
and their equivalent are shown in \autoref{tab:durations}.

\begin{table}[\floatpos]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    unit        & abbreviation & equivalence for n         \\
    \hline
    millisecond & ms           & $n / 1000$         \\
    second      & s            & $n$                \\
    minute      & m            & $n * 60$           \\
    hour        & h            & $n * 60 * 60$      \\
    day         & d            & $n * 60 * 60 * 24$ \\
    \hline
  \end{tabular}
  \caption{Duration units}
  \label{tab:durations}
\end{table}

\subsubsection{Floats}
\label{sec:us-syn-lit-float}

Literal \dfn{floats} consist in a succession of digit, representing
the integral part of the number in decimal base, possibly followed by
a dot (\lstinline|.|) and another succession of digits representing
the decimal part. Briefly, float literals match the
\lstinline|[0-9]+(\.[0-9]+)?| regular
expression. \autoref{lst:literal-floats} is an example of literal
floats.

\begin{urbiscript}[caption=Literal floats,label=lst:literal-floats,float=\floatpos]
1;
[00000000] 1
1.1;
[00000000] 1.1
\end{urbiscript}

\subsubsection{Lists}
\label{sec:us-syn-lit-list}

Literal \dfn{lists} are represented with a comma-separated, potentially
empty list of arbitrary expressions enclosed in square brackets
(\lstinline|[]|), as shown in \autoref{lst:literal-lists}.

\begin{urbiscript}[caption=Literal lists,label=lst:literal-lists,float=\floatpos]
[]; // The empty list
[00000000] []
[1, 2, 3];
[00000000] [1, 2, 3]
\end{urbiscript}

\subsubsection{Strings}

\dfn{String} literals are enclosed in double quotes (\lstinline|"|)
and can contain arbitrary characters, which stand for themselves, with
the exception of the escape character, backslash (\lstinline|\|), see
\autoref{lst:literal-strings}. Backslash introduces the following
escapes:

\begin{itemize}
  \item \lstinline |\\|: backslash
  \item \lstinline|\a|: bell ring
  \item \lstinline|\b|: backspace
  \item \lstinline|\f|: form feed
  \item \lstinline|\n|: line feed
  \item \lstinline|\r|: carriage return
  \item \lstinline|\t|: tabulation
  \item \lstinline|\v|: vertical tabulation
\end{itemize}

The interpreter prints escaped strings; for instance, line feed
will be printed out as \lstinline|\n| when a string result is
dumped. An actual line feed will of course be output if a string
content is printed with echo for instance.

\begin{urbiscript}[caption=Literal strings,label=lst:literal-strings,float=\floatpos]
"";
[00000000] ""
"foo";
[00000000] "foo"
"a\nb"; // UrbiScript escapes string when dumping them
[00000000] "a\nb"
echo("a\nb"); // We can see there is an actual line feed
[00000000] *** a
[:]b
echo("a\\nb");
[00000000] *** a\nb
\end{urbiscript}

\subsection{Operators}

\us supports many \dfn{operators}, most of which are inspired from
\Cxx. Their syntax is presented here, and they are sorted and
described with their original semantics --- that is, \lstinline|+| is
an arithmetic operator that sums two numeric values. However, as in
\Cxx, these operators might be use for any other purpose --- that is,
\lstinline|+| can also be used as the concatenation operator on lists
and strings. Their semantics is thus not limited to what is presented
here.

Tables in this section sort operators top-down, by precedence order.
Group of rows (not separated by horizontal lines) describe operators
that have the same precedence. Many operators are syntactic sugar that
bounce on a method. In this case, the equivalent desugared expression
is shown in the ``Equivalence'' column. This can help you determine
what method to override to define an operator for an object (see
\fixme{autoref{sec:fixme}}).

This section defines the syntax, precedence and associativity of the
operators. Their semantics is described in \autoref{sec:stdlib} in the
documentation of the classes that provide them.

% Operator generators
\newcommand{\operatorhead}{Operator & Use & Associativity & Original semantic
  & Equivalence\\}


\newcommand{\operator}[6][ ]{\lstinline@#2@&\lstinline@#3@&#4&#5&\lstinline@#6@#1\\}
\newcommand{\boperator}[3]{\operator{#1}{a #1 b}{#2}{#3}{a.'#1'(b)}}
\newcommand{\poperator}[3]{\operator{#1}{#1a}{#2}{#3}{a.'#1'()}}

\newcommand{\operatordot}    {\operator  {.}    {a.b}              {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatordota}   {\operator  {.}    {a.b(args)}        {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatorsub}    {\operator  {[]}   {a[args]}          {-}     {Subscript}                {a.'[]'(args)}          }
\newcommand{\operatorsubass} {\operator  {[] =} {a[args] = v}      {-}     {Subscript assignment}     {a.'[]='(args, v)}      }
\newcommand{\operatorass}[2][ ]    {\operator[#1]
                                         {=}    {a = b}            {Right} {Assignment}               {updateSlot("a", b)}    }

\newcommand{\operatoriass}[1]{\operator  {#1=}  {a #1= b}          {Right} {In place assignment}      {a = a #1 b}            }
\newcommand{\operatorsiass}  {
    \operatoriass{+}
    \operatoriass{-}
    \operatoriass{*}
    \operatoriass{/}
    \operatoriass{\%}
    \operatoriass{\^}
    \operatoriass{\~}
}
\newcommand{\operatorinc}    {\operator  {++}   {a++}              {-}     {Incrementation}           {(a = a + 1) - 1}       }
\newcommand{\operatordec}    {\operator  {--}   {a--}              {-}     {Incrementation}           {(a = a - 1) + 1}       }

\newcommand{\operatoruplus}  {\poperator {+}    {-}                {Identity}               }
\newcommand{\operatorumin}   {\poperator {-}    {-}                {Opposite}               }
\newcommand{\operatorexp}    {\boperator {**}   {Right}            {Exponentiation}         }
\newcommand{\operatormult}   {\boperator {*}    {Left}             {Multiplication}         }
\newcommand{\operatordiv}    {\boperator {/}    {Left}             {Division}               }
\newcommand{\operatormod}    {\boperator {\%}   {Left}             {Modulo}                 }
\newcommand{\operatorplus}   {\boperator {+}    {Left}             {Sum}                    }
\newcommand{\operatorminus}  {\boperator {-}    {Left}             {Difference}             }
\newcommand{\operatorlshift} {\boperator {<<}   {Left}             {Left bit shift}         }
\newcommand{\operatorrshift} {\boperator {>>}   {Left}             {Right bit shift}        }
\newcommand{\operatoreq}     {\boperator {==}   {Non Associative}  {Equality}               }
\newcommand{\operatorneq}    {\boperator {!=}   {Non Associative}  {Inequality}             }
\newcommand{\operatorpeq}    {\boperator {===}  {Non Associative}  {Physical equality}      }
\newcommand{\operatorpneq}   {\boperator {!==}  {Non Associative}  {Physical Inequality}    }
\newcommand{\operatoraeq}    {\boperator {=~=}  {Non Associative}  {Approximative equality} }
\newcommand{\operatorinf}    {\boperator {<}    {Non Associative}  {Less than}              }
\newcommand{\operatorinfeq}  {\boperator {<=}   {Non Associative}  {Less than or equal to}  }
\newcommand{\operatorsup}    {\boperator {>}    {Non Associative}  {Greater than}           }
\newcommand{\operatorsupeq}  {\boperator {>=}   {Non Associative}  {Greater than or equal to}}
\newcommand{\operatorbxor}   {\boperator {^}    {Left}             {Bitwise exclusive or}   }
\newcommand{\operatorneg}    {\poperator {!}    {Left}             {Logical negation}       }
\newcommand{\operatorand}    {\boperator {\&\&} {Left}             {Logical and}            }
\newcommand{\operatoror}     {\boperator {||}   {Left}             {Logical or}             }

\subsubsection{Arithmetic operators}

\us supports classic \dfn{arithmetic operators}, with the classic
semantics on numeric values. See \autoref{tab:arithmetic-operators}
and \autoref{lst:arithmetic-operators}.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
  \end{tabular}
  \caption{Arithmetic operators}
  \label{tab:arithmetic-operators}
\end{table}

\begin{urbiscript}[caption=Arithmetic operators,
  label=lst:arithmetic-operators]
1 + 1;
[00000000] 2
1 - 2;
[00000000] -1
2 * 3;
[00000000] 6
10 / 2;
[00000000] 5
2 ** 10;
[00000000] 1024
-(1 + 2);
[00000000] -3
\end{urbiscript}

\subsubsection{Assignment operators}

\dfn{Assignment} in \us can be performed with the \lstinline|=|
operator.  Shorthands such as \lstinline|+=| exist; they are not
redefinable since they are equivalent to a regular assignment combined
with another operator. See \autoref{tab:assignment-operators} and
\autoref{lst:assignment-operators}.


\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorass[\footnotemark]{}
    \operatorsiass
    \hline
  \end{tabular}
  \caption{Assignment operators}
  \label{tab:assignment-operators}
\end{table}
\footnotetext{For object fields only. Assignment to local variables
  cannot be redefined. }

% FIXME: this in place modulo example was removed
%         because %= is a lame Urbi operator.
%  x %= 3;


\begin{urbiscript}[caption=Assignment operators,
  label=lst:assignment-operators]
var x = 0;
[00000000] 0
x = 10;
[00000000] 10
x += 10;
[00000000] 20
x /= 5;
[00000000] 4
x++;
[00000000] 4
x;
[00000000] 5
\end{urbiscript}

\subsubsection{Bitwise operators}

\us features \dfn{bitwise operators}.  They are also used for other
purpose than bit-related operations. See
\autoref{tab:bitwise-operators} and \autoref{lst:bitwise-operators}.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatorbxor
    \hline
  \end{tabular}
  \caption{Bitwise operators}
  \label{tab:bitwise-operators}
\end{table}

\begin{urbiscript}[caption=Bitwise operators,
  label=lst:bitwise-operators]
4 << 2;
[00000000] 16
4 >> 2;
[00000000] 1
\end{urbiscript}

\subsubsection{Boolean operators}

\us supports the usual \dfn{Boolean operators}. See
\autoref{tab:bool-operators} and \autoref{lst:bool-operators}.  The
operators \lstinline|&&| and \lstinline-||- are short-circuiting:
their right-hand side is evaluated only if needed.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
  \end{tabular}
  \caption{Boolean operators}
  \label{tab:bool-operators}
\end{table}

\begin{urbiscript}[caption=Boolean operators, label=lst:bool-operators]
true && true;
[00000000] true
true || false;
[00000000] true
!true;
[00000000] false
true || (1 / 0);
[00000000] true
false && (1 / 0);
[00000000] false
\end{urbiscript}

\subsubsection{Comparison operators}

\us supports classical \dfn{comparison operators}. See
\autoref{tab:comparison-operators} and
\autoref{lst:comparison-operators}.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoraeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
  \end{tabular}
  \caption{Comparison operators}
  \label{tab:comparison-operators}
\end{table}

\begin{urbiscript}[caption=Comparison operators,
  label=lst:comparison-operators]
0 < 0;
[00000000] false
0 <= 0;
[00000000] true
0 == 0;
[00000000] true
0 === 0;
[00000000] false
var x = 0;
[00000000] 0
x === x;
[00000000] true
x !== x;
[00000000] false
\end{urbiscript}

\subsubsection{Miscellaneous operators}

These operators do not fit the previous categories. See
\autoref{tab:miscellaneous-operators} and
\autoref{lst:miscellaneous-operators}. Note that the
\dfn[operator!subscript]{subscript} (square bracket) operator is
\dfn{variadic}: it takes any number of arguments that will be passed
to the \lstinline|'[]'| method of the targeted object.

\begin{table}[\floatposh]
  \caption{Miscellaneous operators}
  \label{tab:miscellaneous-operators}
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
  \end{tabular}
\end{table}

\begin{urbiscript}[caption=Miscellaneous operators,
  label=lst:miscellaneous-operators]
// On lists.
var l = [1, 2, 3, 4, 5];
[00000000] [1, 2, 3, 4, 5]
l[0];
[00000001] 1
l[-1];
[00000002] 5
l[0] = 10;
[00000003] 10
l;
[00000004] [10, 2, 3, 4, 5]

// On strings.
var s = "abcdef";
[00000005] "abcdef"
s[0];
[00000006] "a"
s[1,3];
[00000007] "bc"
s[1,3] = "foo";
[00000008] "foo"
s;
[00000009] "afoodef"
\end{urbiscript}

\clearpage
\subsubsection{All operators summary}

\autoref{tab:operators-summary} is a summary of all operators, to highlight
the overall precedences. Operators are sorted by decreasing
precedence. Groups of rows represent operators with the same
precedence.

\begin{table}[\floatposh]
  \caption{Operators summary}
  \label{tab:operators-summary}
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    Operator               & Use                                    & Associativity
    & Original semantic    & Equivalence                            \\
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoraeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
    \operatorbxor
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
    \operatorass
    \operatorsiass
    \hline
    \operatorinc
    \operatordec
    \hline
  \end{tabular}

\end{table}

\FloatBarrier

\section{Scopes and local variables}

\subsection{Scopes}

% FIXME: This is wrong: the last separator isn't ignored; a pipe voids
% the result, for instance.
\dfn{Scopes} in \us are sequences of expressions, enclosed in curly brackets
(\lstinline|{}|). Expressions are separated with the four expression
separators (see \fixme{autoref{sec:fixme}}). The last separator is optional and
ignored if present. Scopes are themselves expressions, and can thus be
used in composite expressions, nested, and so forth.

\begin{urbiscript}[caption=Scopes,label=lst:scopes,float=\floatpos]
// Scopes evaluate to their last expression
{
  1;
  2;
  3;
};
[00000000] 3
// Scopes can be used as expressions
{1; 2; 3} + 1;
[00000000] 4
\end{urbiscript}

\subsection{Local variables}

\dfn{Local variables} are introduced with the \lstinline|var| keyword,
followed by an identifier (see \autoref{sec:us-syn-id}) and an optional
initialization value assignment. If the initial value is omitted, it
defaults to \refObject{void}. Variable
declarations evaluate to
the initialization value. They can later be referred to by their
name. Their value can be changed with the assignment operator; such an
assignment expression returns the new value. The use of local
variables is illustrated in \autoref{lst:local-variables}.

\begin{urbiscript}[caption=Using local variables,
  label=lst:local-variables,float=\floatpos]
// This declare variable x with value 42, and evaluates to 42.
var x = 42;
[00000000] 42
// x equals 42
x;
[00000000] 42
// We can assign it a new value
x = 51;
[00000000] 51
x;
[00000000] 51
// Initialization defaults to void
var y;
y.isVoid;
[00000000] true
\end{urbiscript}

The lifespan of local variables is the same as their enclosing scope. They
are thus only accessible from their scope and its
subscopes\footnote{Local variables can actually escape their scope
  with lexical closures, see \autoref{sec:us-fun-closures}.}. Two
variables with the same name cannot be defined in the same scope. A
variable with the same name can be defined in an inner scope, in which
case references refer to the innermost variable, as shown in
\autoref{lst:local-variables-scoping}.

\begin{urbiscript}[caption=Local variables scoping,
  label=lst:local-variables-scoping,float=\floatpos]
{
  var x = "x";
  var y = "outer y";
  {
    var y = "inner y";
    var z = "z";
    // We can access variables of parent scopes.
    echo(x);
    // This refers to the inner y.
    echo(y);
    echo(z);
  };
  // This refers to the outer y.
  echo(y);
  // This would be invalid: z does not exist anymore.
  // echo(z);
  // This would be invalid: x is already declared in this scope.
  // var x;
};
[00000000] *** x
[00000000] *** inner y
[00000000] *** z
[00000000] *** outer y
\end{urbiscript}

\FloatBarrier
\section{Functions}

\subsection{Function Definition}

\dfn{Functions} in \us are first class citizens: a function is a
value, like floats and strings, and can be handled as such.  This is
different from most \C-like languages.  One can create a functional
value thanks to the \lstinline|function| keyword, followed by the list
of formal arguments and a compound statement representing the body of
the function. Formal arguments are a comma separated list of
identifiers. \autoref{lst:function} illustrates this.

\begin{urbiscript}[caption=Functional value,label=lst:function,float=\floatpos]
function (arg1, arg2) { echo(0) };
[00000000] function (arg1, arg2) {
[:]  echo(0)
[:]}
\end{urbiscript}

Usually functions are bound to an identifier to be invoked later.
\autoref{lst:function-sugar} shows a short-hand to define a named
function.

\begin{urbiscript}[caption=Storing functions in variables,
  label=lst:function-sugar,float=\floatpos]
// Functions are often stored in variables to call them later
var f1 = function () {
  echo("hello")
};
[00000000:hide] function () {
[:]  echo("hello")
[:]}

f1();
[00000000] *** hello
// This form is strictly equivalent, yet simpler
function f2()
{
  echo("hello")
};
[00000000:hide] function () {
[:]  echo("hello")
[:]}

f2();
[00000000] *** hello
\end{urbiscript}


\subsection{Arguments}

The list of formal arguments defines the number of argument the
function requires. They are accessible by their name from within the
body, as shown in \autoref{lst:function-args}.  If the list of formal
arguments is omitted, the number of effective arguments is not
checked, and arguments themselves are not evaluated. Arguments can
then be manipulated with the call message, explained in
\autoref{sec:us-fun-callmsg}.

\begin{urbiscript}[caption=Storing and calling
  functions,label=lst:function-args,float=\floatpos]
var f = function(a, b) {
  echo(b);
  echo(a);
};
[00000000:hide] function (a, b) {
[:]  echo(b);
[:]  echo(a);
[:]}

f(1, 0);
[00000000] *** 0
[00000000] *** 1
// Calling a function with the wrong number of argument is an error
f(0);
[00000000:error] !!! f: Expected 2 arguments, given 1
f(0, 1, 2);
[00000000:error] !!! f: Expected 2 arguments, given 3
\end{urbiscript}

\subsection{Return value}

The \dfn[function!return value]{return value} of the function is the
evaluation of its body --- that is, since the body is a scope, the
last evaluated expression in the scope.  Values can be returned
manually with the \lstinline|return| keyword followed by the value, in
which case the evaluation of the function is stopped. If
\lstinline|return| is used with no value, the function returns
\lstinline|void|. See \autoref{lst:function-return}.

\begin{urbiscript}[caption=Returning values from functions,
  label=lst:function-return,float=\floatpos]
function f(a, b)
{
  echo(a);
  echo(b);
  a // Return value is a
};
[00000000:hide] function (a, b) {
[:]  echo(a);
[:]  echo(b);
[:]  a
[:]}

f(1, 2);
[00000000] *** 1
[00000000] *** 2
[00000000] 1
function g(a, b)
{
  echo(a);
  return a; // Stop execution at this point and return a
  echo(b); // This is not executed
};
[00000000:hide] function (a, b) {
[:]  echo(a);
[:]  return a;
[:]  echo(b);
[:]}

g(1, 2);
[00000000] *** 1
[00000000] 1
function h()
{
  return; // Stop execution at this point and return void
  echo(0); // This is not executed
};
[00000000:hide] function () {
[:]  return;
[:]  echo(0);
[:]}

h(); // Returns void, so nothing is printed.
\end{urbiscript}

\subsection{Call messages}
\label{sec:us-fun-callmsg}

Functions can access meta-information about how they were called,
through a \lstinline|CallMessage| object. The \dfn{call message}
associated with a function can be accessed with the \lstinline|call|
keyword. It contains several information such as not-yet evaluated
arguments, the name of the function, the target \ldots

\subsection{Strictness}

\us features two different function calls:
\dfn[function!strict]{strict} function calls, effective arguments are
evaluated before invoking the function, and \dfn[function!lazy]{lazy}
function calls, arguments are passed as-is to the function.  As a
matter of fact, the difference is rather that there are strict
functions and lazy function.

Functions defined with a (possibly empty) list of formal arguments in
parentheses are strict: the effective arguments are first evaluated,
and then their value is given to the called function.  See
\autoref{lst:us-fun-strict}.

\begin{urbiscript}[caption=Strict Functions,
  label=lst:us-fun-strict,float=\floatpos]
function first(a, b) {
  echo(a); echo(b)
};
[00000000:hide] function (a, b) {
[:]  echo(a);
[:]  echo(b)
[:]}

first({echo("Arg1"); 1},
      {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

A function declared with no formal argument list is lazy.  Use its
call message to manipulate its \emph{unevaluated} arguments.
\autoref{lst:function-lazy} gives an example.  More information about
this can be found in the \refObject{CallMessage} class documentation.

\begin{urbiscript}[caption=Lazy function,label=lst:function-lazy]
function first
{
  echo(call.evalArgAt(0));
  echo(call.evalArgAt(1));
};
[00000000:hide] function {
[:]  echo(call . evalArgAt(0));
[:]  echo(call . evalArgAt(1));
[:]}

first({echo("Arg1"); 1},
      {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** 1
[00000000] *** Arg2
[00000000] *** 2
\end{urbiscript}

A lazy function may implement a strict interface by evaluating its
arguments and storing them as local variables, see
\autoref{lst:lazy-2-strict}.  This is less efficient than defining a
strict function.

\begin{urbiscript}[caption=Lazy functions with strict semantics,
  label=lst:lazy-2-strict]
function first
{
  var a = call.evalArgAt(0);
  var b = call.evalArgAt(1);
  echo(a); echo(b);
};
[00000000:hide] function {
[:]  var a = call . evalArgAt(0);
[:]  var b = call . evalArgAt(1);
[:]  echo(a);
[:]  echo(b);
[:]}

first({echo("Arg1"); 1},
      {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

\subsection{Lexical closures}
\label{sec:us-fun-closures}

\dfn{Lexical closures} are an additional scoping rule, with which a function
can refer to a local variable located outside the function --- but still
in the current context. \us supports read/write lexical closures,
meaning that the variable is shared between the function and the outer
environment, as shown in \autoref{lst:function-closure}.

\begin{urbiscript}[caption=Lexical closure,
  label=lst:function-closure,float=\floatpos]
var x = 0;
[00000000:hide] 0

function cl()
{
  // x refers to a variable outside the function
  x++;
  echo(x);
};
[00000000] function () {
[:]  x++;
[:]  echo(x);
[:]}

cl();
[00000000] *** 1
x;
[00000000] 1
x++;
[00000000] 1
cl();
[00000000] *** 3
\end{urbiscript}

\autoref{lst:function-closure-escape} illustrate that local variables can even
escape their declaration scope by lexical closure.

\begin{urbiscript}[caption=Local variable escaping its scope by
  lexical closure.,label=lst:function-closure-escape,float=\floatpos]
function wrapper()
{
  // Normally, x is local to 'wrapper', and is limited to this scope.
  var x = 0;
  at (x > 1)
    echo("ping");
  // Here we make it escape the scope by returning a closure on it.
  return function() { x++ };
};
[00000000:hide] function () {
[:]  var x = 0;
[:]  Control . at_(x . '>'(1), detach(echo("ping")), detach({}));
[:]  return function () {
[:]    x++
[:]  };
[:]}

var f = wrapper();
[00000000:hide] function () {
[:]  x++
[:]}
f();
[00000000] 0
f();
[00000000] 1
[00000000] *** ping
\end{urbiscript}

\FloatBarrier
\section{Objects}

Any value in \us is an object. Objects contain:

\begin{itemize}
\item A list of prototypes, which are also objects.
\item A list of slots, which to a name associate an object.
\end{itemize}

\subsection{Slots}

\subsubsection{Manipulation}

\dfn{Objects} can contain any number of \dfn{slots}, every slot has a
name and a value. They are often called ``fields'', ``attributes'' or
``members'' in other object-oriented languages.

The \lstinline|createSlot| function adds a slot to an object with the
void (\autoref{sec:std-void}) value. The \lstinline|updateSlot|
function changes the value of a slot; \lstinline|getSlot| reads
it. The \lstinline|setSlot| method creates a slot with a given
value. Finally, the \lstinline|slotNames| method returns the list of
the object slot's name. \autoref{lst:slots} shows how to manipulate
slots. More documentation about these methods can be found in
\autorefObject{Object}.

\begin{urbiscript}[caption=Manipulating slots, label=lst:slots,
  float=\floatpos]
var o = Object.new;
[00000000:hide] Object_0xADDR
o.slotNames;
[00000000] []
o.createSlot("test");
o.slotNames;
[00000000] ["test"]
o.getSlot("test").asString;
[00000000] "void"
o.updateSlot("test", 42);
[00000000] 42
o.getSlot("test");
[00000000] 42
\end{urbiscript}

\subsubsection{Syntactic Sugar}

Syntactic sugar eases the use of slot methods:

\begin{itemize}
\item \lstinline|var o.name| is equivalent to
  \lstinline|o.createSlot("name")|.
\item \lstinline|var o.name = value| is equivalent to
  \lstinline|o.setSlot("name", value)|.
\item \lstinline|o.name = value| is equivalent to
  \lstinline|o.updateSlot("name", value)|.
\end{itemize}


\subsection{Prototypes}

\subsubsection{Manipulation}

\us is a prototype-based language, unlike most classical object
oriented language, which are class-based. In prototype-based
languages, objects have no type, only \dfn{prototypes}, from which they
inherit behavior.

\us objects can have several prototypes. The list of prototypes is
given by the \lstinline|protos| method; they can be added or removed
with \lstinline|addProto| and \lstinline|removeProto| (see
\autoref{lst:prototypes}).  See \autorefObject{Object} for more
documentation.

\begin{urbiscript}[caption=Manipulating prototypes, label=lst:prototypes,
  float=\floatpos]
var o = Object.new;
[00000000:hide] Object_0xADDR

o.protos;
[00000000] [Object]
o.addProto(Pair);
[00000000:hide] (nil, nil)
o.protos;
[00000000] [(nil, nil), Object]
o.removeProto(Object);
[00000000:hide] (nil, nil)
o.protos;
[00000000] [(nil, nil)]
\end{urbiscript}

\subsubsection{Inheritance}

Objects inherit their prototypes' slots: \lstinline|getSlot| will also
look in an object prototypes' slots. \lstinline|getSlot| performs a
depth-first traversal of the prototypes hierarchy to find slots. That
is, when looking for a slot in an object:

\begin{itemize}
\item \lstinline|getSlot| checks first if the object itself has the
  requested slot. If so, it returns its value.
\item Otherwise, it applies the same research on every prototype, in
  the order of the prototype list (since addProto inserts in the front
  of the prototype list, the last prototype added has priority). This
  search is recursive: \lstinline|getSlot| will also look in the first
  prototype's prototype, etc before looking in the second
  prototype. If the slot is found in a prototype, it is returned.
\item Finally, if no prototype had the slot, an error is raised.
\end{itemize}

\autoref{lst:inheritance} shows how slots are inherited.

\begin{urbiscript}[caption=Slots inheritance, label=lst:inheritance,
  float=\floatpos]
var a = Object.new;
[00000000:hide] Object_0xADDR

var b = Object.new;
[00000000:hide] Object_0xADDR

var c = Object.new;
[00000000:hide] Object_0xADDR

a.setSlot("x", "slot in a");
[00000000:hide] "slot in a"
b.setSlot("x", "slot in b");
[00000000:hide] "slot in b"
// c has no "x" slot
c.getSlot("x");
[00000000:error] !!! lookup failed: x
// c can inherit the "x" slot from a
c.addProto(a);
[00000000:hide] Object_0xADDR
c.getSlot("x");
[00000000] "slot in a"
// b is prepended to the prototype list, and has thus priority
c.addProto(b);
[00000000:hide] Object_0xADDR
c.getSlot("x");
[00000000] "slot in b"
// a local slot in c has priority over prototypes
c.setSlot("x", "slot in c");
[00000000:hide] "slot in c"
c.getSlot("x");
[00000000] "slot in c"
\end{urbiscript}

\subsubsection{Copy on write}

The \lstinline|updateSlot| method has a particular behavior with
respect to prototypes. Although performing an \lstinline|updateSlot|
on a non existent slot is an error, it is valid if the slot is
inherited from a prototype. In this case, the slot is however not
updated in the prototype, but rather created in the object itself,
with the new value. This process is called \dfn{copy on write}; thanks
to it, prototypes are not altered when the slot is overridden in a
child object (see \autoref{lst:copy-on-write}).

\begin{urbiscript}[caption=Copy on write, label=lst:copy-on-write,
  float=\floatpos]
var p = Object.new;
[00000000:hide] Object_0xADDR

var p.slot = 0;
[00000000:hide] 0

var c = Object.new;
[00000000:hide] Object_0xADDR

c.addProto(p);
[00000000:hide] Object_0xADDR

c.slot;
[00000000] 0
c.slot = 1;
[00000000] 1
// p's slot was not altered
p.slot;
[00000000] 0
// It was copied in c
c.slot;
[00000000] 1
\end{urbiscript}

\subsection{Sending messages}

A \dfn{message} in \us consists in a message name and arguments. One can
send a message to an object with the dot (\lstinline|.|) operator,
followed by the message name (which can be any valid identifier) and
the arguments, as shown in \autoref{lst:messages}. When there are no
arguments, the parentheses can be omitted. As you might see,
sending messages is very similar to calling methods in classical
languages.

\begin{urbiscript}[caption=Sending messages, label=lst:messages,
  float=\floatpos]
// Send the message msg to object obj, with arguments arg1 and arg2.
obj.msg(arg1, arg2);
// Send the message msg to object obj, with no arguments.
obj.msg();
// This is strictly equivalent.
obj.msg;
\end{urbiscript}

When a message ``msg'' is sent to object \lstinline|obj|:

\begin{itemize}
\item The ``msg'' slot of \lstinline|obj| is retrieved (i.e.,
  \lstinline|obj.getSlot("msg")|). If the slot is not found, the
  classic lookup error is raised.
\item If the object is not a \lstinline|Routine|
  (\fixme{autoref{sec:fixme}}), it's
  the result of the message sending. In this case, there must be no
  argument, otherwise an error is raised.
\item If the object is a \lstinline|Routine|, it is invoked with the
  message sending arguments, and the returned value is the result. As
  a consequence, the number of arguments in the message sending must
  match the one required by the \lstinline|Routine|.
\end{itemize}

Such message sending is illustrated by \autoref{lst:send-message}.

\begin{urbiscript}[caption=Sending messages, label=lst:send-message,
  float=\floatpos]
var o = Object.new;
[00000000:hide] Object_0xADDR

var o.a = 42;
[00000000:hide] 42

var o.b = function (x) { x + 1 };
[00000000:hide] function (x) {
[:]  x . '+'(1)
[:]}

o.a;
[00000000] 42
o.a();
[00000000] 42
o.a(50);
[00000000:error] !!! a: Expected 0 argument, given 1
o.b;
[00000000:error] !!! b: Expected 1 argument, given 0
o.b();
[00000000:error] !!! b: Expected 1 argument, given 0
o.b(50);
[00000000] 51
\end{urbiscript}

\FloatBarrier
\section{Imperative flow control}

\subsection{break}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|break| makes the execution jump after the loop. See
\autoref{lst:break}.

\begin{urbiscript}[caption=Using break, label=lst:break,
  float=\floatpos]
var i = 5;
[00000000:hide] 5

for (; true; echo(i))
{
  if (i > 8)
    break;
  i++;
};
[00000000] *** 6
[00000000] *** 7
[00000000] *** 8
[00000000] *** 9
\end{urbiscript}

\subsection{continue}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|continue| short-circuits the rest of the loop-body, and
runs the next iteration (if there remains one). See
\autoref{lst:continue}.

\begin{urbiscript}[caption=Using continue, label=lst:continue,
  float=\floatpos]
for (var i = 0; i < 8; i++)
{
  if (i % 2 != 0)
    continue;
  echo(i);
};
[00000000] *** 0
[00000000] *** 2
[00000000] *** 4
[00000000] *** 6
\end{urbiscript}

\subsection{do}

The \lstinline|do| construct enables do evaluate an expression with a
different ``\lstinline|this|''.

\begin{urbiscript}[frame=, backgroundcolor=, ]
do (target)
{
  body
};
[00000000:hide] Object_0xADDR

\end{urbiscript}

It evaluates \lstinline|body|, with \lstinline|this| being
\lstinline|target|, as shown in \autoref{lst:do}.  The \lstinline|do| itself
evaluates to \lstinline|body|.

\begin{urbiscript}[caption=Using \lstinline|do|, label=lst:do,
  float=\floatpos]
var x = 1024;
[00000000:hide] 1024

do (x)
{
  echo(this);
  echo(sqrt);
  setSlot("y", 0);
};
[00000000] *** 1024
[00000000] *** 32
[00000000] 1024
\end{urbiscript}

\subsection{for}

\us support the classical \C-like \lstinline|for| construct.

\begin{urbiscript}[frame=, backgroundcolor=, ]
for (initialization; condition; increment)
  body;
\end{urbiscript}

It has the exact same behavior as \C's \lstinline|for|:

\begin{enumerate}
\item The \lstinline|initialization| is evaluated.
\item The \lstinline|condition| is evaluated. If the result is false,
  executions jump after the \lstinline|for|.
\item The \lstinline|body| is evaluated. If \lstinline|continue| is
  encountered, execution jumps to point 4. If \lstinline|break| is
  encountered, executions jumps after the \lstinline|for|.
\item The \lstinline|increment| is evaluated.
\item Execution jumps to point 2.
\end{enumerate}

\subsection{for in}

\us supports iteration over a collection with another form of the
\lstinline|for| loop.

\begin{urbiscript}[frame=, backgroundcolor=, ]
for (var name in collection)
   body;
\end{urbiscript}

It evaluates \lstinline|body| for each element in
\lstinline|collection|. Inside \lstinline|body|, the current element
is accessible via the \lstinline|name| local
variable. \autoref{lst:foreach} illustrates this.


\begin{urbiscript}[caption=Iterating over a collection with for, label=lst:foreach,
  float=\floatpos]
for (var x in [0, 1, 2, 3, 4])
  echo(x.sqr);
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 9
[00000000] *** 16
\end{urbiscript}

This form of \lstinline|for| simply sends the ``each'' message to
\lstinline|collection| with one argument: the function that takes the
current element and performs \lstinline|action| over it. Thus, you can
make any object acceptable in a \lstinline|for| by defining an
adequate \lstinline|each| method.

\begin{urbiscript}
var Hobbits = Object.new;
[00000000:hide] Object_0xADDR
function Hobbits.each (action)
{
  action("Frodo");
  action("Merry");
  action("Pippin");
  action("Sam");
};
[00000000:hide] function (action) {
[:]  action("Frodo");
[:]  action("Merry");
[:]  action("Pippin");
[:]  action("Sam");
[:]}

for (var name in Hobbits)
  echo("%s is a hobbit." % [name]);
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
// This for statement is equivalent to:
Hobbits.each(function (name) { echo("%s is a hobbit." % [name]) });
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
\end{urbiscript}

\subsection{if}

\us supports the usual \lstinline|if| construct.

\begin{urbiscript}[frame=, backgroundcolor=, ]
if (condition)
  action;

if (condition)
  action
else
  otherwise;
[00000000:hide] Object_0xADDR
\end{urbiscript}

If the \lstinline|condition| evaluation is true, \lstinline|action| is
evaluated. Otherwise, in the latter version, \lstinline|otherwise| is
executed.  Contrary to \C/\Cxx, there \emph{must not} be a semicolon
after the \lstinline|action|; it would end the
\lstinline|if|/\lstinline|else| construct prematurely.

\subsection{switch}

The \lstinline|switch| statement in \us is similiar to \C's one.

\begin{urbiscript}[frame=, backgroundcolor=, ]
switch (value)
{
  case value_one:
    action_one;
  case value_two:
    action_two;
//case ...:
//  ...
  default:
    default_action;
};
[00000000:hide] 3
\end{urbiscript}

It might contain an arbitrary number of cases, and optionally a
default case. The \lstinline|value| is evaluated first, and then the
result is compared sequentially with the evaluation of all cases
values, with the \lstinline|==| operator, until one comparison is
true. If such a match is found, the corresponding action is executed,
and execution jumps after the \lstinline|switch|. Otherwise, the
default case --- if any --- is executed, and execution jumps after the
switch. The switch itself evaluates to case that was evaluated, or to
void if no match was found and there's no default case. \autoref{lst:switch}
illustrates \lstinline|switch| usage.

Unlike \C, there are no \lstinline|break| to end \lstinline|case|
clauses: execution will never span over several cases.  Since the
comparisons are performed with the generic \lstinline|==| operator,
\lstinline|switch| can be performed on any comparable data type.

\begin{urbiscript}[caption=The \lstinline|switch| construct,
  label=lst:switch, float=\floatpos]
function sw(v)
{
  switch (v)
  {
    case "":
      echo("Empty string");
    case "foo":
      "bar";
    default:
      v[0];
  }
} | {};
sw("");
[00000000] *** Empty string
sw("foo");
[00000000] "bar"
sw("foobar");
[00000000] "f"
\end{urbiscript}
% $ Pacify emacs math mode.

\subsection{while}

The \lstinline|while| loop is similar to \C's one.

\begin{urbiscript}[frame=, backgroundcolor=, ]
while (condition)
  body;
\end{urbiscript}

If \lstinline|condition| evaluation, is true, \lstinline|body| is
evaluated and execution jumps before the \lstinline|while|, otherwise
execution jumps after the \lstinline|while|. See \autoref{lst:while}.

\begin{urbiscript}[caption=The \lstinline|while| construct, label=lst:while,
  float=\floatpos]
var i = 5;
[00000000:hide] 5

while (i > 0)
{
  echo(i);
  i--;
};
[00000000] *** 5
[00000000] *** 4
[00000000] *** 3
[00000000] *** 2
[00000000] *** 1
\end{urbiscript}

\FloatBarrier
\section{Exceptions}

\subsection{Throwing exceptions}

Use the \lstinline|throw| keyword to \dfn[exception!throwing]{throw
  exceptions}, as shown in \autoref{lst:throw}. Thrown exceptions will
break the execution upward until they are caught, or until they reach
the toplevel --- as in \Cxx.  Contrary to \Cxx, exceptions reaching
the toplevel are printed, and won't abort the kernel --- other and new
connections will continue to execute normally.

\begin{urbiscript}[caption=Throwing exceptions, label=lst:throw,
  float=\floatpos]
throw 42;
[00000000:error] !!! 42
function inner() { throw "exn" } | {};
function outer() { inner() };
[00000000:hide] function () {
[:]  inner()
[:]}
// Exceptions propagate to parent call up to the toplevel
outer();
[00000000:error] !!! exn
[00000000:error] !!!    called from: 3.20-26: inner
[00000000:error] !!!    called from: 4.1-7: outer
\end{urbiscript}

\subsection{Catching exceptions}

Exceptions are \dfn[exception!catching]{caught} with the
\lstinline|try|/\lstinline|catch| construct. It consists of a first
block (the \dfn{try-block}), from which we want to catch exceptions,
and one or more catch clauses to stop the exception
(\dfn{catch-blocks}). Each catch clause defines a pattern against
which the thrown exception is matched. If no pattern is specified, the
catch clause matches systematically (equivalent to
\lstinline|catch (...)| in \Cxx).

Exceptions thrown from the \texttt{try} block are matched sequentially
against all catch clauses. The first matching clause is executed, and
control jumps after the whole try/catch block. If no catch clause
matches, the exceptions isn't stopped and continues
upward. \autoref{lst:catch} illustrates this.

\begin{urbiscript}[caption=Catching exceptions, label=lst:catch,
  float=\floatpos]
function test(e)
{
  try
  { throw e;  }
  catch (0)
  { echo("zero") }
  catch ([var x, var y])
  { echo(x + y) }
} | {};
test(0);
[00002126] *** zero
test([22, 20]);
[00002131] *** 42
test(51);
[00002143:error] !!! 51
[00002143:error] !!!    called from: 12.1-8: test

\end{urbiscript}

\subsection{Inspecting exceptions}

\subsection{Exceptions and parallelism}



\FloatBarrier
\section{Parallel and event-based flow control}

\subsection{at}
\subsection{every}
\subsection{for\& (:)}
\subsection{for\& (n)}
\subsection{waituntil}
\subsection{whenever}

\FloatBarrier
\section{Pattern matching}
\FloatBarrier
\section{Trajectories}

% Local Variables:
%%% mode: latex
%%% TeX-master: "urbi-specs"
%%% End:
