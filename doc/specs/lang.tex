\chapter{\us Language Specifications}
\label{sec:lang}

\section{Syntax}

\subsection{Characters, encoding}
\index{encoding}
\index{ASCII}
\index{UTF-8}

Currently \us makes no assumptions about the encoding used in the
programs, but the streams are handled as 8-bit characters.

While you are allowed to use whatever character you want in the string
literals (especially using the binary escapes,
\autoref{sec:us-syn-lit-string}), only plain ASCII characters are
allowed in the program body.  Invalid characters are reported,
possibly escaped if they are not ``printable''.  If you enter UTF-8
characters, since they possibly span over several 8-bit characters, a
single (UTF-8) character may be reported as several invalid (8-bit)
characters.

%% UTF-8 is not supported by lstlisting, we need to escape to TeX.
%% TeX4ht produces ugly results when using lstnewenvironment.  Worse,
%% here it creates a new <pre> on each side of the escape characters.
%% So let's hope Eitan fixes this some day.
\begin{urbiscript}[escapeinside=<>,firstnumber=last]
#<Été>;
[00048238:error] !!! invalid character: `#'
[00048239:error] !!! invalid character: `\xc3'
[00048239:error] !!! invalid character: `\x89'
[00048239:error] !!! invalid character: `\xc3'
[00048239:error] !!! invalid character: `\xa9'
\end{urbiscript}

\subsection{Comments}

\dfn{Comments} are used to document the code, they are ignored by the
\us interpreter. Both \Cxx comment types are supported.

\begin{itemize}
\item A \lstinline|//| introduces a comment that lasts until the end
  of the line.
\item A \lstinline|/*| introduces a comment that lasts until
  \lstinline|*/| is encountered. Comments nest, contrary to \C/\Cxx:
  if two \lstinline|/*| are encountered, the
  comment will end after two \lstinline|*/|, not one.
\end{itemize}

\begin{urbiscript}[firstnumber=last]
// C++ style comment
/* C style comment */
/* These comments /* do */ nest */
\end{urbiscript}

\subsection{Synclines}
\label{sec:specs:synclines}

While the interaction with an \us kernel is usually performed via a
network connection, programmers are used to work with files which have
names, line numbers and so forth.  This is most important in error
messages.  Since even loading a file actually means sending its
content as if it were typed in the network session, in order to
provide the user with meaningful locations in error messages, \us
features \dfn[syncline]{synclines}, a means to change the ``current
location'', similarly to \lstinline[language=C]|#line| in \C-like
languages.  This is achieved using special \lstinline|//#| comments.

The following special comments are recognized only as a whole line.
If some component does not match exactly the expected syntax, or if
there are trailing items, the whole line is treated as a comment.
\begin{itemize}
%% I failed to use \var for line and file here.  -- AD.
\item \lstinline|//#line line "file"|\\
  Specify that the \emph{next} line is from the file named \var{file},
  and which line number is \var{line}.  The current location (i.e.,
  current file and line) is lost.

\item \lstinline|//#push line "file"|\\
  Save the current location, and then behave as if \lstinline|//#line|
  was used.

\item \lstinline|//#pop|\\
  Restore the current location.  \lstinline|//#push| and
  \lstinline|//#pop| must match.
\end{itemize}


\subsection{Identifiers}
\label{sec:us-syn-id}

\dfn{Identifiers} in \us are composed of one or more alphanumeric or
underscore (\lstinline|_|) characters, not starting by a digit, i.e.,
identifiers match the \lstinline|[a-zA-Z_][a-zA-Z0-9_]*| regular
expression.  Additionally, identifiers must not match any of the \us
reserved words\footnote{
%%
  The only exception to this rule is \lstinline|new|, which can be
  used as the method identifier in a method call.
%%
} documented in \autoref{sec:syn-key}. Identifiers can also be written
between simple quotes (\lstinline|'|), in which case they may contain
any character.

\begin{urbiscript}[firstnumber=last]
var x;
var foobar51;
var this.a_name_with_underscores;
// Invalid.
// var 3x;
// obj.3x();

// Invalid because "if" is a keyword.
// var if;
// obj.if();
// However, keywords can be escaped with simple quotes.
var 'if';
var this.'else';

// Identifiers can be escaped with simple quotes
var '%x';
var '1 2 3';
var this.'[]';
\end{urbiscript}

\subsection{Keywords}
\label{sec:syn-key}

\dfn{Keywords} are reserved words that cannot be used as identifiers,
for instance.  They are listed in \autoref{tab:keywords}.

\renewcommand{\baselinestretch}{.85}
\begin{table}[\floatpos]
  \centering
  \begin{tabular}{|c|c||c|c|}
    \hline
    Keyword                       & Remark                                  &
    Keyword                       & Remark                                  \\
    \hline
    \lstinline"and"               & Synonym for \lstinline|&&|              &
    \lstinline"long"              & Reserved                                \\
    \lstinline"and_eq"            & Synonym for \lstinline|&=|              &
    \lstinline"loop"              & \lstinline|loop&| and
                                    \lstinline-loop|- flavors               \\
    \lstinline"asm"               & Reserved                                &
    \lstinline"loopn"             & Deprecated, use \lstinline|for|         \\
    \lstinline"at"                &                                         &
    \lstinline"mutable"           & Reserved                                \\
    \lstinline"auto"              & Reserved                                &
    \lstinline"namespace"         & Reserved                                \\
    \lstinline"bitand"            & Synonym for \lstinline|&| operator      &
    \lstinline"new"               &                                         \\
    \lstinline"bitor"             & Synonym for \lstinline-|- operator      &
    \lstinline"not"               & Synonym for \lstinline|!| operator      \\
    \lstinline"bool"              & Reserved                                &
    \lstinline"not_eq"            & Synonym for \lstinline|!=| operator     \\
    \lstinline"break"             &                                         &
    \lstinline"object"            &                                         \\
    \lstinline"call"              &                                         &
    \lstinline"onleave"           &                                         \\
    \lstinline"case"              &                                         &
    \lstinline"or"                & Synonym for \lstinline-||- operator     \\
    \lstinline"catch"             & Reserved                                &
    \lstinline"or_eq"             & Synonym for \lstinline-|=- operator     \\
    \lstinline"char"              & Reserved                                &
    \lstinline"private"           & Ignored                                 \\
    \lstinline"class"             &                                         &
    \lstinline"protected"         & Ignored                                 \\
    \lstinline"closure"           &                                         &
    \lstinline"public"            & Ignored                                 \\
    \lstinline"compl"             & Synonym for \lstinline|~|               &
    \lstinline"register"          & Reserved                                \\
    \lstinline"const"             & Reserved                                &
    \lstinline"reinterpret_cast"  & Reserved                               \\
    \lstinline"const_cast"        & Reserved                                &
    \lstinline"return"            &                                         \\
    \lstinline"continue"          &                                         &
    \lstinline"short"             & Reserved                                \\
    \lstinline"default"           & Reserved                                &
    \lstinline"signed"            & Reserved                                \\
    \lstinline"delete"            &                                         &
    \lstinline"sizeof"            & Reserved                                \\
    \lstinline"do"                &                                         &
    \lstinline"static"            & Deprecated                              \\
    \lstinline"double"            & Reserved                                &
    \lstinline"static_cast"       & Reserved                                \\
    \lstinline"dynamic_cast"      & Reserved                                &
    \lstinline"stopif"            &                                         \\
    \lstinline"else"              &                                         &
    \lstinline"struct"            & Reserved                                \\
    \lstinline"emit"              & Deprecated                              &
    \lstinline"switch"            &                                         \\
    \lstinline"enum"              & Reserved                                &
    \lstinline"template"          & Reserved                                \\
                                  &                                         &
    \lstinline"this"              &                                         \\
    \lstinline"every"             &                                         &
    \lstinline"throw"             & Reserved                                \\
    \lstinline"explicit"          & Reserved                                &
    \lstinline"timeout"           &                                         \\
    \lstinline"export"            & Reserved                                &
    \lstinline"try"               & Reserved                                \\
    \lstinline"extern"            & Reserved                                &
    \lstinline"typedef"           & Reserved                                \\
    \lstinline"external"          &                                         &
    \lstinline"typeid"            & Reserved                                \\
    \lstinline"float"             & Reserved                                &
    \lstinline"typename"          & Reserved                                \\
    \lstinline"for"               & \lstinline|for&| and \lstinline-for|- flavors&
    \lstinline"union"             & Reserved                                \\
    \lstinline"foreach"           & Deprecated, use \lstinline|for|    &
    \lstinline"unsigned"          & Reserved                                \\
    \lstinline"freezeif"          &                                         &
    \lstinline"using"             & Reserved                                \\
    \lstinline"friend"            & Reserved                                &
    \lstinline"var"               &                                         \\
    \lstinline"from"              &                                         &
    \lstinline"virtual"           & Reserved                                \\
    \lstinline"function"          &                                         &
    \lstinline"volatile"          & Reserved                                \\
    \lstinline"goto"              & Reserved                                &
    \lstinline"waituntil"         &                                         \\
    \lstinline"if"                &                                         &
    \lstinline"wchar_t"           & Reserved                                \\
    \lstinline"in"                &                                         &
    \lstinline"whenever"          &                                         \\
    \lstinline"inline"            & Reserved                                &
    \lstinline"while"             & \lstinline|while&| and
                                    \lstinline-while|- flavors              \\
    \lstinline"int"               & Reserved                                &
    \lstinline"xor"               & Synonym for \lstinline|^| operator      \\
    \lstinline"internal"          & Deprecated                              &
    \lstinline"xor_eq"            & Synonym \lstinline|^=| operator         \\
    \hline
  \end{tabular}
  \caption{Keywords}
  \label{tab:keywords}
\end{table}
\renewcommand{\baselinestretch}{1}

\subsection{Literals}

\subsubsection{Angles}

\dfn[angle]{Angles} are floats (see \autoref{sec:us-syn-lit-float})
followed by an angle unit. They are simply equivalent to the same
float, expressed in radians. For instance, \lstinline|180deg| (180
degrees) is equal to \lstinline|pi|. Available units and their
equivalent are presented in \autoref{tab:angle}.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    unit        & abbreviation & equivalence for $n$  \\
    \hline
    radian      & rad          & $n$         \\
    degree      & deg          & $n / 180 * \pi$        \\
    grad        & grad         & $n / 200 * \pi$        \\
    \hline
  \end{tabular}
  \caption{Angle units}
  \label{tab:angle}
\end{table}

\begin{urbiassert}[firstnumber=last]
pi == 180deg;
pi == 200grad;
\end{urbiassert}

\subsubsection{Durations}

\dfn{Durations} are floats (see \autoref{sec:us-syn-lit-float})
followed by a time unit. They are simply equivalent to the same float,
expressed in seconds. For instance, \lstinline|1s 1ms|, which stands
for ``one second and one millisecond'', is strictly equivalent to
\lstinline|1.0001|. Available units and their equivalent are presented
in \autoref{tab:duration}.

\begin{table}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    unit        & abbreviation & equivalence for $n$  \\
    \hline
    millisecond & ms           & $n / 1000$         \\
    second      & s            & $n$                \\
    minute      & min          & $n \times 60$           \\
    hour        & h            & $n \times 60 \times 60$      \\
    day         & d            & $n \times 60 \times 60 \times 24$ \\
    \hline
  \end{tabular}
  \caption{Duration units}
  \label{tab:duration}
\end{table}

\begin{urbiassert}[firstnumber=last]
1d == 24h;
1h == 60min;
1min == 60s;
1s == 1000ms;

1s == 1;
1s2s3s == 6;
1s 2s 3s == 6;
1s 1ms == 1.001;
1ms 1s == 1.001;
\end{urbiassert}

\subsubsection{Floats}
\label{sec:us-syn-lit-float}

\us supports the so called \dfn{scientific notation} for
floating-point literals.  See \refObject{Float} for more details.
Examples include:

\begin{urbiscript}[firstnumber=last]
1;
[00000000] 1
1.234e6;
[00000000] 1234000
\end{urbiscript}

\subsubsection{Lists}
\label{sec:us-syn-lit-list}

Literal \dfn{lists} are represented with a comma-separated, potentially
empty list of arbitrary expressions enclosed in square brackets
(\lstinline|[]|), as shown in the listing below.  See
\refObject{List} for more details.

\begin{urbiscript}[firstnumber=last]
[]; // The empty list
[00000000] []
[1, 2, 3];
[00000000] [1, 2, 3]
\end{urbiscript}

\subsubsection{Strings}
\label{sec:us-syn-lit-string}

\dfn{String} literals are enclosed in double quotes (\lstinline|"|)
and can contain arbitrary characters, which stand for themselves, with
the exception of the escape character, backslash (\lstinline|\|), see
below.  The escapes sequences are defined in \autoref{tab:escapes}.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|p{.6\linewidth}|}
    \hline
    \lstinline|\\| & backslash             \\
    \lstinline|\a| & bell ring             \\
    \lstinline|\b| & backspace             \\
    \lstinline|\f| & form feed             \\
    \lstinline|\n| & line feed             \\
    \lstinline|\r| & carriage return       \\
    \lstinline|\t| & tabulation            \\
    \lstinline|\v| & vertical tabulation   \\

    \lstinline|\[0-7]{3}|
    & eight-bit character corresponding to a three-digit octal number.
    For instance, \lstinline|\000| and \lstinline|177|. \\

    \lstinline|\x[0-9a-fA-F]{2}|
    & eight-bit character corresponding to a two-digit hexadecimal
    number.  For instance, \lstinline|0xfF|. \\

    \lstinline|\B(\var{length})(\var{content})|
    & binary blob.  A \var{length}-long sequence of verbatim
    \var{content}.  \var{length} is expressed in decimal.  \var{content}
    is not interpreted in any way.  The parentheses are part of the syntax,
    they are mandatory.  For instance \lstinline|\B(2)(\B)|\\
    \hline
  \end{tabular}
  \caption{String escapes}
  \label{tab:escapes}
\end{table}

Consecutive string literals are glued together into a unique string.
This is useful to split large strings into chunks that fit usual
programming widths.

\begin{urbiassert}[firstnumber=last]
"foo" "bar" "baz" == "foobarbaz";
"\B(3)("\")" == "\"\\\"";
\end{urbiassert}

The interpreter prints the strings escaped; for instance, line feed
will be printed out as \lstinline|\n| when a string result is dumped
and so forth. An actual line feed will of course be output if a string
content is printed with echo for instance.

\begin{urbiscript}[firstnumber=last]
"";
[00000000] ""
"foo";
[00000000] "foo"
"a\nb"; // urbiscript escapes string when dumping them
[00000000] "a\nb"
echo("a\nb"); // We can see there is an actual line feed
[00000000] *** a
[:]b
echo("a\\nb");
[00000000] *** a\nb
\end{urbiscript}

See \refObject{String} for more details.

\subsection{Statement Separators}
\label{sec:lang:separators}

Sequential languages such as \Cxx support a single way to compose two
statements: the sequential composition, ``denoted'' by \samp{;}.  To
support concurrency and more fined tuned sequentiality, \us features
four different statement-separators (or connectors):
\begin{description}
\item[\samp{;}] sequentiality
\item[\samp{|}] tight sequentiality
\item[\samp{,}] background concurrency
\item[\samp{\&}] fair-start concurrency
\end{description}

\subsubsection{\samp{;}}

The \samp{;}-connector waits for the first statement to finish before
starting the second statement.  When used in the top-level interactive
session, both results are displayed.

\begin{urbiscript}[firstnumber=last]
1; 2; 3;
[00000000] 1
[00000000] 2
[00000000] 3
\end{urbiscript}

\subsubsection{\samp{,}}

The \samp{,}-connector sends the first statement in background for
concurrent execution, and starts the second statement when possible.
When used in interactive sessions, the value of back-grounded
statements are \emph{not} printed --- the time of their arrival being
unpredictable, such results would clutter the output randomly.  Use
\refObject[s]{Channel} or \refObject[s]{Event} to return results
asynchronously.

\begin{urbiscript}[firstnumber=last]
{
  for (3)
  {
    sleep(1s);
    echo("ping");
  },
  sleep(0.5s);
  for (3)
  {
    sleep(1s);
    echo("pong");
  },
};
[00000316] *** ping
[00000316] *** pong
[00000316] *** ping
[00000316] *** pong
[00000316] *** ping
[00000316] *** pong
\end{urbiscript}

Both \samp{;} and \samp{,} have equal precedence.  They are scoped
too: the execution follow ``waits'' for the end of the jobs
back-grounded with \samp{,} before proceeding.  Compare the two
following executions.

\begin{urbiscript}[firstnumber=last]
{
  sleep(100ms) | echo("1"),
  sleep(400ms) | echo("2"),
  echo("done");
};
[00000316] *** done
[00000316] *** 1
[00000316] *** 2
\end{urbiscript}

\begin{urbiscript}[firstnumber=last]
{
  sleep(100ms) | echo("1"),
  sleep(400ms) | echo("2"),
};
echo("done");
[00000316] *** 1
[00000316] *** 2
[00000316] *** done
\end{urbiscript}


\subsubsection{\samp{|}}
When using the \samp{;} connector, the scheduler is allowed to run
other commands between the first and the second statement.  The
\samp{|} does not yield between both statements.  It is therefore more
efficient, and, in a way, provides some atomicity for concurrent tasks.

\begin{urbiscript}[firstnumber=last]
{
  { echo("11") ; sleep(100ms) ; echo("12") },
  { echo("21") ; sleep(400ms) ; echo("22") },
};
[00000316] *** 11
[00000316] *** 21
[00000316] *** 12
[00000316] *** 22
\end{urbiscript}

%% Cannot use sleep here, as it yields, which makes the point moot.
\begin{urbiscript}[firstnumber=last]
{
  { echo("11") | echo("12") },
  { echo("21") | echo("22") },
};
[00000316] *** 11
[00000316] *** 12
[00000316] *** 21
[00000316] *** 22
\end{urbiscript}

In an interactive session, both statements must be ``known'' before
launching the sequence.  The value of the composed statement is the
value of the second statement.

\subsubsection{\samp{\&}}

The \samp{\&} is very similar to the \samp{,} connector, but for its
precedence.  \urbi expects to process the whole statement before
launching the connected statements.   This is especially handy in
interactive sessions, as a means to fire a set of tasks concurrently.


\subsection{Operators}

\us supports many \dfn{operators}, most of which are inspired from
\Cxx. Their syntax is presented here, and they are sorted and
described with their original semantics --- that is, \lstinline|+| is
an arithmetic operator that sums two numeric values. However, as in
\Cxx, these operators might be use for any other purpose --- that is,
\lstinline|+| can also be used as the concatenation operator on lists
and strings. Their semantics is thus not limited to what is presented
here.

Tables in this section sort operators top-down, by precedence order.
Group of rows (not separated by horizontal lines) describe operators
that have the same precedence. Many operators are syntactic sugar that
bounce on a method. In this case, the equivalent desugared expression
is shown in the ``Equivalence'' column. This can help you determine
what method to override to define an operator for an object (see
\autoref{sec:tut:operators}).

This section defines the syntax, precedence and associativity of the
operators. Their semantics is described in \autoref{sec:stdlib} in the
documentation of the classes that provide them.

% Operator generators
\newcommand{\operatorhead}{Operator & Use & Associativity & Original semantic
  & Equivalence\\}


\newcommand{\operator}[6][ ]{\lstinline@#2@&\lstinline@#3@&#4&#5&\lstinline@#6@#1\\}
\newcommand{\boperator}[3]{\operator{#1}{a #1 b}{#2}{#3}{a.'#1'(b)}}
\newcommand{\poperator}[3]{\operator{#1}{#1a}{#2}{#3}{a.'#1'()}}

\newcommand{\operatordot}    {\operator  {.}    {a.b}              {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatordota}   {\operator  {.}    {a.b(args)}        {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatorsub}    {\operator  {[]}   {a[args]}          {-}     {Subscript}                {a.'[]'(args)}          }
\newcommand{\operatorsubass} {\operator  {[] =} {a[args] = v}      {-}     {Subscript assignment}     {a.'[]='(args, v)}      }
\newcommand{\operatorass}[2][ ]    {\operator[#1]
                                         {=}    {a = b}            {Right} {Assignment}               {updateSlot("a", b)}    }

\newcommand{\operatoriass}[1]{\operator  {#1=}  {a #1= b}          {Right} {In place assignment}      {a = a #1 b}            }
\newcommand{\operatorsiass}  {
    \operatoriass{+}
    \operatoriass{-}
    \operatoriass{*}
    \operatoriass{/}
    \operatoriass{\%}
    \operatoriass{\^}
%    \operatoriass{\~}
}
\newcommand{\operatorinc}    {\operator  {++}   {a++}              {-}     {Incrementation}           {(a = a + 1) - 1}       }
\newcommand{\operatordec}    {\operator  {--}   {a--}              {-}     {Incrementation}           {(a = a - 1) + 1}       }

\newcommand{\operatoruplus}  {\poperator {+}    {-}                {Identity}               }
\newcommand{\operatorumin}   {\poperator {-}    {-}                {Opposite}               }
\newcommand{\operatorexp}    {\boperator {**}   {Right}            {Exponentiation}         }
\newcommand{\operatormult}   {\boperator {*}    {Left}             {Multiplication}         }
\newcommand{\operatordiv}    {\boperator {/}    {Left}             {Division}               }
\newcommand{\operatormod}    {\boperator {\%}   {Left}             {Modulo}                 }
\newcommand{\operatorplus}   {\boperator {+}    {Left}             {Sum}                    }
\newcommand{\operatorminus}  {\boperator {-}    {Left}             {Difference}             }
\newcommand{\operatorlshift} {\boperator {<<}   {Left}             {Left bit shift}         }
\newcommand{\operatorrshift} {\boperator {>>}   {Left}             {Right bit shift}        }
\newcommand{\operatoreq}     {\boperator {==}   {Non Associative}  {Equality}               }
\newcommand{\operatorneq}    {\boperator {!=}   {Non Associative}  {Inequality}             }
\newcommand{\operatorpeq}    {\boperator {===}  {Non Associative}  {Physical equality}      }
\newcommand{\operatorpneq}   {\boperator {!==}  {Non Associative}  {Physical Inequality}    }
\newcommand{\operatoraeq}    {\boperator {\~=}  {Non Associative}  {Relative Approximate equality} }
\newcommand{\operatoreqaeq}  {\boperator {=~=}  {Non Associative}  {Absolute Approximate equality} }
\newcommand{\operatorinf}    {\boperator {<}    {Non Associative}  {Less than}              }
\newcommand{\operatorinfeq}  {\boperator {<=}   {Non Associative}  {Less than or equal to}  }
\newcommand{\operatorsup}    {\boperator {>}    {Non Associative}  {Greater than}           }
\newcommand{\operatorsupeq}  {\boperator {>=}   {Non Associative}  {Greater than or equal to}}
\newcommand{\operatorbxor}   {\boperator {^}    {Left}             {Bitwise exclusive or}   }
\newcommand{\operatorneg}    {\poperator {!}    {Left}             {Logical negation}       }
\newcommand{\operatorand}    {\boperator {\&\&} {Left}             {Logical and}            }
\newcommand{\operatoror}     {\boperator {||}   {Left}             {Logical or}             }

\subsubsection{Arithmetic operators}

\us supports classic \dfn{arithmetic operators}, with the classic
semantics on numeric values. See \autoref{tab:arith} and the listing
below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
  \end{tabular}
  \caption{Arithmetic operators}
  \label{tab:arith}
\end{table}

\begin{urbiassert}[firstnumber=last]
   1 + 1 ==    2;
   1 - 2 ==   -1;
   2 * 3 ==    6;
  10 / 2 ==    5;
 2 ** 10 == 1024;
-(1 + 2) ==   -3;
\end{urbiassert}

\subsubsection{Assignment operators}

\dfn{Assignment} in \us can be performed with the \lstinline|=|
operator.  Shorthands such as \lstinline|+=| exist; they are not
redefinable since they are equivalent to a regular assignment combined
with another operator. See \autoref{tab:assignment} and the listing
below.


\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorass[\footnotemark]{}
    \operatorsiass
    \hline
  \end{tabular}
  \caption{Assignment operators}
  \label{tab:assignment}
\end{table}
\footnotetext{For object fields only. Assignment to local variables
  cannot be redefined. }

% FIXME: this in place modulo example was removed
%         because %= is a lame Urbi operator.
%  x %= 3;


\begin{urbiscript}[firstnumber=last]
var y = 0;
[00000000] 0
y = 10;
[00000000] 10
y += 10;
[00000000] 20
y /= 5;
[00000000] 4
y++;
[00000000] 4
y;
[00000000] 5
\end{urbiscript}

\subsubsection{Bitwise operators}

\us features \dfn{bitwise operators}.  They are also used for other
purpose than bit-related operations. See \autoref{tab:bitwise} and the
listing below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatorbxor
    \hline
  \end{tabular}
  \caption{Bitwise operators}
  \label{tab:bitwise}
\end{table}

\begin{urbiassert}[firstnumber=last]
4 << 2 == 16;
4 >> 2 ==  1;
\end{urbiassert}

\subsubsection{Logical operators}

\us supports the usual \dfn{Boolean operators}. See the table and the
listing below. The operators \lstinline|&&| and \lstinline-||- are
short-circuiting: their right-hand side is evaluated only if needed.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
  \end{tabular}
  \caption{Boolean operators}
  \label{tab:boolean}
\end{table}

\begin{urbiassert}[firstnumber=last]
true && true;
true || false;
!true == false;
true || (1 / 0);
(false && (1 / 0)) == false;
\end{urbiassert}

\subsubsection{Comparison operators}

\us supports classical \dfn{comparison operators}. See
\autoref{tab:comparison} and the listing below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoraeq
    \operatoreqaeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
  \end{tabular}
  \caption{Comparison operators}
  \label{tab:comparison}
\end{table}

\begin{urbiscript}[firstnumber=last]
assert
{
 ! (0 < 0);
    0 <= 0;
    0 == 0;
   0 !== 0;
};
var z = 0;
[00000000] 0
assert
{
  z === z;
  ! (z !== z);
};
\end{urbiscript}

\subsubsection{Miscellaneous operators}

These operators do not fit the previous categories. See the table and
the listing below. Note that the \dfn[operator!subscript]{subscript}
(square bracket) operator is \dfn{variadic}: it takes any number of
arguments that will be passed to the \lstinline|'[]'| method of the
targeted object.

\begin{table}[\floatposh]
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
  \end{tabular}
  \caption{Miscellaneous operators}
\end{table}

\begin{urbiscript}[firstnumber=last]
// On lists.
var l = [1, 2, 3, 4, 5];
[00000000] [1, 2, 3, 4, 5]
assert
{
  l[0] == 1;
  l[-1] == 5;
  (l[0] = 10) == 10;
  l == [10, 2, 3, 4, 5];
};

// On strings.
var s = "abcdef";
[00000005] "abcdef"
assert
{
  s[0] == "a";
  s[1,3] == "bc";
  (s[1,3] = "foo") == "foo";
  s == "afoodef";
};
\end{urbiscript}

% \clearpage
\subsubsection{All operators summary}

\autoref{tab:operators-summary} is a summary of all operators, to
highlight the overall precedences. Operators are sorted by decreasing
precedence. Groups of rows represent operators with the same
precedence.

\begin{table}[\floatposh]
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    Operator               & Use                                    & Associativity
    & Original semantic    & Equivalence                            \\
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoreqaeq
    \operatoraeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
    \operatorbxor
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
    \operatorass
    \operatorsiass
    \hline
    \operatorinc
    \operatordec
    \hline
  \end{tabular}
  \caption{Operators summary}
  \label{tab:operators-summary}
\end{table}


\section{Scopes and local variables}

\subsection{Scopes}

\dfn{Scopes} are sequences of statements, enclosed in curly brackets
(\lstinline|{}|). Statements are separated with the four statements
separators (see \autoref{sec:lang:separators}).  A trailing \samp{;}
or \samp{,} is ignored.  A trailing \samp{\&} or \samp{|} behaves as
if \lstinline|& {}| or \lstinline'| {}' was used.  This particular
case is heavily used by \us programmers to discard the value of an
expression:

\begin{urbiscript}[firstnumber=last]
// Return value is 1.  Displayed.
1;
[00000000] 1
// Return value is that of {}, i.e., void.  Nothing displayed.
1 | {};
// Same as "1 | {}", a valueless expression.
1|;
\end{urbiscript}

Scopes are themselves expressions, and can thus be used in composite
expressions, nested, and so forth.

\begin{urbiscript}[firstnumber=last]
// Scopes evaluate to their last expression
{
  1;
  2;
  3; // This last separator is optional.
};
[00000000] 3
// Scopes can be used as expressions
{1; 2; 3} + 1;
[00000000] 4
\end{urbiscript}

\subsection{Local variables}

\dfn{Local variables} are introduced with the \lstinline|var| keyword,
followed by an identifier (see \autoref{sec:us-syn-id}) and an optional
initialization value assignment. If the initial value is omitted, it
defaults to \refObject{void}. Variable
declarations evaluate to
the initialization value. They can later be referred to by their
name. Their value can be changed with the assignment operator; such an
assignment expression returns the new value. The use of local
variables is illustrated below.

\begin{urbiscript}[firstnumber=last]
// This declare variable x with value 42, and evaluates to 42.
var t = 42;
[00000000] 42
// x equals 42
t;
[00000000] 42
// We can assign it a new value
t = 51;
[00000000] 51
t;
[00000000] 51
// Initialization defaults to void
var u;
u.isVoid;
[00000000] true
\end{urbiscript}

The lifespan of local variables is the same as their enclosing scope. They
are thus only accessible from their scope and its
sub-scopes\footnote{Local variables can actually escape their scope
  with lexical closures, see \autoref{sec:us-fun-closures}.}. Two
variables with the same name cannot be defined in the same scope. A
variable with the same name can be defined in an inner scope, in which
case references refer to the innermost variable, as shown below.

\begin{urbiscript}[firstnumber=last]
{
  var x = "x";
  var y = "outer y";
  {
    var y = "inner y";
    var z = "z";
    // We can access variables of parent scopes.
    echo(x);
    // This refers to the inner y.
    echo(y);
    echo(z);
  };
  // This refers to the outer y.
  echo(y);
  // This would be invalid: z does not exist anymore.
  // echo(z);
  // This would be invalid: x is already declared in this scope.
  // var x;
};
[00000000] *** x
[00000000] *** inner y
[00000000] *** z
[00000000] *** outer y
\end{urbiscript}


\section{Functions}

\subsection{Function Definition}

\dfn{Functions} in \us are first class citizens: a function is a
value, like floats and strings, and can be handled as such.  This is
different from most \C-like languages.  One can create a functional
value thanks to the \lstinline|function| keyword, followed by the list
of formal arguments and a compound statement representing the body of
the function. Formal arguments are a possibly-empty comma-separated
list of identifiers.  Non-empty lists of formal arguments may
optionally end with a trailing comma. The listing below illustrates
this.

\begin{urbiscript}[firstnumber=last]
function () { echo(0) };
[00000000] function () {
[:]  echo(0)
[:]}

function (arg1, arg2) { echo(0) };
[00000000] function (arg1, arg2) {
[:]  echo(0)
[:]}

function (
           arg1, // Ignored argument.
           arg2, // Also ignored.
          )
{
  echo(0)
};
[00000000] function (arg1, arg2) {
[:]  echo(0)
[:]}
\end{urbiscript}

Usually functions are bound to an identifier to be invoked later.
The listing below shows a short-hand to define a named
function.

\begin{urbiscript}[firstnumber=last]
// Functions are often stored in variables to call them later.
var f1 = function () {
  echo("hello")
}|
f1();
[00000000] *** hello

// This form is strictly equivalent, yet simpler.
function f2()
{
  echo("hello")
}|
f2();
[00000000] *** hello
\end{urbiscript}


\subsection{Arguments}

The list of formal arguments defines the number of argument the
function requires. They are accessible by their name from within the
body. If the list of formal arguments is omitted, the number of
effective arguments is not checked, and arguments themselves are not
evaluated. Arguments can then be manipulated with the call message,
explained below.

\begin{urbiscript}[firstnumber=last]
var f = function(a, b) {
  echo(b + a);
}|
f(1, 0);
[00000000] *** 1
// Calling a function with the wrong number of argument is an error.
f(0);
[00000000:error] !!! f: expected 2 arguments, given 1
f(0, 1, 2);
[00000000:error] !!! f: expected 2 arguments, given 3
\end{urbiscript}

Non-empty lists of effective arguments may end with an optional comma.
\begin{urbiscript}[firstnumber=last]
f(
  "bar",
  "foo",
 );
[00000000] *** foobar
\end{urbiscript}


\subsection{Return value}

The \dfn[function!return value]{return value} of the function is the
evaluation of its body --- that is, since the body is a scope, the
last evaluated expression in the scope.  Values can be returned
manually with the \lstinline|return| keyword followed by the value, in
which case the evaluation of the function is stopped. If
\lstinline|return| is used with no value, the function returns
\lstinline|void|.

\begin{urbiscript}[firstnumber=last]
function g1(a, b)
{
  echo(a);
  echo(b);
  a // Return value is a
}|
g1(1, 2);
[00000000] *** 1
[00000000] *** 2
[00000000] 1

function g2(a, b)
{
  echo(a);
  return a; // Stop execution at this point and return a
  echo(b); // This is not executed
}|
g2(1, 2);
[00000000] *** 1
[00000000] 1

function g3()
{
  return; // Stop execution at this point and return void
  echo(0); // This is not executed
}|
g3(); // Returns void, so nothing is printed.
\end{urbiscript}

\subsection{Call messages}
\label{sec:us-fun-callmsg}

Functions can access meta-information about how they were called,
through a \lstinline|CallMessage| object. The \dfn{call message}
associated with a function can be accessed with the \lstinline|call|
keyword. It contains several information such as not-yet evaluated
arguments, the name of the function, the target \ldots

\subsection{Strictness}

\us features two different function calls:
\dfn[function!strict]{strict} function calls, effective arguments are
evaluated before invoking the function, and \dfn[function!lazy]{lazy}
function calls, arguments are passed as-is to the function.  As a
matter of fact, the difference is rather that there are strict
functions and lazy function.

Functions defined with a (possibly empty) list of formal arguments in
parentheses are strict: the effective arguments are first evaluated,
and then their value is given to the called function.

\begin{urbiscript}[firstnumber=last]
function first1(a, b) {
  echo(a); echo(b)
}|
first1({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

A function declared with no formal argument list is lazy.  Use its
call message to manipulate its \emph{unevaluated} arguments.
The listing below gives an example.  More information about
this can be found in the \refObject{CallMessage} class documentation.

\begin{urbiscript}[firstnumber=last]
function first2
{
  echo(call.evalArgAt(0));
  echo(call.evalArgAt(1));
}|
first2({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** 1
[00000000] *** Arg2
[00000000] *** 2
\end{urbiscript}

A lazy function may implement a strict interface by evaluating its
arguments and storing them as local variables, see below.  This is
less efficient than defining a strict function.

\begin{urbiscript}[firstnumber=last]
function first3
{
  var a = call.evalArgAt(0);
  var b = call.evalArgAt(1);
  echo(a); echo(b);
}|
first3({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

\subsection{Lexical closures}
\label{sec:us-fun-closures}

\dfn{Lexical closures} are an additional scoping rule, with which a function
can refer to a local variable located outside the function --- but still
in the current context. \us supports read/write lexical closures,
meaning that the variable is shared between the function and the outer
environment, as shown below.

\begin{urbiscript}[firstnumber=last]
var n = 0|
function cl()
{
  // x refers to a variable outside the function
  n++;
  echo(n);
}|
cl();
[00000000] *** 1
n;
[00000000] 1
n++;
[00000000] 1
cl();
[00000000] *** 3
\end{urbiscript}

The following listing illustrate that local variables can even
escape their declaration scope by lexical closure.

\begin{urbiscript}[firstnumber=last]
function wrapper()
{
  // Normally, x is local to 'wrapper', and is limited to this scope.
  var x = 0;
  at (x > 1)
    echo("ping");
  // Here we make it escape the scope by returning a closure on it.
  return function() { x++ };
} |

var w = wrapper()|
w();
[00000000] 0
w();
[00000000] 1
[00000000] *** ping
\end{urbiscript}

See \autoref{sec:faq:atexp} for more details about the warning.


\section{Objects}

Any value in \us is an object. Objects contain:

\begin{itemize}
\item A list of prototypes, which are also objects.
\item A list of slots, which to a name associate an object.
\end{itemize}

\subsection{Slots}

\subsubsection{Manipulation}

\dfn{Objects} can contain any number of \dfn{slots}, every slot has a
name and a value. Slots are often called ``fields'', ``attributes'' or
``members'' in other object-oriented languages.

The \lstinline|createSlot| function adds a slot to an object with the
void (\autoref{sec:std-void}) value. The \lstinline|updateSlot|
function changes the value of a slot; \lstinline|getSlot| reads
it. The \lstinline|setSlot| method creates a slot with a given
value. Finally, the \lstinline|localSlotNames| method returns the list of
the object slot's name. The listing below shows how to manipulate
slots. More documentation about these methods can be found in
\autorefObject{Object}.

\begin{urbiscript}[firstnumber=last]
var o = Object.new|
o.localSlotNames;
[00000000] []
o.createSlot("test");
o.localSlotNames;
[00000000] ["test"]
o.getSlot("test").asString;
[00000000] "void"
o.updateSlot("test", 42);
[00000000] 42
o.getSlot("test");
[00000000] 42
\end{urbiscript}

\subsubsection{Syntactic Sugar}

There is some syntactic sugar for slot methods:
\begin{itemize}
\item \lstinline|var o.name| is equivalent to
  \lstinline|o.createSlot("name")|.
\item \lstinline|var o.name = value| is equivalent to
  \lstinline|o.setSlot("name", value)|.
\item \lstinline|o.name = value| is equivalent to
  \lstinline|o.updateSlot("name", value)|.
\end{itemize}


\subsection{Prototypes}

\subsubsection{Manipulation}

\us is a prototype-based language, unlike most classical object
oriented language, which are class-based. In prototype-based
languages, objects have no type, only \dfn{prototypes}, from which they
inherit behavior.

\us objects can have several prototypes. The list of prototypes is
given by the \lstinline|protos| method; they can be added or removed
with \lstinline|addProto| and \lstinline|removeProto|.  See
\autorefObject{Object} for more documentation.

\begin{urbiscript}[firstnumber=last]
var ob = Object.new|
ob.protos;
[00000000] [Object]
ob.addProto(Pair);
[00000000] (nil, nil)
ob.protos;
[00000000] [(nil, nil), Object]
ob.removeProto(Object);
[00000000] (nil, nil)
ob.protos;
[00000000] [(nil, nil)]
\end{urbiscript}

\subsubsection{Inheritance}

Objects inherit their prototypes' slots: \lstinline|getSlot| will also
look in an object prototypes' slots. \lstinline|getSlot| performs a
depth-first traversal of the prototypes hierarchy to find slots. That
is, when looking for a slot in an object:

\begin{itemize}
\item \lstinline|getSlot| checks first if the object itself has the
  requested slot. If so, it returns its value.
\item Otherwise, it applies the same research on every prototype, in
  the order of the prototype list (since addProto inserts in the front
  of the prototype list, the last prototype added has priority). This
  search is recursive: \lstinline|getSlot| will also look in the first
  prototype's prototype, etc before looking in the second
  prototype. If the slot is found in a prototype, it is returned.
\item Finally, if no prototype had the slot, an error is raised.
\end{itemize}

This listing shows how slots are inherited.

\begin{urbiscript}[firstnumber=last]
var a = Object.new|
var b = Object.new|
var c = Object.new|
a.setSlot("x", "slot in a")|
b.setSlot("x", "slot in b")|
// c has no "x" slot
c.getSlot("x");
[00000000:error] !!! lookup failed: x
// c can inherit the "x" slot from a.
c.addProto(a)|
c.getSlot("x");
[00000000] "slot in a"
// b is prepended to the prototype list, and has thus priority
c.addProto(b)|
c.getSlot("x");
[00000000] "slot in b"
// a local slot in c has priority over prototypes
c.setSlot("x", "slot in c")|
c.getSlot("x");
[00000000] "slot in c"
\end{urbiscript}

\subsubsection{Copy on write}

The \lstinline|updateSlot| method has a particular behavior with
respect to prototypes. Although performing an \lstinline|updateSlot|
on a non existent slot is an error, it is valid if the slot is
inherited from a prototype. In this case, the slot is however not
updated in the prototype, but rather created in the object itself,
with the new value. This process is called \dfn{copy on write}; thanks
to it, prototypes are not altered when the slot is overridden in a
child object.

\begin{urbiscript}[firstnumber=last]
var p = Object.new|
var p.slot = 0|
var d = Object.new|
d.addProto(p)|
d.slot;
[00000000] 0
d.slot = 1;
[00000000] 1
// p's slot was not altered
p.slot;
[00000000] 0
// It was copied in d
d.slot;
[00000000] 1
\end{urbiscript}

\subsection{Sending messages}

A \dfn{message} in \us consists in a message name and arguments. One can
send a message to an object with the dot (\lstinline|.|) operator,
followed by the message name (which can be any valid identifier) and
the arguments, as shown below. When there are no
arguments, the parentheses can be omitted. As you might see,
sending messages is very similar to calling methods in classical
languages.

\begin{urbiunchecked}
// Send the message msg to object obj, with arguments arg1 and arg2.
obj.msg(arg1, arg2);
// Send the message msg to object obj, with no arguments.
obj.msg();
// This is strictly equivalent.
obj.msg;
\end{urbiunchecked}

When a message \var{msg} is sent to object \lstinline|obj|:

\begin{itemize}
\item The \var{msg} slot of \lstinline|obj| is retrieved (i.e.,
  \lstinline|obj.getSlot("\var{msg}")|). If the slot is not found, the
  classic lookup error is raised.
\item If the object is a \dfn{routine} (either a primitive, written in
  \Cxx for instance, or a function implemented in \us), it is invoked
  with the message arguments, and the returned value is the result. As
  a consequence, the number of arguments in the message sending must
  match the one required by the routine.
\item Otherwise (the object is not a routine), this object is the
  result of the message sending. There must be no argument.
\end{itemize}

Such message sending is illustrated below.

\begin{urbiscript}[firstnumber=last]
var obj = Object.new|
var obj.a = 42|
var obj.b = function (x) { x + 1 }|
obj.a;
[00000000] 42
obj.a();
[00000000] 42
obj.a(50);
[00000000:error] !!! a: expected 0 argument, given 1
obj.b;
[00000000:error] !!! b: expected 1 argument, given 0
obj.b();
[00000000:error] !!! b: expected 1 argument, given 0
obj.b(50);
[00000000] 51
\end{urbiscript}

\section{Imperative flow control}

\subsection{break}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|break| makes the execution jump after the loop.

\begin{urbiscript}[firstnumber=last]
var i = 5|
for (; true; echo(i))
{
  if (i > 8)
    break;
  i++;
};
[00000000] *** 6
[00000000] *** 7
[00000000] *** 8
[00000000] *** 9
\end{urbiscript}

\subsection{continue}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|continue| short-circuits the rest of the loop-body, and
runs the next iteration (if there remains one).

\begin{urbiscript}[firstnumber=last]
for (var i = 0; i < 8; i++)
{
  if (i % 2 != 0)
    continue;
  echo(i);
};
[00000000] *** 0
[00000000] *** 2
[00000000] *** 4
[00000000] *** 6
\end{urbiscript}

\subsection{do}

The \lstinline|do| construct changes the target (\lstinline|this|)
when evaluating an expression.  It is a convenient means to avoid
repeating the same target several times.

\begin{urbiunchecked}
do (\var{target})
{
  \var{body}
};
\end{urbiunchecked}

It evaluates \var{body}, with \lstinline|this| being \var{target}, as
shown below.  The whole construct evaluates to the value
of \var{body}.

\begin{urbiscript}[firstnumber=last]
do (1024)
{
  assert(this == 1024);
  assert(sqrt == 32);
  setSlot("y", 23);
}.y;
[00000000] 23
\end{urbiscript}


\subsection{if}
\label{sec:lang:if}
As in most programming languages, conditionals are expressed with
\lstinline|if|.

\begin{urbiunchecked}
if (\var{condition}) \var{then-clause}
if (\var{condition}) \var{then-clause} else \var{else-clause}
\end{urbiunchecked}

First \var{condition} is evaluated; if it evaluates to a value which
is true (\autoref{sec:truth}), evaluate \var{then-clause}, otherwise,
if applicable, evaluate \var{else-clause}.

\begin{urbiscript}[firstnumber=last]
if (true) assert(true) else assert(false);
if (false) assert(false) else assert(true);
if (true) assert(true);
\end{urbiscript}

Beware that \emph{there must not be a terminator after the
  \var{then-clause}}:

\begin{urbiscript}[firstnumber=last]
if (true)
  assert(true);
else
  assert(false);
[00000002:error] !!! syntax error, unexpected else
\end{urbiscript}

Contrary to \C/\Cxx, it has value: it also implements the
\lstinline|\var{condition} ? \var{then-clause} : \var{else-clause}|
construct.  Unfortunately, due to syntactic constraints inherited from
\C, it is a \emph{statement}: it cannot be used directly as an
expression.  But as everywhere else in \us, to use a statement where
an expression is expected, use braces:

\begin{urbiscript}[firstnumber=last]
assert(1 + if (true) 3 else 4 == 4);
[00000003:error] !!! syntax error, unexpected if
assert(1 + { if (true) 3 else 4 } == 4);
\end{urbiscript}

The \var{condition} can be any statement list.  Variables which it
declares are visible in both the \var{then-clause} and the
\var{else-clause}, but do not escape the \lstinline|if| construct.

\begin{urbiscript}[firstnumber=last]
assert({if (false) 10 else 20} == 20);
assert({if (true)  10 else 20} == 10);

assert({if (true) 10         } == 10);

assert({if (var x = 10) x + 2 else x - 2} == 12);
assert({if (var x = 0)  x + 2 else x - 2} == -2);

if (var xx = 123) xx | xx;
[00000005:error] !!! lookup failed: xx
\end{urbiscript}

\subsection{for}
\label{sec:lang:for}
\lstinline|for| comes in several flavors.

\subsubsection{C-like for}

\us support the classical \C-like \lstinline|for| construct.

\begin{urbiunchecked}
for (\var{initialization}; \var{condition}; \var{increment})
  \var{body}
\end{urbiunchecked}

It has the exact same behavior as \C's \lstinline|for|:

\begin{enumerate}
\item The \var{initialization} is evaluated.
\item \var{condition} is evaluated. If the result is false, executions
  jump after \lstinline|for|.
\item \var{body} is evaluated. If \lstinline|continue| is encountered,
  execution jumps to point 4. If \lstinline|break| is encountered,
  executions jumps after the \lstinline|for|.
\item The \var{increment} is evaluated.
\item Execution jumps to point 2.
\item The loop evaluates to \lstinline|void|.
\end{enumerate}

\subsubsection{Range-for}
\label{sec:lang:for:each}

\us supports iteration over a collection with another form of the
\lstinline|for| loop.

\begin{urbiunchecked}
for (var \var{name} : \var{collection})
   \var{body};
\end{urbiunchecked}

It evaluates \var{body} for each element in \var{collection}. The loop
evaluates to \lstinline|void|.  Inside \var{body}, the current element
is accessible via the \var{name} local variable. The listing below
illustrates this.

\begin{urbiscript}[firstnumber=last]
for (var x : [0, 1, 2, 3, 4])
  echo(x.sqr);
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 9
[00000000] *** 16
\end{urbiscript}

This form of \lstinline|for| simply sends the \lstinline|each| message
to \var{collection} with one argument: the function that takes the
current element and performs \lstinline|action| over it. Thus, you can
make any object acceptable in a \lstinline|for| by defining an
adequate \lstinline|each| method.

\begin{urbiscript}[firstnumber=last]
var Hobbits = Object.new|
function Hobbits.each (action)
{
  action("Frodo");
  action("Merry");
  action("Pippin");
  action("Sam");
}|
for (var name in Hobbits)
  echo("%s is a hobbit." % [name]);
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
// This for statement is equivalent to:
Hobbits.each(function (name) { echo("%s is a hobbit." % [name]) });
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
\end{urbiscript}

\subsubsection{for $n$-times}
\label{sec:lang:for:n}

\us provides some support for simple replication of computations: it
allow to repeat a loop body $n$-times.  With the exception that the
loop index is not available within the body, \lstinline|for (n)| is
equivalent to \lstinline|for (var i: n)|.  It supports the same
flavors: \lstinline|for;|, \lstinline{for|}, and \lstinline|for&|. The
loop evaluates to \lstinline|void|.

\begin{urbiassert}[firstnumber=last]
{ var res = []; for (3) { res << 1; res << 2 } ; res }
        == [1, 2, 1, 2, 1, 2];

{ var res = []; for|(3) { res << 1; res << 2 } ; res }
        == [1, 2, 1, 2, 1, 2];

{ var res = []; for&(3) { res << 1; res << 2 } ; res }
        == [1, 1, 1, 2, 2, 2];
\end{urbiassert}

Note that since these \lstinline|for| loops are merely anonymous
foreach-style loops, the argument needs not being an integer, any
iterable value can be used.

\begin{urbiassert}[firstnumber=last]
3 == { var r = 0; for ([1, 2, 3]) r += 1; r};
3 == { var r = 0; for ("123")     r += 1; r};
\end{urbiassert}


\subsection{if}

\us supports the usual \lstinline|if| constructs.

\begin{urbiunchecked}
if (\var{condition})
  \var{action};

if (\var{condition})
  \var{action}
else
  \var{otherwise};
\end{urbiunchecked}

If the \var{condition} evaluation is true, \var{action} is
evaluated. Otherwise, in the latter version, \var{otherwise} is
executed.  Contrary to \C/\Cxx, there \emph{must not} be a semicolon
after the \var{action}; it would end the
\lstinline|if|/\lstinline|else| construct prematurely.

\subsection{loop}

Endless loops can be created with \lstinline|loop|, which is
equivalent to \lstinline|while (true)|.  The loop evaluates to
\lstinline|void|.  Both sequential flavors, \lstinline|loop;| and
\lstinline'loop;', are supported.  The default flavor is
\lstinline|loop;|.

\begin{urbiassert}[firstnumber=last]
{
  var n = 10|;
  var res = []|;
  loop;
  {
    n--;
    res << n;
    if (n == 0)
      break
  };
  res
}
==
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
\end{urbiassert}

\begin{urbiassert}[firstnumber=last]
{
  var n = 10|;
  var res = []|;
  loop|
  {
    n--;
    res << n;
    if (n == 0)
      break
  };
  res
}
==
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
\end{urbiassert}

\subsection{switch}

The \lstinline|switch| statement in \us is similar to \C's one.

\begin{urbiunchecked}
switch (\var{value})
{
  case \var{value_one}:
    \var{action_one};
  case \var{value_two}:
    \var{action_two};
//case ...:
//  ...
  default:
    \var{default_action};
};
\end{urbiunchecked}

It might contain an arbitrary number of cases, and optionally a
default case. The \var{value} is evaluated first, and then the
result is compared sequentially with the evaluation of all cases
values, with the \lstinline|==| operator, until one comparison is
true. If such a match is found, the corresponding action is executed,
and execution jumps after the \lstinline|switch|. Otherwise, the
default case --- if any --- is executed, and execution jumps after the
switch. The switch itself evaluates to case that was evaluated, or to
void if no match was found and there's no default case. The listing below
illustrates \lstinline|switch| usage.

Unlike \C, there are no \lstinline|break| to end \lstinline|case|
clauses: execution will never span over several cases.  Since the
comparisons are performed with the generic \lstinline|==| operator,
\lstinline|switch| can be performed on any comparable data type.

\begin{urbiscript}[firstnumber=last]
function sw(v)
{
  switch (v)
  {
    case "":
      echo("Empty string");
    case "foo":
      "bar";
    default:
      v[0];
  }
}|;
sw("");
[00000000] *** Empty string
sw("foo");
[00000000] "bar"
sw("foobar");
[00000000] "f"
\end{urbiscript}
% $ Pacify emacs math mode.

\subsection{while}

The \lstinline|while| loop is similar to \C's one.

\begin{urbiunchecked}
while (\var{condition})
  \var{body};
\end{urbiunchecked}

If \var{condition} evaluation, is true, \var{body} is evaluated and
execution jumps before the \lstinline|while|, otherwise execution
jumps after the \lstinline|while|.

\begin{urbiscript}[firstnumber=last]
var j = 3|
while (0 < j)
{
  echo(j);
  j--;
};
[00000000] *** 3
[00000000] *** 2
[00000000] *** 1
\end{urbiscript}

The default flavor for \lstinline|while| is \lstinline|while;|.

\subsubsection{while;}

The semantics of

\begin{urbiunchecked}
while; (\var{condition})
  \var{body};
\end{urbiunchecked}

\noindent
is the same as

\begin{urbiunchecked}
\var{condition} | \var{body} ; \var{condition} | \var{body} ; ...
\end{urbiunchecked}

\noindent
as long as \var{cond} evaluates to true, or until \lstinline|break| is
invoked.  If \lstinline|continue| is evaluated, the rest of the body
is skipped, and the next iteration is started.

\begin{urbiscript}[firstnumber=last]
{
  var i = 4|
  while (true)
  {
    i -= 1;
    echo ("in: " + i);
    if (i == 1)
      break
    else if (i == 2)
      continue;
    echo ("out: " + i);
  };
};
[00000000] *** in: 3
[00000000] *** out: 3
[00000000] *** in: 2
[00000000] *** in: 1
\end{urbiscript}


\subsubsection{while|}

The semantics of

\begin{urbiunchecked}
while| (\var{condition})
  \var{body};
\end{urbiunchecked}

\noindent
is the same as

\begin{urbiunchecked}
\var{condition} | \var{body} | \var{condition} | \var{body} | ...
\end{urbiunchecked}

The execution is can be controlled by \lstinline|break| and
\lstinline|continue|.

\begin{urbiscript}[firstnumber=last]
{
  var i = 4|
  while| (true)
  {
    i -= 1;
    echo ("in: " + i);
    if (i == 1)
      break
    else if (i == 2)
      continue;
    echo ("out: " + i);
  };
};
[00000000] *** in: 3
[00000000] *** out: 3
[00000000] *** in: 2
[00000000] *** in: 1
\end{urbiscript}


\section{Exceptions}
\label{sec:lang:except}
\subsection{Throwing exceptions}

Use the \lstinline|throw| keyword to \dfn[exception!throwing]{throw
  exceptions}, as shown below. Thrown exceptions will
break the execution upward until they are caught, or until they reach
the top-level --- as in \Cxx.  Contrary to \Cxx, exceptions reaching
the top-level are printed, and won't abort the kernel --- other and new
connections will continue to execute normally.

\begin{urbiscript}[firstnumber=last]
throw 42;
[00000000:error] !!! 42
function inner() { throw "exn" } |
function outer() { inner() }|
// Exceptions propagate to parent call up to the top-level
outer();
[00000000:error] !!! exn
[00000000:error] !!!    called from: 3.20-26: inner
[00000000:error] !!!    called from: 4.1-7: outer
\end{urbiscript}

\subsection{Catching exceptions}

Exceptions are \dfn[exception!catching]{caught} with the
\lstinline|try|/\lstinline|catch| construct. It consists of a first
block (the \dfn{try-block}), from which we want to catch exceptions,
and one or more catch clauses to stop the exception
(\dfn{catch-blocks}). Each catch clause defines a pattern against
which the thrown exception is matched. If no pattern is specified, the
catch clause matches systematically (equivalent to
\lstinline|catch (...)| in \Cxx).

Exceptions thrown from the \texttt{try} block are matched sequentially
against all catch clauses. The first matching clause is executed, and
control jumps after the whole try/catch block. If no catch clause
matches, the exceptions isn't stopped and continues
upward.

\begin{urbiscript}[firstnumber=last]
function test(e)
{
  try
  { throw e;  }
  catch (0)
  { echo("zero") }
  catch ([var x, var y])
  { echo(x + y) }
} | {};
test(0);
[00002126] *** zero
test([22, 20]);
[00002131] *** 42
test(51);
[00002143:error] !!! 51
[00002143:error] !!!    called from: 12.1-8: test
\end{urbiscript}

\subsection{Inspecting exceptions}

An \refObject{Exception} is a regular object, on which introspection
can be performed.

\begin{urbiscript}[firstnumber=last]
try
{
  Math.cos(3,1415);
}
catch (var e)
{
  echo ("Exception type: %s" % e.'$type');
  if (e.isA(Exception.Arity))
  {
    echo("Routine: %s" % e.routine);
    echo("Number of effective arguments: %s" % e.effective);
  };
};
[00000132] *** Exception type: Arity
[00000133] *** Routine: cos
[00000134] *** Number of effective arguments: 2
\end{urbiscript}

%% FIXME: \subsection{Exceptions and parallelism}

\section{Assertions}
\label{sec:assertions}

\dfn[assertion]{Assertions} allow to embed consistency checks in the
code.  They are particularly useful when developing a program since
they allow early catching of errors.  Yet, they can be costly in
production mode: the run-time cost of verifying every single assertion
might be prohibitive.  Therefore, as in \C-like languages, assertions
are disabled when \lstinline|System.ndebug| is true, see \refObject{System}.

\us supports assertions in two different ways: with a function-like
syntax, which is adequate for single claims, and a block-like syntax,
to group claims together.

The \lstinline|assert(\var{expression})| bounces to the
\lstinline|System.'assert'| function, see \refObject{System}.

\begin{urbiscript}[firstnumber=last]
assert(true);
assert(42);
assert(1 == 1 + 1);
[00000002:error] !!! failed assertion: 1 == 1 . '+'(1) (1 != 2)
\end{urbiscript}

Groups of assertions are more readable when used with the
\lstinline|assert{\var{exp1}; \var{exp2}; ...}| construct.  The
(possibly empty) list of claims may be ended with a semicolon.

\begin{urbiscript}[firstnumber=last]
assert
{
  true;
  42;
  1 == 1 + 1;
};
[00000002:error] !!! failed assertion: 1 . '=='(1 . '+'(1))
\end{urbiscript}

For sake of readability and compactness, this documentation shows
assertion blocks as follows.

\begin{urbiassert}[firstnumber=last]
true;
42;
1 == 1 + 1;
[00000002:error] !!! failed assertion: 1 . '=='(1 . '+'(1))
\end{urbiassert}


\section{Parallel and event-based flow control}

\subsection{\lstinline'at'}
\label{sec:lang:at}
Using the \lstindex{at} construct, one can arm code that will be
triggered each time some condition is true.

The \lstinline'at' construct is as follows:

\begin{urbiunchecked}
at (\var{condition})
  \var{statement1}
onleave
  \var{statement2}
\end{urbiunchecked}

The \var{condition} can be of two different kinds:
\lstinline|\var{e}?(\var{args})| to catch when events are sent, or
\lstinline|\var{exp}| to catch each time a Boolean \var{exp} becomes
true.

The \lstinline|onleave \var{statement2}| part is optional.  Note that,
as is the case for the \lstinline|if| statement, there must not be a
semicolon after \var{statement1} if there is an \lstinline|onleave|
clause.

\subsubsection{\lstinline'at' on Events}
%% FIXME: More details are needed.  Don't bounce elsewhere.
See \autoref{sec:tut:events} for an example of using \lstinline|at|
statements to watch events.

\subsubsection{\lstinline'at' on Boolean Expressions}

The \lstinline|at| construct can be used to watch a given Boolean
expression.

\begin{urbiscript}
var x = 0 |
var x_is_two = false |
at (x == 2)
  x_is_two = true
onleave
  x_is_two = false;

x = 3|;  assert(!x_is_two);
x = 2|;  assert( x_is_two);
x = 2|;  assert( x_is_two);
x = 3|;  assert(!x_is_two);
\end{urbiscript}

It can also wait for some condition to hold long enough:
\lstinline|\var{exp} ~ \var{duration}|, as a condition, denotes the
fact that \var{exp} was true for \var{duration} seconds.

\begin{urbiscript}
var x = 0 |
var x_was_two_for_two_seconds = false |
at (x == 2 ~ 2s)
  x_was_two_for_two_seconds = true
onleave
  x_was_two_for_two_seconds = false;

x = 2       | assert(!x_was_two_for_two_seconds);
sleep(1.5s) | assert(!x_was_two_for_two_seconds);
sleep(1.5s) | assert( x_was_two_for_two_seconds);

x = 3|; sleep(0.1s);  assert(!x_was_two_for_two_seconds);

x = 2       | assert(!x_was_two_for_two_seconds);
sleep(1.5s) | assert(!x_was_two_for_two_seconds);
x = 3|; x = 2|; sleep (1s) | assert(!x_was_two_for_two_seconds);
\end{urbiscript}


\subsubsection{Scoping at \lstinline'at'}

\lstinline'at' statements are not scoped.  But, using a
\refObject{Tag} object, one can control them.  In the following
example, \lstinline|scopeTag| is used to label the \lstinline|at|
statement.  When the function ends, the \lstinline|at| is no longer
active.

\begin{urbiscript}
var x = 0 |
var x_is_two = false |;

{
  scopeTag:
    at (x == 2)
      x_is_two = true
    onleave
      x_is_two = false;
  sleep(2s);
},
x = 2 |; assert(x_is_two);
x = 1 |; assert(!x_is_two);
sleep(3s);
x = 2 | assert(!x_is_two);
\end{urbiscript}

\subsection{\lstinline'every'}

The \lstindex{every} statement enables to execute a block of code
repeatedly, with the given period.

\begin{urbiscript}[firstnumber=last]
// Print out a message every second.
timeout (2.1s)
  every (1s)
    echo("Are you still there?");
[00000000] *** Are you still there?
[00001000] *** Are you still there?
[00002000] *** Are you still there?
\end{urbiscript}

It exists in several flavors.

\subsubsection{\lstinline'every|'}
The whole \lstinline'every|' statement itself remains in foreground:
statements attached after it with \lstinline';' or \lstinline'|' will
not be reached unless you \lstinline'break' out of it.  You may use
\lstinline|continue| to finish one iteration.  In that case, the
following iteration is not immediately started, it will be launched as
expected, at the given period.

% We used to use 100ms instead of 1s, but severely loaded machines
% (the Mac Mini) fail way too often.
\begin{urbiscript}[firstnumber=last]
{
  var count = 4;
  var start = time;
  echo("before");
  every| (1s)
  {
    count -= 1;
    echo("begin: %s @ %1.0fs" % [count, time - start]);
    if (count == 2)
      continue;
    if (count == 0)
      break;
    echo("end:   " + count);
  };
  echo("after");
};
[00000597] *** before
[00000598] *** begin: 3 @ 0s
[00000599] *** end:   3
[00000698] *** begin: 2 @ 1s
[00000798] *** begin: 1 @ 2s
[00000799] *** end:   1
[00000898] *** begin: 0 @ 3s
[00000899] *** after
\end{urbiscript}

The \lstindex{every|} flavor does not let iterations overlap. If an
iteration takes too long, the following iterations are delayed. That
is, the next iterations will start immediately after the end of the
current one, and next iterations will occur normally from this point.

\begin{urbiscript}[firstnumber=last]
{
  var too_long = true|;

  var count = 5;
  // Every other iteration exceeds the period, and will delay the
  // following one.
  every| (1s)
  {
    if (! count -=1)
      break;

    if (too_long)
    {
      too_long = false;
      echo("Long in");
      sleep(1.5s);
      echo("Long out");
    }
    else
    {
      too_long = true;
      echo("Short");
    };
  };
};
[00000000] *** Long in
[00001500] *** Long out
[00001500] *** Short
[00002500] *** Long in
[00004000] *** Long out
[00004000] *** Short
\end{urbiscript}

The flow-control constructs \lstinline|break| and \lstinline|continue|
are supported.

\begin{urbiscript}[firstnumber=last]
{
  var count = 0;
  every| (250ms)
  {
    count += 1;
    if (count == 2)
      continue;
    if (count == 4)
      break;
    echo(count);
  }
};
/*(*/sleep(2s);/*)*/
[00000000] *** 1
[00001500] *** 3
\end{urbiscript}


\subsubsection{\lstinline'every,'}
The default flavor, \lstinline|every,| launches the execution of the
block in the background every given period. Iterations may overlap.

% Cut the previous every, no [firstnumber=last]
\begin{urbiscript}
// If an iteration is longer than the given period, it will overlap
// with the next one.
timeout (2.8s)
  every (1s)
  {
    echo("In");
    sleep(1.5s);
    echo("Out");
  };
[00000000] *** In
[00001000] *** In
[00001500] *** Out
[00002000] *** In
[00002500] *** Out
\end{urbiscript}

\subsection{for}

The \lstinline|for| loops come into several flavors, depending one the
actual kind of \lstinline|for| loop.

\subsubsection{C-for,}
\begin{note}
  This feature is experimental.  It might be changed, or even removed.
  Feedback on its use would be appreciated.
\end{note}

\lstinline|for,| is syntactic sugar for \lstinline|while,|, see
\autoref{sec:lang:while:comma}.

\begin{urbiscript}[firstnumber=last]
for, (var i = 3; 0 < i; i -= 1)
{
  var j = i |
  echo ("in: i = %s, j = %s" % [i, j]);
  sleep(j/10);
  echo ("out: i = %s, j = %s" % [i, j]);
};
echo ("done");
[00000144] *** in: i = 3, j = 3
[00000145] *** in: i = 2, j = 2
[00000145] *** in: i = 1, j = 1
[00000246] *** out: i = 0, j = 1
[00000346] *** out: i = 0, j = 2
[00000445] *** out: i = 0, j = 3
[00000446] *** done
\end{urbiscript}

\begin{urbiscript}[firstnumber=last]
for, (var i = 9; 0 < i; i -= 1)
{
  var j = i;
  if (j % 2)
    continue
  else if (j == 4)
    break
  else
    echo("%s: done" % j)
};
echo("done");
[00000146] *** 8: done
[00000148] *** 6: done
[00000150] *** done
\end{urbiscript}


\subsubsection{range-for\& (:)}
\label{sec:lang:for:each:and}

One can iterate concurrently over the members of a collection.

\begin{urbiscript}[firstnumber=last]
for& (var i: [0, 1, 2])
{
  echo (i * i);
  echo (i * i);
};
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
\end{urbiscript}

If an iteration executes \lstinline|continue|, it is stopped; the
other iterations are not affected.

\begin{urbiscript}[firstnumber=last]
for& (var i: [0, 1, 2])
{
  var j = i;
  if (j == 1)
    continue;
  echo (j);
};
[00020653] *** 0
[00021054] *** 2
\end{urbiscript}

%%% FIXME:
%%% If an iteration executes \lstinline|break|, all the iterations
%%% including this one, are stopped.
%%%
%%% \begin{urbiscript}[firstnumber=last]
%%% for& (var i: [0, 1, 2])
%%% {
%%%   var j = i;
%%%   sleep(1s);
%%%   if (j == 1)
%%%    { echo ("break");
%%%     break;};
%%%   echo (j);
%%% };
%%% \end{urbiscript}

\subsubsection{for\& (n)}

Since \lstinline|for& (\var{n}) \var{body}| is processed as
\lstinline|for& (var \var{tmp}: \var{n}) \var{body}|, which \var{tmp}
a hidden variable, see \autoref{sec:lang:for:each:and} for details.


\subsection{loop,}
\begin{note}
  This feature is experimental.  It might be changed, or even removed.
  Feedback on its use would be appreciated.
\end{note}

This is syntactic sugar for \lstinline|while,(true)|.  In the
following example, care must be taken that concurrent executions don't
modify \lstinline|n| simultaneously.  This would happen had
\lstinline|;| been used instead of \lstinline'|'.

\begin{urbiassert}[firstnumber=last]
{
  var n = 10|;
  var res = []|;
  loop,
  {
    n-- |
    res << n |
    if (n == 0)
      break
  };
  res.sort
}
==
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
\end{urbiassert}

\subsection{\lstinline|waituntil|}
\label{sec:lang:waituntil}

The \lstinline|waituntil| construct is used to hold the execution
until some condition is verified.  Similarly to \lstinline|at|
(\autoref{sec:lang:at}) and the other event-based constructs,
\lstinline|waituntil| may work on events, or on Boolean expressions.

\subsubsection{\lstinline'waituntil' on Events}

When the execution flow enters a \lstinline|waituntil|, the execution
flow is held until the event is fired.  Once caught, the event is
consumed, another \lstinline|waituntil| will require another event
emission.

\begin{urbiscript}[firstnumber=last]
{
  var e = Event.new;
  {
    waituntil (e?);
    echo ("caught e");
  },
  e!;
[00021054] *** caught e
  e!;
};
\end{urbiscript}

In the case of lasting events (see \lstinline|Event.trigger|), the
condition remains verified as long as the event is ``on''.

\begin{urbiscript}[firstnumber=last]
{
  var e = Event.new;
  e.trigger;
  {
    waituntil (e?);
    echo ("caught e");
  };
[00021054] *** caught e
  {
    waituntil (e?);
    echo ("caught e");
  };
[00021054] *** caught e
  {
    waituntil (e?);
    echo ("caught e");
  };
[00021054] *** caught e
};
\end{urbiscript}

The event specification may use pattern-matching to specify the
accepted events.

\begin{urbiscript}[firstnumber=last]
{
  var e = Event.new;
  {
    waituntil (e?(1, var b));
    echo ("caught e(1, %s)" % b);
  },
  e!;
  e!(1);
  e!(2, 2);
  e!(1, 2);
[00021054] *** caught e(1, 2)
  e!(1, 2);
};
\end{urbiscript}

Events sent before do not release the construct.

\begin{urbiscript}[firstnumber=last]
{
  var e = Event.new;
  e!;
  {
    waituntil (e?);
    echo ("caught e");
  },
  e!;
[00021054] *** caught e
};
\end{urbiscript}

\subsubsection{\lstinline'waituntil' on Boolean Expressions}

You may use any expression that evaluates to a truth value as argument
to \lstinline'waituntil'.

\begin{urbiscript}[firstnumber=last]
{
  var foo = Object.new;
  {
    waituntil (foo.hasLocalSlot("bar"));
    echo(foo.getLocalSlot("bar"));
  },
  var foo.bar = 123|;
};
[00021054] *** 123
\end{urbiscript}

\subsection{\lstinline|whenever|}

The \lstinline|whenever| construct really behaves like a never-ending
\lstinline|loop if| construct.  It also works on events and Boolean
expressions, and triggers each time the condition \emph{becomes}
verified.

\begin{urbiunchecked}
whenever (\var{condition})
  \var{statement1}
\end{urbiunchecked}

It supports an optional \lstinline|else| clause, which is run whenever
the condition changes ``from true to false''.

\begin{urbiunchecked}
whenever (\var{condition})
  \var{statement1}
else
  \var{statement2}
\end{urbiunchecked}

The execution of a \lstinline|whenever| clause is ``instantaneous'',
there is no mean to use \samp{,} to put it in background.  It is also
asynchronous with respect to the condition: the emission of an event
is not held until all its watchers have completed their job.

\subsubsection{\lstinline'whenever' on Events}

A \lstinline'whenever' clause can be used to catch events with or
without payloads.

\begin{urbiscript}
var e = Event.new|;
whenever (e?)
  echo("e on")
else
  echo("e off");
e!;
[00021054] *** e on
[00021054] *** e off
e!(1) & e!(2);
[00021054] *** e on
[00021054] *** e off
[00021054] *** e on
[00021054] *** e off
\end{urbiscript}

The payload is available in both bodies.  The pattern-matching and
guard on the payload is available.

\begin{urbiscript}
var e = Event.new|;
whenever (e?("arg", var arg) if arg % 2)
  echo("e (%s) on" % arg)
else
  echo("e (%s) off" % arg);
e!("param", 23);
e!("arg", 52);
e!("arg", 23);
[00000002] *** e (23) on
[00000003] *** e (23) off
e!("arg", 52);
e!("arg", 17);
[00000004] *** e (17) on
[00000005] *** e (17) off
\end{urbiscript}


If the body of the \lstinline|whenever| lasts for a long time, it is
possible that two executions be run concurrently.

\begin{urbiscript}
var e = Event.new|;
whenever (e?(var d))
  {
    echo("e (%s) on begin" % d);
    sleep(d);
    echo("e (%s) on end" % d);
  }
else
  {
    echo("e (%s) off begin" % d);
    sleep(d);
    echo("e (%s) off end" % d);
  };

e!(0.3s) & e!(1s);
sleep(3s);
[00000202] *** e (0.3) on begin
[00000202] *** e (1) on begin
[00000508] *** e (0.3) on end
[00000508] *** e (0.3) off begin
[00000810] *** e (0.3) off end
[00001208] *** e (1) on end
[00001208] *** e (1) off begin
[00002210] *** e (1) off end
\end{urbiscript}

\subsubsection{\lstinline'whenever' on Boolean Expressions}

A \lstinline'whenever' construct will repeatedly evaluate its body as
long as its condition holds.  The number of evaluation of the bodies
is typically non-deterministic, as not only does it depend on how
long the condition holds, but also ``how fast'' the \urbi kernel runs.

\begin{urbiscript}
var x = 0|;
var count = 0|;
var t = Tag.new|;
t:
  whenever (x % 2)
  {
    if (!count)
      echo("x is now odd (%s)" % x);
    count++;
  }
  else
  {
    if (!count)
      echo("x is now even (%s)" % x);
    count++;
  };

t:
  whenever (100 < count)
  {
    count = 0 |
    x++;
  };
waituntil(x == 4);
[00000769] *** x is now even (0)
[00000809] *** x is now odd (1)
[00000846] *** x is now even (2)
[00000886] *** x is now odd (3)
[00000924] *** x is now even (4)
t.stop;
\end{urbiscript}


\subsection{While}
\subsubsection{\lstinline|while,|}
\label{sec:lang:while:comma}

\begin{note}
  This feature is experimental.  It might be changed, or even removed.
  Feedback on its use would be appreciated.
\end{note}

This construct provides a means to run concurrently multiple instances
of statements.  The semantics of

\begin{urbiunchecked}
while, (\var{condition})
  \var{body};
\end{urbiunchecked}

\noindent
is the same as

\begin{urbiunchecked}
\var{condition} | \var{body} , \var{condition} | \var{body} , ...
\end{urbiunchecked}

Attention must be paid to the fact that the (concurrent) iterations
share a common access to the environment, therefore if, for instance,
you want to keep the value of some index variable, use a local
variable inside the loop body:

% Cut the previous every, no [firstnumber=last]
\begin{urbiscript}
{
  var i = 4|
  while, (i)
  {
    var j = i -= 1;
    echo ("in: i = %s, j = %s" % [i, j]);
    sleep(j/10);
    echo ("out: i = %s, j = %s" % [i, j]);
  }|
  echo ("done");
}|
[00000144] *** in: i = 2, j = 3
[00000145] *** in: i = 1, j = 2
[00000145] *** in: i = 0, j = 1
[00000146] *** in: i = 0, j = 0
[00000146] *** out: i = 0, j = 0
[00000246] *** out: i = 0, j = 1
[00000346] *** out: i = 0, j = 2
[00000445] *** out: i = 0, j = 3
[00000446] *** done
\end{urbiscript}

As for the other flavors, \lstinline|continue| skips the current
iteration, and \lstinline|break| ends the loop.  Note that
\lstinline|break| stops all the running iterations.  This semantics is
likely to be changed to ``\lstinline|break| ends the current iteration
and stops the generation of others, but lets the other concurrent
iterations finish'', so do not rely on this feature.

Control flow is passed to the following statement when all the
iterations are done.

\begin{urbiscript}[firstnumber=last]
{
  var i = 10|
  while, (i)
  {
    var j = i -= 1;
    if (j % 2)
      continue
    else if (j == 4)
      break
    else
      echo("%s: done" % j)
  }|
  echo("done");
};
[00000146] *** 8: done
[00000148] *** 6: done
[00000150] *** done
\end{urbiscript}


%% FIXME: \section{Pattern matching}

\section{Trajectories}
\label{sec:lang:traj}

In robotics, \dfn[trajectory]{trajectories} are often used: they are a
means to change the value of a variable (actually, a slot) over time.
This can be done using detached executions, for instance using a
combination of \lstinline|every| and \lstinline|detach|, but \us
provides syntactic sugar to this end.

For instance the following drawing shows how the \lstinline|y|
variable is moved smoothly from its \dfn{initial value}
(\lstinline|0|) to its \dfn{target value} (\lstinline|100|) in 3
seconds (the value given to the \lstinline|smooth| \dfn{attribute}.

\urbitrajectory{smooth}

Trajectories can be frozen and unfrozen, using tags
(\autoref{sec:tut:tags}).  In that case, ``time is suspended'', and
the trajectory resumes as if the trajectory was never interrupted.

\urbitrajectory{smooth-frozen}

When the target value is reached, the trajectory generator is detached
from the variables: changes to the value of the variable no longer
trigger the trajectory generator.

\urbitrajectory{smooth-continued}

See the specifications of \refObject{TrajectoryGenerator} for the list
of supported trajectories.

%%% Local Variables:
%%% mode: latex
%%% coding: utf-8
%%% TeX-master: "urbi-specs"
%%% ispell-personal-dictionary: "../urbi.dict"
%%% End:

