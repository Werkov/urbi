\section{List}

\lstinline|List|s implement potentially empty ordered collections of
elements.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Object}
\end{itemize}

\subsection{Construction}

List can be created with their literal syntax, as shown in
\autoref{sec:us-syn-lit-list}.

%% They can also be created with the \lstinline|new| method of
%% \lstinline|List|, given the initial members (\autoref{lst:new-list}).
%%
%% \begin{urbiscript}[caption=List.new, label=lst:new-list]
%% List.new(nil, "foo", 42);
%% [00000000] [nil, "foo", 42]
%% \end{urbiscript}

\subsection{Methods}

\subsubsection{all}

% FIXME: link to predicate glossary entry
Return whether all the members of the target verify the given
predicate.

\begin{urbiscript}
// Are all elements positive?
[-2, 0, 2, 4].all(function (e) { e > 0 });
[00000000] false
// Are all elements even?
[-2, 0, 2, 4].all(function (e) { e % 2 == 0 });
[00000000] true
\end{urbiscript}

\subsubsection{any}

% FIXME: link to predicate glossary entry
Return whether at least one of the members of the target verify the
given predicate.

\begin{urbiscript}
// Is there any even element?
[-3, 1, -1].all(function (e) { e % 2 == 0 });
[00000000] false
// Is there any positive element?
[-3, 1, -1].any(function (e) { e > 0 });
[00000000] true
\end{urbiscript}

\subsubsection{asList}

Return the target.

\begin{urbiscript}
[0, 1, 2].asList;
[00000000] [0, 1, 2]
\end{urbiscript}

\subsubsection{asString}

Return the target as a string describing the list.

\begin{urbiscript}
[0, 1, 2].asString;
[00000000] "[0, 1, 2]"
\end{urbiscript}

\subsubsection{back}

Return the last element of the target. An error if the target is empty.

\begin{urbiscript}
[0, 1, 2].back;
[00000000] 2
[].back;
[00000000:error] !!! back: cannot be applied onto empty list
\end{urbiscript}

\subsubsection{clear}

Empty the target.

\begin{urbiscript}
var x = [0, 1, 2];
[00000000] [0, 1, 2]
x.clear;
[00000000] []
\end{urbiscript}

\subsubsection{each}

Apply the given functional value on all members sequentially.

\begin{urbiscript}
[0, 1, 2].each(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 0
[00000000] *** 1
[00000000] *** 1
[00000000] *** 4
[00000000] *** 4
\end{urbiscript}

\subsubsection{each\&}

Apply the given functional value on all members simultaneously.

\begin{urbiscript}
[0, 1, 2].'each&'(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
\end{urbiscript}

\subsubsection{empty}

Return whether the target is empty.

\begin{urbiscript}
[].empty;
[00000000] true
[1].empty;
[00000000] false
\end{urbiscript}

\subsubsection{filter}

Return the list of all member of the target that verify the given
predicate.

\begin{urbiscript}
// Keep only odd numbers
[0, 1, 2, 3, 4, 5].filter(function (v) {v % 2 == 1});
[00000000] [1, 3, 5]
\end{urbiscript}

\subsubsection{foldl}

\fixme{This is too damn hard to explain, yet so simple.}

\begin{urbiscript}

\end{urbiscript}

\subsubsection{front}
\label{sec:std-list-front}

Return the first element of the target. An error if the target is
empty.

\begin{urbiscript}
[0, 1, 2].front;
[00000000] 0
[].front;
[00000000:error] !!! front: cannot be applied onto empty list
\end{urbiscript}

\subsubsection{has}

Return whether one of the member of the target equals the argument.

\begin{urbiscript}
[0, 1, 2].has(1);
[00000000] true
[0, 1, 2].has(5);
[00000000] false
\end{urbiscript}

\subsubsection{hasSame}

Return whether one of the member of the target is physically equal to
the argument.

\begin{urbiscript}
var x = 1;
[00000000:hide] 1
[0, x, 2].hasSame(1);
[00000000] false
[0, x, 2].hasSame(x);
[00000000] true
\end{urbiscript}

\subsubsection{head}

Synonym for \lstinline|front| (\autoref{sec:std-list-front}).

\subsubsection{join}

Concatenate all members of the target to form a string, separating
them with the given separator.

\begin{urbiscript}
["b", "ob", "b"].join("a");
[00000000] "baobab"
\end{urbiscript}

\subsubsection{map}

Apply the given functional value on every member, and return the list
of results.

\begin{urbiscript}
[0, 1, 2, 3].map(function (v) { v % 2 == 0});
[00000000] [true, false, true, false]
\end{urbiscript}

\subsubsection{[]}
\label{sec:std-list-nth}

Return the nth member of the target (indexing is zero-based). An error
if out of bounds.

%\begin{urbiscript}[caption={\lstinline|List.'\[\]'|},
%label=lst:list-nth]
\begin{urbiscript}
var l = [0, 1, 2];
[00000000:hide] [0, 1, 2]
l[1];
[00000000] 1
l[3];
[00007061:error] !!! []: invalid index: 3
\end{urbiscript}

\subsubsection{removeBack}

Remove and return the last element of the target. An error if the
target is empty.

\begin{urbiscript}
var x = [0, 1, 2];
[00000000] [0, 1, 2]
x.removeBack;
[00000000] 2
x;
[00000000] [0, 1]
[].removeBack;
[00000000:error] !!! removeBack: cannot be applied onto empty list
\end{urbiscript}

\subsubsection{removeFront}

Remove and return the first element from the target. An error if the
target is empty.

\begin{urbiscript}
var x = [0, 1, 2];
[00000000] [0, 1, 2]
x.removeFront;
[00000000] 0
x;
[00000000] [1, 2]
[].removeFront;
[00000000:error] !!! removeFront: cannot be applied onto empty list
\end{urbiscript}

\subsubsection{insertBack}
\label{sec:std-list-pushback}

Insert the given element at the end of the target.

\begin{urbiscript}
var x = [0, 1];
[00000000] [0, 1]
x.insertBack(2);
[00000000] [0, 1, 2]
x;
[00000000] [0, 1, 2]
\end{urbiscript}

\subsubsection{insertFront}

Insert the given element at the beginning of the target.

\begin{urbiscript}
var x = [1, 2];
[00000000] [1, 2]
x.insertFront(0);
[00000000] [0, 1, 2]
x;
[00000000] [0, 1, 2]
\end{urbiscript}

\subsubsection{range}

Return a sub-range of the string, from the first index included to the
second index excluded. An error if out of bounds.

\begin{urbiscript}
[0, 1, 2, 3].range(1, 3);
[00000000] [1, 2]
[].range(1, 3);
[00428697:error] !!! urbi/list.u: []: invalid index: 1
\end{urbiscript}


\subsubsection{remove}

Remove all elements from the target that equals the argument.

\begin{urbiscript}
var x = [0, 1, 0, 2, 0, 3];
[00000000] [0, 1, 0, 2, 0, 3]
x.remove(0);
[00000000] [1, 2, 3]
x;
[00000000] [1, 2, 3]
\end{urbiscript}

\subsubsection{removeById}

Remove all elements from the target that physically equals the
argument.

\begin{urbiscript}
var x = 1;
[00000000] 1
var l = [0, 1, x, 1, 2];
[00000000] [0, 1, 1, 1, 2]
l.removeById(x);
[00000000] [0, 1, 1, 2]
l;
[00000000] [0, 1, 1, 2]
\end{urbiscript}

\subsubsection{reverse}

Return the target with the order of elements inverted.

\begin{urbiscript}
[0, 1, 2].reverse;
[00000000] [2, 1, 0]
\end{urbiscript}

\subsubsection{==}

Check whether all elements in the target and the first argument, are
equal two by two.

%\begin{urbiscript}[caption={\lstinline|List.==|}, label=lst:list-sameAs]
\begin{urbiscript}
[0, 1, 2] == [0, 1, 2];
[00000000] true
[0, 1, 2] == [0, 0, 2];
[00000000] false
\end{urbiscript}

\subsubsection{[]=}
\label{sec:std-list-setnth}

Assign a value to the element of the target at the given index.

%\begin{urbiscript}[caption={\lstinline|List.'\[\]='|}, label=lst:list-setNth]
\begin{urbiscript}
var x = [0, 1, 2];
[00000000] [0, 1, 2]
x[1] = 42;
[00000000] 42
x;
[00000000] [0, 42, 2]
\end{urbiscript}

\subsubsection{size}

Return the number of elements in the target.

\begin{urbiscript}
[1, 2, 3].size;
[00000000] 3
[].size;
[00000000] 0
\end{urbiscript}

\subsubsection{sort}

Return the target, sorted with respect to the \lstinline|<| criteria.

\begin{urbiscript}
[1, 0, 3, 2].sort;
[00000000] [0, 1, 2, 3]
\end{urbiscript}

\subsubsection{tail}

Return the target, minus the first element. An error if the target is
empty.

\begin{urbiscript}
[0, 1, 2].tail;
[00000000] [1, 2]
[].tail;
[00000000:error] !!! tail: cannot be applied onto empty list
\end{urbiscript}

\subsubsection{*}

Return the target, concatenated n times to itself, n being the
argument.

%\begin{urbiscript}[caption={\lstinline|List.'*'|}, label=lst:list-times]
\begin{urbiscript}
[0, 1] * 3;
[00000000] [0, 1, 0, 1, 0, 1]
\end{urbiscript}

\subsubsection{+}

Return the concatenation of the target and the given list.

%\begin{urbiscript}[caption={\lstinline|List.'+'|}, label=lst:list-plus,
\begin{urbiscript}
  float=\floatpos]
[0, 1] + [2, 3];
[00000000] [0, 1, 2, 3]
\end{urbiscript}

\subsubsection{-}

Return the target without all element that equals any element in the
given list.

%\begin{urbiscript}[caption={\lstinline|List.'-'|}, label=lst:list-minus,
\begin{urbiscript}
[0, 1, 0, 2, 3] - [1, 2];
[00000000] [0, 0, 3]
\end{urbiscript}

\subsubsection{\textless\textless}

A synonym for \lstinline|insertBack| (\autoref{sec:std-list-pushback}).

\subsubsection{\textless}

Return whether the target is inferior to the given list. A list is
inferior to another if at least one of its element differs from the
other, and the first differing element is inferior to the other.

%\begin{urbiscript}[caption={\lstinline|List.'<'|}, label=lst:list-inf,
\begin{urbiscript}
[0, 1, 2] < [0, 1, 2];
[00000000] false
[0, 1, 2] < [0, 0, 2];
[00000000] false
[0, 1, 2] < [0, 2, 2];
[00000000] true
\end{urbiscript}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  lst asList asString foldl hasSame removeBack popback removeFront
% LocalWords:  popfront insertBack pushback insertFront pushfront urbi sameAs
% LocalWords:  removeById setNth
