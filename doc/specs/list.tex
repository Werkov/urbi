\section{List}

\lstinline|List|s implement potentially-empty ordered (heterogeneous)
collections of elements.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Object}
\end{itemize}

\subsection{Construction}

List can be created with their literal syntax: a possibly empty
sequence of expressions in square brackets, separated by commas.
Non-empty list may actually \emph{terminate} with a comma, rather than
\emph{separate}; in other words, an optional trailing comma is accepted.

\begin{urbiscript}
[]; // The empty list
[00000000] []
[1, "2", [3,],];
[00000000] [1, "2", [3]]
\end{urbiscript}

\subsection{Slots}

\begin{itemize}
\item \lstinline|all(\var{fun})|\\
  % FIXME: link to predicate glossary entry
  Return whether all the members of the target verify the predicate
  \var{fun}.

\begin{urbiscript}[firstnumber=last]
// Are all elements positive?
assert(! [-2, 0, 2, 4].all(function (e) { e > 0 }));
// Are all elements even?
assert([-2, 0, 2, 4].all(function (e) { e % 2 == 0 }));
\end{urbiscript}

\item \lstinline|any(\var{fun})|\\
  % FIXME: link to predicate glossary entry
  Whether at least one of the members of the target verifies the
  predicate \var{fun}.

\begin{urbiscript}[firstnumber=last]
// Is there any even element?
assert(! [-3, 1, -1].any(function (e) { e % 2 == 0 }));
// Is there any positive element?
assert([-3, 1, -1].any(function (e) { e > 0 }));
\end{urbiscript}

\item \lstinline|asBool|\\
  Whether not empty.
\begin{urbiassert}[firstnumber=last]
[].asBool == false;
[1].asBool == true;
\end{urbiassert}

\item \lstinline|asList|\\
Return the target.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2].asList == [0, 1, 2];
\end{urbiassert}

\item \lstinline|asString|\\
  A string describing the list.  Uses \lstinline|asPrintable| on its
  members, so that, for instance, strings are displayed with quotes.

\begin{urbiassert}[firstnumber=last]
[0, [1], "2"].asString == "[0, [1], \"2\"]";
\end{urbiassert}

\item \lstinline|back|\\
Return the last element of the target. An error if the target is empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].back == 2);
[].back;
[00000000:error] !!! back: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|clear|\\
  Empty the target.

\begin{urbiscript}[firstnumber=last]
var x = [0, 1, 2];
[00000000] [0, 1, 2]
assert(x.clear == []);
\end{urbiscript}

\item \lstinline|each(\var{fun})|\\
  Apply the given functional value \var{fun} on all members,
  sequentially.

\begin{urbiscript}[firstnumber=last]
[0, 1, 2].each(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 0
[00000000] *** 1
[00000000] *** 1
[00000000] *** 4
[00000000] *** 4
\end{urbiscript}

\item \lstinline|'each&'(\var{fun})|\\
Apply the given functional value on all members simultaneously.

\begin{urbiscript}[firstnumber=last]
[0, 1, 2].'each&'(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
\end{urbiscript}

\item \lstinline|empty|\\
  Whether the target is empty.

\begin{urbiassert}[firstnumber=last]
[].empty;
! [1].empty;
\end{urbiassert}

\item \lstinline|filter(\var{fun})|\\
  The list of all the members of the target that verify the predicate
  \var{fun}.

\begin{urbiscript}[firstnumber=last]
// Keep only odd numbers.
assert([0, 1, 2, 3, 4, 5].filter(function (v) {v % 2 == 1}) == [1, 3, 5]);
\end{urbiscript}

\item \lstinline|foldl(\var{action}, \var{value})|\\
  \wref[Fold_(higher-order_function)]{Fold},
  also known as \dfn{reduce} or \dfn{accumulate}, computes a result
  from a list.  Starting from \var{value} as the initial result, apply
  repeatedly the binary \var{action} to the current result and the
  next member of the list, from left to right.  For instance, if
  \var{action} were the binary addition and \var{value} were 0, then
  folding a list would compute the sum of the list, including for
  empty lists.

\begin{urbiscript}[firstnumber=last]
[].foldl(function (a, b) { a + b }, 0);
[00000000] 0
[1, 2, 3].foldl(function (a, b) { a + b }, 0);
[00000000] 6
[1, 2, 3].foldl(function (a, b) { a - b }, 0);
[00000000] -6
\end{urbiscript}

\item \lstinline|front|\\
  Return the first element of the target. An error if the target is
  empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].front == 0);
[].front;
[00000000:error] !!! front: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|has(\var{that})|\\
  Whether one of the members of the target equals the argument.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2].has(1);
! [0, 1, 2].has(5);
\end{urbiassert}

\item \lstinline|hasSame(\var{that})|\\
  Return whether one of the member of the target is physically equal
  to the argument.

\begin{urbiscript}[firstnumber=last]
var y = 1;
[00000000:hide] 1
[0, y, 2].hasSame(1);
[00000000] false
[0, y, 2].hasSame(y);
[00000000] true
\end{urbiscript}

\item \lstinline|head|\\
  Synonym for \lstinline|front|.

\item \lstinline|insertBack(\var{that})|\\
  Insert the given element at the end of the target.

\begin{urbiscript}[firstnumber=last]
var z = [0, 1];
[00000000] [0, 1]
assert(z.insertBack(2) == [0, 1, 2]);
assert(z == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|insertFront(\var{that})|\\
  Insert the given element at the beginning of the target.

\begin{urbiscript}[firstnumber=last]
var a = [1, 2];
[00000000] [1, 2]
assert(a.insertFront(0) == [0, 1, 2]);
assert(a == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|join(\var{sep} = "", \var{prefix} = "", \var{suffix} = "")|\\
  Bounces to \lstinline|String.join|, see \refObject{String}.

\begin{urbiassert}[firstnumber=last]
["", "ob", ""].join                == "ob";
["", "ob", ""].join("a")           == "aoba";
["", "ob", ""].join("a", "B", "b") == "Baobab";
\end{urbiassert}

\item \lstinline|keys()|\\
  The list of valid indexes.  This allows uniform iteration over a
  \refObject{Dictionary} or a \refObject{List}.

\begin{urbiscript}[firstnumber=last]
{
  var l = ["a", "b", "c"];
  assert(l.keys == [0, 1, 2]);
  assert({
           var res = [];
           for (var k: l.keys)
             res << l[k];
           res
         }
         == l);
};
\end{urbiscript}

\item \lstinline|map(\var{fun})|\\
Apply the given functional value on every member, and return the list
of results.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2, 3].map(function (v) { v % 2 == 0})
        == [true, false, true, false];
\end{urbiassert}

\item \lstinline|range(\var{begin}, \var{end})|\\
  Return a sub-range of the string, from the first index included to
  the second index excluded. An error if out of bounds.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2, 3].range(1, 3) == [1, 2]);
[].range(1, 3);
[00428697:error] !!! range: invalid index: 1
\end{urbiscript}

\item \lstinline|remove(\var{val})|\\
  Remove all elements from the target that equals \var{val}.

\begin{urbiscript}[firstnumber=last]
var c = [0, 1, 0, 2, 0, 3];
[00000000] [0, 1, 0, 2, 0, 3]
assert(c.remove(0) == [1, 2, 3]);
assert(c == [1, 2, 3]);
\end{urbiscript}

\item \lstinline|removeBack|\\
  Remove and return the last element of the target. An error if the
  target is empty.

\begin{urbiscript}[firstnumber=last]
var t = [0, 1, 2];
[00000000] [0, 1, 2]
assert(t.removeBack == 2);
assert(t == [0, 1]);
[].removeBack;
[00000000:error] !!! removeBack: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|removeById(\var{that})|\\
  Remove all elements from the target that physically equals
  \var{that}.

\begin{urbiscript}[firstnumber=last]
var d = 1;
[00000000] 1
var e = [0, 1, d, 1, 2];
[00000000] [0, 1, 1, 1, 2]
assert(e.removeById(d) == [0, 1, 1, 2]);
assert(e == [0, 1, 1, 2]);
\end{urbiscript}

\item \lstinline|removeFront|\\
Remove and return the first element from the target. An error if the
target is empty.

\begin{urbiscript}[firstnumber=last]
var g = [0, 1, 2];
[00000000] [0, 1, 2]
assert(g.removeFront == 0);
assert(g == [1, 2]);
[].removeFront;
[00000000:error] !!! removeFront: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|reverse|\\
Return the target with the order of elements inverted.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2].reverse == [2, 1, 0];
\end{urbiassert}

\item \lstinline|size|\\
Return the number of elements in the target.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2].size == 3;
[].size == 0;
\end{urbiassert}

\item \lstinline|sort|\\
Return the target, sorted with respect to the \lstinline|<| criteria.

\begin{urbiassert}[firstnumber=last]
[1, 0, 3, 2].sort == [0, 1, 2, 3];
\end{urbiassert}

\item \lstinline|tail|\\
Return the target, minus the first element. An error if the target is
empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].tail == [1, 2]);
[].tail;
[00000000:error] !!! tail: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|'=='(\var{that})|\\
Check whether all elements in the target and \var{that}, are
equal two by two.

\begin{urbiassert}[firstnumber=last]
[0, 1, 2] == [0, 1, 2];
!([0, 1, 2] == [0, 0, 2]);
\end{urbiassert}

\item \lstinline|'[]'(\var{n})|\\
  Return the \var{n}th member of the target (indexing is
  zero-based). If \var{n} is negative, start from the end.  An error
  if out of bounds.

\begin{urbiscript}[firstnumber=last]
assert(["0", "1", "2"][0] == "0");
assert(["0", "1", "2"][2] == "2");
["0", "1", "2"][3];
[00007061:error] !!! []: invalid index: 3

assert(["0", "1", "2"][-1] == "2");
assert(["0", "1", "2"][-3] == "0");
["0", "1", "2"][-4];
[00007061:error] !!! []: invalid index: -4
\end{urbiscript}

\item \lstinline|'[]='(\var{index}, \var{value})|\\
  Assign \var{value} to the element of the target at the given
  \var{index}.

\begin{urbiscript}[firstnumber=last]
var f = [0, 1, 2];
[00000000] [0, 1, 2]
f[1] = 42;
[00000000] 42
assert(f == [0, 42, 2]);
\end{urbiscript}

\item \lstinline|'*'(\var{times})|\\
Return the target, concatenated n times to itself, n being \var{times}.

\begin{urbiassert}[firstnumber=last]
[0, 1] * 3 == [0, 1, 0, 1, 0, 1];
\end{urbiassert}

\item \lstinline|'+'(\var{other})|\\
Return the concatenation of the target and the \var{other} list.

\begin{urbiassert}[firstnumber=last]
[0, 1] + [2, 3] == [0, 1, 2, 3];
\end{urbiassert}

\item \lstinline|'-'(\var{other})|\\
Return the target without all element that equals any element in the
\var(other) list.

\begin{urbiassert}[firstnumber=last]
[0, 1, 0, 2, 3] - [1, 2] == [0, 0, 3];
\end{urbiassert}

\item \lstinline|'<<'(\var{that})|\\
  A synonym for \lstinline|insertBack|.

\item \lstinline|'<'(\var{other})|\\
  Return whether the target is inferior to the \var{other} list. A
  list is inferior to another if at least one of its element differs
  from the other, and the first differing element is inferior to the
  other.

\begin{urbiassert}[firstnumber=last]
!([0, 1, 2] < [0, 1, 2]);
!([0, 1, 2] < [0, 0, 2]);
[0, 1, 2] < [0, 2, 2];
\end{urbiassert}

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  lst asList asString foldl hasSame removeBack popback removeFront
% LocalWords:  popfront insertBack pushback insertFront pushfront urbi sameAs
% LocalWords:  removeById setNth
