\newcommand{\slot}[2]{%
  \lstindex{#1} & #2 \\\hline%
}%

\newcommand{\optSlot}[2]{%
  \cellcolor{verylightgray}[\lstindex{#1}] & #2 \\\hline%
}%

\newenvironment{slotsOrEvents}[1]
{%
  % \subparagraph{#1}%
  \tablehead{%
    \hline%
    \textbf{#1} &%
    \textbf{Description}\\\hline%
  }%
  \begin{supertabular}{|m{.15\textwidth}|m{.8\textwidth}|}%
  }{%
  \end{supertabular}%
}

\newenvironment{slots}
{%
  \begin{slotsOrEvents}{Slot}%
  }{%
  \end{slotsOrEvents}%
}

\newenvironment{events}
{%
  \begin{slotsOrEvents}{Event}%
  }{%
  \end{slotsOrEvents}%
}

\newcommand{\refFacet}[2][]%
  {\hyperref[sec:facet:#2]{\lstinline|#2|#1 (\autoref*{sec:facet:#2})}}

\newcommand{\facet}[2][]{%
  \ifthenelse{\equal{#1}{}}{%
    \subsection{#2\index{#2@\lstinline{#2}}}%
  }{%
    \subsection{#2 (subclass of #1)\index{#2@\lstinline{#2}}}%
  }%
  \label{sec:facet:#2}
}


\chapter{Gostai Standard Robotics API}
\label{sec:naming}


This section aims at clarifying the naming conventions in \urbi
Engines for standard hardware/software devices and components
implemented as UObject and the corresponding methods/attributes/events
to access them. The list of available hardware types and software
component is increasing and this document will be updated
accordingly. Please contact us directly, should you be working on a
component not described or closely related to one described here:

\begin{center}
  \email{standard@gostai.com}
\end{center}

Any implementation of an \urbi server must comply with the latest
version of this standard to get the ``\urbi Ready'' certification from
Gostai S.A.S.

Gostai S.A.S. is currently the only authority which has the ability to
deliver an ``\urbi Ready'' certification.

``\urbi Ready'' and the associated logo are trademarks of Gostai
S.A.S. and should not be used or displayed in any way without an
explicit written agreement from Gostai.

\section{The Structure Tree}

The robot will be described as a set of \dfn[component]{components} organized
in a hierarchical structure called the \dfn{structure tree}. The
relationship between a component and a sub-component in the tree is a
`part-of' inclusion relationship. From the point of view of \urbi,
each component in the tree is an object, and it contains attributes
pointing to its sub-components. Here is a example illustrating a part
of a hierarchy that could be found with a humanoid robot:

\begin{center}
  \includegraphics[width=.8\linewidth]{img/structure-tree}
\end{center}

The leaves of the tree are called \textit{devices}, and they usually
match physical devices in the robot: motors, sensors, lights, camera,
etc. Inside \urbi, the various objects corresponding to the tree
components are accessed by following the path of objects inclusions,
like in the example below (shortcuts will be described later):

\begin{urbiunchecked}
body.legR.hip.tilt;
body.legL.knee.led;
body.legL.hip;
// ...
\end{urbiunchecked}


The structure tree should not be mistaken for a representation of the
kinematics chain of the robot. The kinematics chain is built from a
subset of the devices corresponding to motor devices, and it
represents spatial connections between them. Except for these motor
devices, the structure tree components do not have a direct
counterpart in the kinematics chain, or, if they do, it is as a subset
of the kinematics chain (for example, \code{legR} is a subset of the
whole kinematics chain).


The goal of this standard is to provide guidelines on how to define
the components and the structure tree, knowing the kinematics chain of
the robot.

\section{Frame of Reference}

In many cases, it will be necessary to refer to an absolute frame of
reference attached to the robot body. To avoid ambiguities, the
standard frame of reference will have the following definition:

\begin{center}
  \includegraphics{img/reference-frame}
\end{center}

\begin{description}
\item[Origin] the center of mass of the robot
\item[X axis] oriented towards the front of the robot. If there is a
  camera, the front is defined by the default direction of the camera,
  otherwise the front will be seen as the natural frontal orientation
  for a mobile robot (the direction of ``forward'' movement). If the
  robot is not naturally oriented, the X axis will be chosen to match
  the main axis of symmetry of the robot body and it will be oriented
  towards the smallest side, typically the top of a cone for
  example. In case of a perfectly symmetrical body, the X axis can be
  chosen arbitrarily but a clear mark should be made visible on the
  robot body to indicate it.
\item[Z axis] oriented in the opposite direction from the gravity. If
  there is no gravity or natural up/down orientation in the
  environment or normal operation mode of the robot, the Z axis should
  be chosen in the direction of the main axis of symmetry in the
  orthogonal plane defined by the X axis, oriented towards the
  smallest side. In case of a perfectly symmetrical plane, the Z axis
  can be chosen arbitrarily but a clear mark should be made visible on
  the robot body to indicate it.
\item[Y axis] oriented to make a right-handed coordinate system.
\end{description}


The axes are oriented in a counter-clockwise direction, as depicted in
the illustration above.

\section{Component naming}

Each component A, which is a sub-component of component B has a name, distinct
from the name of all the other components at the same level.
This name is a generic designation of what A represents, such as ``leg''
,``head'', or ``finger''.

Using the correct name for each component is a critical part of this standard.
No formal rule can be given to find this name for any possible robot
configuration. However, this document includes a table covering many different
possible cases. We recommend that robot manufacturers pick from this table
the name that fits the most the description of their component.

\section{Localization}
When two identical components A1 and A2, such as the two legs of an humanoid
robots, are present in the same sub-component B, an extra node is inserted in
the hierarchy to differenciate them. This node is of the \code{Localizer} type,
and provides a \code{[]} operator, taking a \code{Localization} argument, used
to access each of the identical sub-components.
The urbi SDK provides an implementation for the \code{Localizer} and
\code{Localization} classes.
When possible, localization should be simple geometrical qualifier like
\textit{Right}/\textit{Center}/\textit{Left},
\textit{Front}/\textit{Middle}/\textit{Back} or
\textit{Up}/\textit{In-between}/\textit{Down}.
Note that ``right'' or ``front'' are
understood here from the point of view of a man standing and looking
in the direction of the X-axis of the robot, and \textit{Up/Down}
matches the Z-axis, as depicted in the figure below:

\begin{center}
  \includegraphics[width=.5\linewidth]{img/cube}
\end{center}

Several geometric qualifiers can be used at the same time to further
refine the position. As a convention, height information (U/I/D) comes first,
folowwed by depth information (F/M/H), and then side information (R/C/L).

\begin{urbiunchecked}
// Top-left LED of the left eye.
robot.body.head.eye[left].led[topleft].val = 1;
// Touch sensor at the end of the front-left leg of a four-legged robot:
robot.body.leg[frontleft].foot.touch;
\end{urbiunchecked}

You can further qualify a side+depth localization with an additional
R/L side information. This can be used in the typical layout below:

\begin{center}
  \includegraphics{img/lrfh}
\end{center}

This dual positioning using side+depth can also be used to combine
side+height or height+depth information.

Layouts with a sequence of three or more identical components can use numbers
as their Localization, starting from 0.  The smaller the number, the closer to
the front, up, or left. For instance, an insectoid robot with 3 legs on each
side will use
\code{robot.body.leg[left][0]} to address the frontleft leg.

Some components like spines or tails are highly articulated with a set
of identical sub-components. When talking about these sub-components,
the above localization should be replaced by an array with a numbering
starting at 0. The smaller the number, the closer the sub-component is
to the robot main body. For surface-like sub-components, like skin
touch sensors, the array can be two dimensional.

Other possible localization for sensors are the X, Y and Z axis
themselves, like for example for an accelerometer or a gyro sensor,
available in each of the three directions.

\begin{urbiunchecked}
robot.body.accel[x]; // accelerometer in the x direction
\end{urbiunchecked}


Examples of component names including localization:

\begin{urbiunchecked}
leg[right], leg[left]L;
finger[right], finger[center], finger[left];      // three-finger hand
joint[0], joint[1] ... joint[5] // from tail
touch[478][124]                 // from skin
accel[x], accel[y], accel[z];         // typical accelerometer
gyro[x], gyro[y], gyro[z];            // typical gyro sensor
\end{urbiunchecked}

\section{Facets}
\label{sec:facet}

\urbi allows multiple inheritances between objects. This feature can be
used to introduce the notion of ``facet''. A facet is an object in \urbi
that describes some aspects of a type of component.

For example, for a joint, we can have a ``swivel'' facet, used to define
patella joints. For the robot body itself, we have a ``mobile'' facet
describing mobile robots, which includes some standard way of
requesting a move forward, a turn, etc. A robot with a Pan/Tilt camera
or otherwise moving camera will have the ``panoramic'' facet which is
abstracting the way the robot can turn its gaze in any direction.

In short, facets are standard Urbi objects that components can inherit
from to acquire some functionalities, expressed as a standard
interface.  These objects feature slots, and events; some of them
possibly are optional, which is denoted by grayed-cells, and a name
put in square backets.

The following pages describe a few of the most standard facets. Each
facet should be reimplemented for any particular robot that uses them,
for example the ``mobile'' facet will have a completely different
implementation with a humanoid robot and a wheeled robot.

\facet{Identity}

Contains information about the robot identity.

\begin{slots}
  \slot{type}
  {
    This describes the robot category among: humanoid, fourlegged,
    wheeled, industrial arm. It gives a general idea of the robot
    family, but does not replace a more systematic probe of available
    services by investigating the list of attributes of the object.
  }

  \slot{name}%
  {%
    Name of the robot.%
  }

  \slot{model}%
  {%
    Model of the robot.%
  }

  \slot{serial}%
  {%
    Serial number (if available).%
  }

\end{slots}


\facet{Network}

Contains information about the network identification of the robot.

\begin{slots}
  \slot{IP}%
  {%
    IP address of the robot.%
  }

\end{slots}

\facet{Motor}

This facet is used to describe a generic motor controller.

\begin{slots}
  \slot{val}%
  {%
    This slot is a generic pointer to a more specific slot describing
    the motor position, like \code{position} or \code{angle},
    depending on the type of motor. It is mandatory in the Urbi Ready
    standard as a universal proxy to control an actuator. The more
    specific slot is described in a subclass of \code{Motor}.%
  }

  \optSlot{PGain}%
  {%
    Controls the P gain of the PID controller.%
  }

  \optSlot{IGain}%
  {%
    Controls the I gain of the PID controller.%
  }

  \optSlot{DGain}%
  {%
    Controls the D gain of the PID controller.%
  }

\end{slots}

\facet[Motor]{LinearMotor}


This facet is used to describe a linear motor controller.

\begin{slots}
  \slot{position}%
  {%
    Position of the motor in centimeters.  Pointed to by the
    \code{val} slot.%
  }

  \slot{force}%
  {%
    Intensity of the measured or estimated force applied on a linear
    motor.%
  }

\end{slots}

\facet[Motor]{RotationalMotor}


This facet is used to describe a rotational motor controller.

\begin{slots}
  \slot{angle}%
  {%
    Angle of the motor in radian, modulo $2\pi$. Pointed to by the
    \code{val} slot.%
  }

  \slot{turn}%
  {%
    Absolute angular position of the motor, expressed in number of
    turns.%
  }

  \slot{torque}%
  {%
    Intensity of the measured or estimated torque applied on the
    motor.%
  }

\end{slots}


\facet{Sensor}

This facet is used to describe a generic sensor.

\begin{slots}
  \slot{val}%
  {%
    This slot is a generic pointer to a more specific slot describing
    the sensor value, like \code{distance} or \code{temperature},
    depending on the type of sensor. It is mandatory in the Urbi Ready
    standard as a universal proxy to read a sensor. The more specific
    slot is described in a subclass of \code{Sensor}.%
  }

\end{slots}


\facet[Sensor]{DistanceSensor}

This facet is used to describe a distance sensor (infrared, laser,
ultrasonic...).

\begin{slots}
  \slot{distance}%
  {%
    Measured distance expressed in meters.  Pointed to by the
    \code{val} slot.%
  }

\end{slots}


\facet[Sensor]{TouchSensor}

This facet is used to describe a touch pressure sensor (contact,
induction,...).

\begin{slots}
  \slot{pressure}%
  {%
    Intensity of the pressure put on the touch sensor. Can be 0/1 for
    simple buttons or expressed in Pascal units. Pointed to by the
    \code{val} slot.%
  }

\end{slots}


\facet[Sensor]{AccelerationSensor}

This facet is used to describe an accelerometer.

\begin{slots}
  \slot{acceleration}%
  {%
    Acceleration expressed in $m/s^2$.  Pointed to by the \code{val}
    slot.%
  }

\end{slots}

\facet[Sensor]{GyroSensor}
This facet is used to describe an gyrometer.

\begin{slots}
  \slot{speed}%
  {%
    Rotational speed in $\mathrm{rad}/s$.  Pointed to by the
    \code{val} slot.%
  }
\end{slots}

\facet[Sensor]{TemperatureSensor}
This facet is used to describe a temperature sensor.

\begin{slots}
  \slot{temperature}%
  {%
    Measured temperature in Celsius degrees.  Pointed to by the
    \code{val} slot.%
  }
\end{slots}

\facet{Mobile}

Mobile robots all share this generic interface to provide high order
level motion control capabilities.

\begin{slots}
  \slot{go(x)}%
  {%
    Move approximatively x meters forward if x is positive, backward
    otherwise.%
  }

  \slot{turn(x)}%
  {%
    Turn right approximatively \var{x} radians.  \var{x} can be a
    positive or negative value.%
  }

\end{slots}

\facet{Tracker}

Camera-equipped robots can sometimes move the orientation of the field
of view horizontally and vertically, which is a very important feature
for many applications. In that case, this facet abstracts how such
motion can be achieved, whether it is done with a pan/tilt camera or
with whole body motion or a combination of both.

\begin{slots}
  \slot{yaw}%
  {%
    Rotational articulation around the Z axis in the robot, expressed
    in radians.%
  }

  \slot{pitch}%
  {%
    Rotational articulation around the Y axis in the robot, expressed
    in radians.%
  }

\end{slots}

\facet{VideoIn}

The VideoIn facet groups every information relative to cameras or any
image sensor.

\begin{slots}
  \slot{val}%
  {%
    Image represented as a \code{Binary} value. %
  }

  \slot{xfov}%
  {%
    The x field of view of the camera expressed in radians.%
  }

  \slot{yfov}%
  {%
    The y field of view of the camera expressed in radians.%
  }

  \slot{height}%
  {%
    Height of the image in the current resolution, expressed in
    pixels%
  }

  \slot{width}%
  {%
    Width of the image in the current resolution, expressed in pixels%
  }

  \optSlot{format}%
  {%
    Format of the image, expressed as an integer in the enum urbi::UImageFormat.
    See below for more informations.%
  }

  \optSlot{exposure}%
  {%
    Exposure duration, expressed in seconds. 0 if non applicable.%
  }

  \optSlot{wb}%
  {%
    White balance (expressed with an integer value depending on the
    camera documentation). 0 if non applicable.%
  }

  \optSlot{gain}%
  {%
    Camera gain amplification (expressed as a coefficient between 0
    and infinity). 1 if non applicable.%
  }

  \optSlot{resolution}%
  {%
    Image resolution, expressed as an integer. 0 corresponds to the
    maximal resolution of the camera. Successive values correspond to
    all the supported image sizes in decreasing order.
    Once modified, the effective resolution in X/Y can be checked with
    the width and height slots.%
  }
  \optSlot{quality}%
  {%
    If the image is in the jpeg format, this slot sets the compression quality,
    from 0 (best compression, worst quality) to 100 (best quality, bigger
    image).%
  }

\end{slots}

The image sensor is expected to use the cheapest way in term of CPU and/or
energy consumption to produce images of the requested format.
Implementations linked to a physical image sensor do not have to implement
all the possible formats. In this case, the format closest to what was
requested must be used.
A generic image conversion object will be provided. In order to avoid
duplicate image conversions when multiple unrelated behaviors need the same
format, it is recommended that this object be instannciated in a slot of the
VideoIn object named after the format it converts to:
\begin{urbiunchecked}
if (!robot.body.head.camera.hasSlot("jpeg"))
{
  var robot.body.head.camera.jpeg =
    ImageConversion.new(robot.body.head.camera.getSlot("val"));
  robot.body.head.camera.jpeg.format = 3;
}
\end{urbiunchecked}

\facet{AudioOut}
The AudioOut facet groups every information relative to speakers.

\begin{slots}
  \slot{val}%
  {%
    The speaker value, expressed as a binary, in the format given by
    the binary header during the assignment.

    Speakers are write-only devices, so there is not much sense in
    reading the content of this attribute. At best, it returns the
    remaining sound to be played if it is not over yet, but this is
    not a requirement.%
  }

  \slot{remain}%
  {%
    The amount of time remaining to play in the speaker sound buffer
    (expressed in \textit{ms} as a default unit).%
  }

  \slot{playing}%
  {%
    This is a boolean value which is true when there is a sound
    currently playing (the buffer is not empty)%
  }

  \optSlot{volume}%
  {%
    Volume of the play back, in decibels.%
  }
\end{slots}



\facet{AudioIn}

The AudioIn facet groups every information relative to microphones.

\begin{slots}
  \slot{val}%
  {%
    Binary value corresponding to the sound heard, expressed in the
    current unit (wav, mp3...). The unit can be changed like any other
    regular unit in Urbi.

    The content is the sound heard by the microphone since the last
    update event.%
  }
  \slot{duration}%
  {%
    Amount of sound in the val attribute, expressed in \textit{ms}.%
  }
  \optSlot{gain}%
  {%
    Microphone gain amplification (expressed between 0 and 1)%
  }
\end{slots}


\facet{BlobDetector}

Ball detectors, marker detectors and various feature-based detectors
should all share a similar interface. They extract a part of the image
that fits some criteria and define a \dfn{blob} accordingly. Here are
the typical slots expected:

\begin{slots}
  \slot{x}%
  {%
    The x position of the center of the blob in the image%
  }

  \slot{y}%
  {%
    The y position of the center of the blob in the image%
  }

  \slot{ratio}%
  {%
    The size of the blob expressed as a normalized image size: 1 =
    full image, 0 = nothing.%
  }

  \slot{visible}%
  {%
    A Boolean expressing whether there is a blob in the image or not
    (see threshold)%
  }

  \slot{threshold}%
  {%
    The minimum value of ratio to decide that the blob is visible.%
  }

  \optSlot{orientation}%
  {%
    Angle of the main ellipsoid axis of the blob (0 = horizontal),
    expressed in radians.%
  }

  \optSlot{elongation}%
  {%
    Ratio between the main and the second diameter of the blob
    enveloping ellipse.%
  }

\end{slots}

\facet{TextToSpeech}
Text to speech allows to read text using a speech synthetizor. Default
implementations should use the \code{speaker} component (or alias) as
their default sound output.

\begin{slots}
  \optSlot{lang}%
  {%
    The language used, in international notation (fr, en, it…): ISO
    639%
  }

  \optSlot{speed}%
  {%
    How fast the voice should go.  A positive number, with 1 standing
    for ``regular speed''.
  }

  \optSlot{pitch}%
  {%
    Voice pitch.  A positive number, with 1 standing the regular pitch.%
  }

  \optSlot{gender}%
  {%
    Gender of the speaker (0:male/1:female).%
  }

  \optSlot{age}%
  {%
    Age of the speaker, if applicable.%
  }

  \optSlot{voice}%
  {%
    Most TTS engines propose several voices, this attribute
    allows picking one. It's a string identifier specific to the TTS
    developer.%
  }

  \slot{say(s)}%
  {%
    Speak the sentence given in parameter \var{s}.%
  }

  \optSlot{voicexml(s)}%
  {%
    Speak the text \var{s} expressed as a VoiceXML string.%
  }

  \optSlot{script(s)}%
  {%
    Speak the text \var{s} augmented by script markups (see specific
    Gostai documentation) to generate \urbi events.%
  }

\end{slots}


\facet{SpeechRecognizer}

Speech recognition allows to transform a stream of sound into a text
using various speech recognition algorithms. Implementations
should use the \code{micro} component as their default sound input.

\begin{slots}
  \optSlot{lang}%
  {%
    The language used, in international notation (fr, en, it…): ISO
    639%
  }
\end{slots}

\begin{events}
  \slot{hear(s)}%
  {%
    This event has one parameter which is the string describing what
    the speech engine has recognized (can be a word or a sentence).%
  }
\end{events}

\facet{Led}

Simple unicolor Led.

\begin{slots}
  \slot{val}%
  {%
    Led intensity between 0 and 1.%
  }
\end{slots}


\facet[Led]{RGBLed}

Tri-color led.

\begin{slots}
  \slot{r,g,b}%
  {%
    Intensity of the r, g, and b components, between 0 and 1.%
  }
\end{slots}

\section{Standard Components}

Standard components correspond to components typically found in wheeled
robots, humanoid or animaloid robots, or in industrial arms.

\subsection{Yaw/Pitch/Roll orientation}
\label{sec:naming:ypr}

It is not always clear which rotational direction corresponds to the
yaw, pitch or roll components (listed in the table below). This is a
quick guideline to help determine the proper association.

Let us consider the robot in its resting, most prototypical position,
like ``standing'' on two or four legs for a humanoid or animaloid, and
let all members ``naturally'' fall under gravity. When gravity has no
effect on a certain joint (because it is in the orthogonal plan to Z,
for example), the medium position between rangemin and rangemax should
be used. The body position achieved will be considered as a reference.
Then for each component that is described in terms of yaw/pitch/roll
sub-decomposition, the association will be as follow:

\begin{description}
\item[yaw] rotational articulation around the Z axis in the robot.
\item[pitch] rotational articulation around the Y axis in the robot.
\item[roll] rotational articulation around the X axis in the robot.
\end{description}

When there is no exact match with the X/Y/Z axis, the closest match, or
the default remaining available axis, should be selected to determine
the yaw/pitch/roll meaning.

\subsection{Standard Component List}
\label{sec:naming:components}

The following table summarizes the currently referenced standard
components, with a description of potential components that they could
be subcomponent of, a description of potential components they may
contain, and a list of relevant facets. This table should be seen as a
quick reference guide to identify available components in a given
robot.

\newcommand{\component}[5]
{
  \lstindex{#1} &
  #5 &
  \code{#2} &
  \code{#3} &
  \code{#4}\\\hline
}

\tablehead{\hline
\textbf{Name} &
\textbf{Description} &
\textbf{Sub. of} &
\textbf{Contains} &
\textbf{Facets} \\\hline}
\begin{supertabular}{|m{.115\linewidth}|m{.45\linewidth}|*{4}{m{.12\linewidth}|}}
  \component{robot}{}{body}{Identity Network Mobile Tracker}{
    %%
    This is the main component that represents an abstraction of the
    robot.
    %%
  }

  \component{body}{robot}{arm leg neck head wheel tail skin torso
    \ldots}{}{
    %%
    This is the main component that contains every piece of hardware
    in the robot. This includes all primary kinematics sub-chains
    (arms, legs, neck, head, etc) and non-localized sensor arrays,
    typically body skin or heat detectors.  Localized sensors, like
    fingertips touch sensors, will typically be found attached to the
    finger component they belong and not directly to the body.
    %%
  }

  \component{leg}{body}{hip knee ankle foot joint}{}{
    %%
    Legs are found in humanoid or animaloid robots and correspond to
    part of the kinematics chain that are attached to the main body by
    one extremity only and which do touch the ground in normal
    operation mode (unlike arms). A typical configuration for
    humanoids contains a hip, a knee and an ankle. If the leg is more
    segmented, the leg can be described with a simple array of joints.
    %%
  }

  \component{arm}{body}{shoulder elbow wrist hand grip joint}{}{
    %%
    Unlike legs, an arm's extremity does not always touch the ground
    in normal operating mode. This applies to humanoid robots or
    single-arm industrial robots. Arms supersede legs in the
    nomenclature: if a body part behaves alternatively like an arm and
    like a leg, it will be considered as an arm.
    %%
  }

  \component{shoulder}{arm}{yaw pitch roll}{}{
    %%
    The shoulder is the upper part of the arm. It can have one, two or
    three degrees of freedom and is the closest part of the arm
    relative to the body.
    %%
  }

  \component{elbow}{arm}{pitch}{}{
    %%
    Separates the upper arm and the lower arm, this is usually a
    single rotational axis.
    %%
  }

  \component{wrist}{arm}{yaw pitch roll}{}{
    %%
    Connects the hand and the lower part of the arm. Usually three
    degrees of freedom axis.
    %%
  }

  \component{hand}{arm}{finger}{}{
    %%
    The hand is an extension of the arm that usually holds
    fingers. It's not the wrist, which is articulated and between the
    arm and the hand.
    %%
  }

  \component{finger}{hand}{touch}{Motor}{
    %%
    Fingers are a series of articulated motors at the extremity of the
    arm, and connected to the hand. They are usually localized with
    arrays and/or lateral localization respective to the hand.
    %%
  }

  \component{grip}{arm hand}{touch}{Motor}{
    %%
    Simple two-fingers system.
    %%
  }

  \component{hip}{leg}{yaw pitch roll}{}{
    %%
    The hip is the upper part of the leg and connects it to the main
    body. It can have one, two or three degrees of freedom.
    %%
  }

  \component{knee}{leg}{pitch}{}{
    %%
    Separates the upper leg and the lower leg, this is usually a
    single rotational axis.
    %%
    }

  \component{ankle}{leg}{yaw pitch roll}{}{
    %%
    Connects the foot and the lower part of the leg. Usually three
    degrees of freedom axis.
    %%
    }

  \component{foot}{leg}{touch}{}{
    %%
    The foot is an extension of the leg that usually holds toes. It's
    not the ankle, which is articulated and between the leg and the
    foot. The foot can also contain touch sensors in simple
    configurations.
    %%
  }

  \component{toe}{foot}{touch}{Motor}{
    %%
    Like fingers, but attached to the foot.
    %%
  }

  \component{neck}{body}{yaw pitch roll}{}{
    %%
    The neck corresponds to a degree of freedom not part of the head,
    but relative to the rigid connection between the head and the main
    body.
    %%
  }

  \component{tail}{body}{joint}{}{
    %%
    A tail is a series of articulated motors at the back of the robot.
    %%
  }

  \component{head}{body neck}{camera mouth ear lip eye eyebrow}{}{
    %%
    The head main pivotal axis.
    %%
  }

  \component{mouth}{head}{lip}{Motor}{
    %%
    The robot mouth (open/close)
    %%
  }

  \component{ear}{head}{}{Motor}{
    %%
    Ears may have degrees of freedom in certain robots.
    %%
  }

  \component{joint}{tail arm leg lip}{}{Motor}{
    %%
    Generic articulation in the robot.
    %%
  }

  \component{yaw}{neck knee ankle shoulder elbow wrist
    torso}{}{Rotational\-Motor}{
    %%
    Rotational articulation around the Z axis in the
    robot. See \autoref{sec:naming:ypr}.
    %%
  }

  \component{pitch}{neck knee ankle shoulder elbow wrist
    torso}{}{Rotational\-Motor}{
    %%
    Rotational articulation around the Y axis in the
    robot.  See \autoref{sec:naming:ypr}.
    %%
  }

  \component{roll}{neck knee ankle shoulder elbow wrist
    torso}{}{Rotational\-Motor}{
    %%
    Rotational articulation around the X axis in the robot. See
    \autoref{sec:naming:ypr}.
    %%
  }

  \component{lip}{mouth}{joint}{Motor}{
    %%
    Corresponds to animated lips.
    %%
  }

  \component{eye}{head}{camera}{}{
    %%
    Corresponds to the eyeball pivotal axis.
    %%
    }

  \component{eyebrow}{head}{joint}{Motor}{
    %%
    Some robots will have eyebrows with generally one or several
    degrees of freedom.
    %%
    }

  \component{torso}{body}{yaw pitch roll}{}{
    %%
    This corresponds to a pivotal or rotational axis in the middle of
    the main body.
    %%
    }

  \component{spine}{torso}{joint}{}{
    %%
    This is a more elaborated version of ``torso'', with a series of
    articulations to give several degrees of freedom in the back of
    the robot.
    %%
    }

  \component{clavicle}{body}{}{Motor}{
    %%
    This is not to be mixed up with the ``top of the arm'' body part. It
    is an independent degree of freedom that can be used to bring the
    two arms closer in a sort of ``shoulder raising'' movement.
    %%
    }

  \component{touch}{finger grip foot toe}{}{TouchSensor}{
    %%
      Touch sensor.
    %%
    }

  \component{gyro}{body}{}{GyroSensor}{
    %%
      Gyrometer sensor.
    %%
    }

  \component{accel}{body}{}{Accel\-eration\-Sensor}{
    %%
      Accelerometer sensor.
    %%
    }

  \component{camera}{head body}{}{VideoIn}{
    %%
    Camera sensor. If several cameras are available, localization
    shall apply; however there must always be an alias from
    \code{camera} to one of the effective cameras (like \code{cameraR}
    or \code{cameraL}).
    %%
    }

  \component{speaker}{head body}{}{AudioIn}{
    %%
    Speaker device. If several speakers are available, localization
    shall apply; however there must always be an alias from
    \code{speaker} to one of the effective speakers (like
    \code{speakerR} or \code{speakerL}).
    %%
    }

  \component{micro}{head body}{}{AudioOut}{
    %%
    Microphone devices. If several microphones are available,
    localization shall apply; however there must always be an alias
    from \code{micro} to one of the effective microphones (like
    \code{microR} or \code{microL}).
    %%
  }

  \component{speech}{robot}{}{Speech\-Recognizer}{
    %%
      Speech recognition component.
    %%
    }

  \component{voice}{robot}{}{TextTo\-Speech}{
    %%
      Voice synthesis component.
    %%
    }

\end{supertabular}



\section{Compact notation}

Components are usually identified with their full-length name, which is
the path to access them inside the structure tree. For convenience and
backward compatibility with pre-2.0 versions of \urbi, there is also a
compact notation available. We will describe here how to construct the
compact notation starting from the full name and the structure tree.

\tablehead{\hline
Full name &
Compact name\\\hline}
\begin{supertabular}{|m{9.008cm}|m{5.533cm}|}
\code{robot.body.armR.elbow} &
\code{elbowR} \\\hline
\code{robot.body.head.yaw} &
\code{headYaw} \\\hline
\code{robot.body.legL.knee.pitch} &
\code{kneeL} \\\hline
\code{robot.body.armR.hand.finger[3][2]} &
\code{fingerR[3][2]} \\\hline
\code{robot.body.armL.hand.fingerR} &
\code{fingerLR} \\\hline
\end{supertabular}

The rule is to move every localization qualifier at the end of the
compact notation, in the order where they appear in the full-length
name. The remaining component names should then be considered one by
one to see if they are needed to remove ambiguities. If they are not,
like typically the robot or body components which are shared with
almost every other full-length name, they can be ignored. If finally
several component names have to be kept, they should be separated by
using upper case letters for the first character instead of a dot, like
in Java-style notation.

\begin{example}[\code{robot.body.armL.hand.fingerR}]~\\
  \begin{enumerate}
  \item Move all localization at the end:
    \code{robot.body.arm.hand.fingerLR}
  \item The fullname remaining is: \code{robot.body.arm.hand.finger}
  \item \code{finger} should be kept, \code{hand}, \code{arm},
    \code{body} and \code{robot} are not necessary since every
    finger component will always be attached only to a hand, itself
    attached to an arm and a body and a robot.
  \item The result is \code{fingerLR}
  \end{enumerate}
\end{example}


\begin{example}[\code{robot.body.head.yaw}]~\\
  \begin{enumerate}
  \item No localization to move
  \item \code{yaw} must be kept because \code{head} also have a
    \code{pitch} subcomponent and
  \item \code{head} must also be kept to avoid ambiguity with other
    components having a \code{yaw} subcomponent.
  \item The result is \code{headYaw}
  \end{enumerate}
\end{example}

\begin{example}[\code{robot.body.legL.knee.pitch}]~\\
  \begin{enumerate}
  \item Move all localization at the end:
    \code{robot.body.leg.knee.pitchL}
  \item \code{pitch} is not necessary because \code{knee} has only a
    \code{pitch}, so \code{knee} will be kept only
  \item The result is \code{kneeL}
  \end{enumerate}
\end{example}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
