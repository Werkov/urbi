\section{Float}

Float is an \us primitive to represent floating point number.  They
are also used, in the current version of \us, to represent integers.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Comparable}
\item \refObject{Orderable}
\item \refObject{RangeIterable}
\end{itemize}

\subsection{Construction}
\label{sec:float:ctor}

The most common way to create fresh floats is using the literal
syntax.  Numbers are composed of three parts:
\begin{description}
\item[integral] (mandatory) a non empty sequence of (decimal) digits;
\item[fractional] (optional) a period, and a non empty sequence of
  (decimal) digits;
\item[exponent] (optional) either \samp{e} or \samp{E}, an optional
  sign (\samp{+} or \samp{-}), then a non-empty sequence of digits.
\end{description}

In other words, float literals match the
\lstinline|[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?|
regular expression.  For instance:

\begin{urbiassert}
0 == 0000.0000;
// This is actually a call to the unary '+'.
+1 == 1;
0.123456 == 123456 / 1000000;
1e3 == 1000;
1e-3 == 0.001;
1.234e3 == 1234;
\end{urbiassert}

There are also some special numbers, \lstinline|nan|, \lstinline|inf|
(see below).

\begin{urbiassert}[firstnumber=last]
Math.log(0) == -inf;
Math.exp(-inf) == 0;
(inf/inf).asString == "nan";
\end{urbiassert}

A null float can also be obtained with \lstinline|Float|'s
\lstinline|new| method.

\begin{urbiassert}[firstnumber=last]
Float.new == 0;
\end{urbiassert}

\subsection{Slots}

\begin{itemize}
\item \lstinline|abs|\\
  Absolute value of the target.
\begin{urbiassert}[firstnumber=last]
(-5).abs == 5;
  0 .abs == 0;
  5 .abs == 5;
\end{urbiassert}

\item \lstinline|acos|\\
  Arccosine of the target.
\begin{urbiassert}[firstnumber=last]
0.acos == Float.pi/2;
1.acos == 0;
\end{urbiassert}

\item \lstinline|asBool|\\
  Whether non null.
\begin{urbiassert}[firstnumber=last]
0.asBool == false;
0.1.asBool == true;
(-0.1).asBool == true;
inf.asBool == true;
nan.asBool == true;
\end{urbiassert}

\item \lstinline|asFloat|\\
  Return the target.
\begin{urbiassert}[firstnumber=last]
51.asFloat == 51;
\end{urbiassert}

\item \lstinline|asList|\\
  Bounces to \lstinline|seq|.  It is therefore possible to use the
  various flavors of \lstinline|for|-range loops on integers:
\begin{urbiassert}[firstnumber=last]
{
  var res = [];
  for (var i : 3)
    res << i;
  res
}
== [0, 1, 2];

{
  var res = [];
  for|(var i : 3)
    res << i;
  res
}
== [0, 1, 2];

{
  var res = [];
  for&(var i : 3)
    res << i;
  res.sort
}
== [0, 1, 2];
\end{urbiassert}%>>

\item \lstinline|asin|\\
  Arcsine of the target.
\begin{urbiassert}[firstnumber=last]
0.asin == 0;
\end{urbiassert}

\item \lstinline|asString|\\
  Return a string representing the target.
\begin{urbiassert}[firstnumber=last]
42.asString == "42";
\end{urbiassert}

\item \lstinline|atan|\\
  Return the arctangent of the target.
\begin{urbiassert}[firstnumber=last]
0.atan == 0;
1.atan == Float.pi/4;
\end{urbiassert}

\item \lstinline|'bitand'(\var{that})|\\
  The bitwise-and between \lstinline|this| and \var{that}.
\begin{urbiassert}[firstnumber=last]
(3 bitand 6) == 2;
\end{urbiassert}

\item \lstinline|'bitor'(\var{that})|\\
  Bitwise-or between \lstinline|this| and \var{that}.
\begin{urbiassert}[firstnumber=last]
(3 bitor 6) == 7;
\end{urbiassert}

\item \lstinline|clone|\\
  Return a fresh Float with the same value as the target.
\begin{urbiscript}[firstnumber=last]
var x = 0;
[00000000] 0
var y = x.clone;
[00000000] 0
x === y;
[00000000] false
\end{urbiscript}

\item \lstinline|compl|\\
  The complement to 1 of the target interpreted as a 32 bits integer.
\begin{urbiassert}[firstnumber=last]
compl 0 == 4294967295;
compl 4294967295 == 0;
\end{urbiassert}

\item \lstinline|cos|\\
  Cosine of the target.
\begin{urbiassert}[firstnumber=last]
0.cos == 1;
Float.pi.cos == -1;
\end{urbiassert}

\item \lstinline|each(\var{fun})|\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, sequentially.  The number must be non-negative.
\begin{urbiassert}[firstnumber=last]
{
  var res = [];
  3.each(function (i) { res << 100 + i });
  res
}
== [100, 101, 102];

{
  var res = [];
  for(var x : 3) { res << x; sleep(20ms); res << (100 + x); };
  res
}
== [0, 100, 1, 101, 2, 102];

{
  var res = [];
  0.each (function (i) { res << 100 + i });
  res
}
== [];
\end{urbiassert}

\item \lstinline'each|(\var{fun})'\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, with tight sequentiality.  The number must be
  non-negative.
\begin{urbiassert}[firstnumber=last]
{
  var res = [];
  3.'each|'(function (i) { res << 100 + i });
  res
}
== [100, 101, 102];

{
  var res = [];
  for|(var x : 3) { res << x; sleep(20ms); res << (100 + x); };
  res
}
== [0, 100, 1, 101, 2, 102];
\end{urbiassert}%>>>>>>

\item \lstinline|each&(\var{fun})|\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, concurrently.  The number must ne non-negative.
\begin{urbiassert}[firstnumber=last]
{
  var res = [];
  for& (var x : 3) { res << x; sleep(30ms); res << (100 + x) };
  res
}
== [0, 1, 2, 100, 101, 102];
\end{urbiassert}%>>>>

\item \lstinline|exp|\\
  Exponential of the target.
\begin{urbiscript}[firstnumber=last]
1.exp;
[00000000] 2.71828
\end{urbiscript}

\item \lstinline|format(\var{finfo})|\\
  Format according to the \refObject{FormatInfo} object \var{finfo}.
  The precision, \lstinline|\var{finfo}.precision|, sets the maximum
  number of digits after decimal point when in fixed or scientific
  mode, and in total when in default mode.  Beware that 0 plays a
  special role, as it is not a ``significant'' digit.

  \begin{windows}
    Under Windows the behavior differs slightly.
  \end{windows}
\begin{urbiassert}[firstnumber=last]
"%1.0d" % 0.1 == "0.1";
"%1.0d" % 1.1 == {if (System.Platform.isWindows) "1.1" else "1"};

"%1.0f" % 0.1 == "0";
"%1.0f" % 1.1 == "1";
\end{urbiassert}

\item \lstinline|inf|\\
  Return the infinity.
\begin{urbiscript}[firstnumber=last]
Float.inf;
[00000000] inf
\end{urbiscript}

\item \lstinline|log|\\
  The logarithm of the target.
\begin{urbiassert}[firstnumber=last]
0.log == -inf;
1.log == 0;
1.exp.log == 1;
\end{urbiassert}

\item \lstinline|max(\var{arg1}, ...)|\\
  Bounces to \lstinline|List.max| on \lstinline|[this, \var{arg1}, ...]|.
\begin{urbiassert}[firstnumber=last]
1.max == 1;
1.max(2, 3) == 3;
3.max(1, 2) == 3;
\end{urbiassert}

\item \lstinline|min(\var{arg1}, ...)|\\
  Bounces to \lstinline|List.min| on \lstinline|[this, \var{arg1}, ...]|.
\begin{urbiassert}[firstnumber=last]
1.min == 1;
1.min(2, 3) == 1;
3.min(1, 2) == 1;
\end{urbiassert}

\item \lstinline|nan|\\
  The ``not a number'' special float value.  More precisely, this
  returns the ``quiet NaN'', i.e., it is propagated in the various
  computations, it does not raise exceptions.
\begin{urbiscript}[firstnumber=last]
Float.nan;
[00000000] nan
(Float.nan + Float.nan) / (Float.nan - Float.nan);
[00000000] nan
\end{urbiscript}

A {NaN} has one distinctive property over the other Floats: it is
equal to no other float, not even itself.  This behavior is mandated
by the \wref[IEEE_754-2008]{IEEE 754-2008} standard.
\begin{urbiassert}[firstnumber=last]
{ var n = Float.nan; n === n};
{ var n = Float.nan; n  != n};
\end{urbiassert}

\item \lstinline|pi|\\
  $\pi$.
\begin{urbiassert}[firstnumber=last]
Float.pi.cos ** 2 + Float.pi.sin ** 2 == 1;
\end{urbiassert}

\item \lstinline|random|\\
  A random integer between 0 (included) and the target (excluded).
\begin{urbiscript}[firstnumber=last]
20.map(function (dummy) { 5.random });
[00000000] [1, 2, 1, 3, 2, 3, 2, 2, 4, 4, 4, 1, 0, 0, 0, 3, 2, 4, 3, 2]
\end{urbiscript}

\item \lstinline|round|\\
  The target, rounded to the nearest integer.
\begin{urbiassert}[firstnumber=last]
1.6.round == 2;
1.4.round == 1;
\end{urbiassert}

\item \lstinline|seq|\\
  The sequence of integers from 0 to \lstinline|this| - 1 as a list.
  The number must be non-negative.
\begin{urbiassert}[firstnumber=last]
3.seq == [0, 1, 2];
0.seq == [];
(-1).seq;
[00004586:error] !!! seq: expected non-negative integer, got -1
\end{urbiassert}

\item \lstinline|sgn|\\
  Return 1 if \lstinline|this| is positive, 0 if it is null, -1
  otherwise.
\begin{urbiassert}[firstnumber=last]
(-1164).sgn == -1;
0.sgn       == 0;
(1164).sgn  == 1;
\end{urbiassert}

\item \lstinline|sin|\\
  The sine of the target.
\begin{urbiassert}[firstnumber=last]
0.sin == 0;
\end{urbiassert}

\item \lstinline|sqr|\\
  Square of the target.
\begin{urbiassert}[firstnumber=last]
32.sqr == 1024;
32.sqr == 32 ** 2;
\end{urbiassert}

\item \lstinline|sqrt|\\
  The square root of the target.
\begin{urbiassert}[firstnumber=last]
1024.sqrt == 32;
1024.sqrt == 1024 ** 0.5;
\end{urbiassert}

\item \lstinline|tan|\\
  Tangent of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.tan == 0);
(Float.pi/4).tan;
[00000000] 1
\end{urbiscript}

\item \lstinline|times(\var{fun})|\\
  Call the functional argument \var{fun} \lstinline|this| times.

\begin{urbiscript}[firstnumber=last]
3.times(function () { echo("ping")});
[00000000] *** ping
[00000000] *** ping
[00000000] *** ping
\end{urbiscript}

\item \lstinline|trunc|\\
  Return the target truncated.
\begin{urbiassert}[firstnumber=last]
1.9.trunc == 1;
(-1.9).trunc == -1;
\end{urbiassert}

\item \lstinline|'^'(\var{that})|\\
  Bitwise exclusive or between \lstinline|this| and \var{that}.
\begin{urbiassert}[firstnumber=last]
(3 ^ 6) == 5;
\end{urbiassert}

\item \lstinline|'>>'(\var{that})|\\%>>
  \lstinline|this| shifted by \var{that} bits towards the right.
\begin{urbiassert}[firstnumber=last]
4 >> 2 == 1;
\end{urbiassert}

\item \lstinline|'<'(\var{that})|\\
  Whether \lstinline|this| is less than \var{b}. The other comparison
  operators (\lstinline|<=|, \lstinline|>|, \ldots) can thus also be
  applied on floats since Float inherits \refObject{Orderable}.
\begin{urbiassert}[firstnumber=last]
  0 < 1;
!(1 < 0);
\end{urbiassert}

\item \lstinline|'<<'(\var{that})|\\
  \lstinline|this| shifted by \var{that} bit towards the left.
\begin{urbiassert}[firstnumber=last]
4 << 2 == 16;
\end{urbiassert}

\item \lstinline|'-'(\var{that})|\\
  \lstinline|this| subtracted by \var{b}.
\begin{urbiassert}[firstnumber=last]
6 - 3 == 3;
\end{urbiassert}

\item \lstinline|'+'(\var{that})|\\
  The sum of \lstinline|this| and \var{that}.
\begin{urbiassert}[firstnumber=last]
1 + 1 == 2;
\end{urbiassert}

\item \lstinline|'/'(\var{that})|\\
  The quotient of \lstinline|this| divided by \var{that}.
\begin{urbiassert}[firstnumber=last]
50 / 10 == 5;
10 / 50 == 0.2;
\end{urbiassert}

\item \lstinline|'%'(\var{that})|\\
  \lstinline|this| modulo \var{b}.
\begin{urbiassert}[firstnumber=last]
50 % 11 == 6;
\end{urbiassert}

\item \lstinline|'*'(\var{that})|\\
  Product of \lstinline|this| by \var{that}.
\begin{urbiassert}[firstnumber=last]
2 * 3 == 6;
\end{urbiassert}

\item \lstinline|'**'(\var{that})|\\
  \lstinline|this| to the \var{that} power (${this}^{that}$).
\begin{urbiassert}[firstnumber=last]
2 ** 10 == 1024;
\end{urbiassert}

\item \lstinline|'=='(\var{that})|\\
  Whether \lstinline|this| equals \var{that}.
\begin{urbiassert}[firstnumber=last]
  1 == 1;
!(1 == 2);
\end{urbiassert}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  Orderable lst acos arccosine asin arcsine asString atan bitand
% LocalWords:  arctangent bitwise bitor compl sqrt trunc asFloat sqr sgn rshift
% LocalWords:  lshift eq
