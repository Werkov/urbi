\section{Float}

Float is an \us primitive to represent floating point number.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Comparable}
\item \refObject{Orderable}
\item \refObject{RangeIterable}
\end{itemize}

\subsection{Construction}

The most common way to create fresh floats is by using the literal
syntax presented in \autoref{sec:us-syn-lit-float}. A null float can
also be obtained with \lstinline|Float|'s \lstinline|new| method.

\begin{urbiscript}
Float.new;
[00000000] 0
\end{urbiscript}

\subsection{Methods}

\begin{itemize}
\item \lstinline|abs|\\
  Absolute value of the target.
\begin{urbiscript}[firstnumber=last]
assert((-5).abs == 5);
assert(  0 .abs == 0);
assert(  5 .abs == 5);
\end{urbiscript}

\item \lstinline|acos|\\
  Arccosine of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.acos == pi/2);
assert(1.acos == 0);
\end{urbiscript}

\item \lstinline|asBool|\\
  Whether non null.
\begin{urbiscript}[firstnumber=last]
assert(0.asBool == false);
assert(0.1.asBool == true);
assert((-0.1).asBool == true);
assert(inf.asBool == true);
assert(nan.asBool == true);
\end{urbiscript}

\item \lstinline|asFloat|\\
  Return the target.
\begin{urbiscript}[firstnumber=last]
assert(51.asFloat == 51);
\end{urbiscript}

\item \lstinline|asList|\\
  Bounces to \lstinline|seq|.  It is therefore possible to use the
  various flavors of \lstinline|for|-rang loops on integers:
\begin{urbiscript}[firstnumber=last]
{
  var res;

  res = [];
  for (var i : 3)
    res << i;
  assert(res == [0, 1, 2]);

  res = [];
  for|(var i : 3)
    res << i;
  assert(res == [0, 1, 2]);

  res = [];
  for&(var i : 3)
    res << i;
  assert(res.sort == [0, 1, 2]);
};
\end{urbiscript}%>>

\item \lstinline|asin|\\
  Arcsine of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.asin == 0);
\end{urbiscript}

\item \lstinline|asString|\\
  Return a string representing the target.
\begin{urbiscript}[firstnumber=last]
assert(42.asString == "42");
\end{urbiscript}

\item \lstinline|atan|\\
  Return the arctangent of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.atan == 0);
assert(1.atan == pi/4);
\end{urbiscript}

\item \lstinline|'bitand'(\var{that})|\\
  The bitwise-and between \lstinline|this| and \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(3 bitand 6 == 2);
\end{urbiscript}

\item \lstinline|'bitor'(\var{that})|\\
  Bitwise-or between \lstinline|this| and \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(3 bitor 6 == 7);
\end{urbiscript}

\item \lstinline|clone|\\
  Return a fresh Float with the same value as the target.
\begin{urbiscript}[firstnumber=last]
var x = 0;
[00000000] 0
var y = x.clone;
[00000000] 0
x === y;
[00000000] false
\end{urbiscript}

\item \lstinline|compl|\\
  The complement to 1 of the target.
\begin{urbiscript}[firstnumber=last]
assert(compl 0 == 4294967295);
assert(compl 4294967295 == 0);
\end{urbiscript}

\item \lstinline|cos|\\
  Cosine of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.cos == 1);
assert(pi.cos == -1);
\end{urbiscript}

\item \lstinline|each(\var{fun})|\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, sequentially.
\begin{urbiscript}[firstnumber=last]
3.each(function (i) { echo(100 + i) });
[00000000] *** 100
[00000000] *** 101
[00000000] *** 102
for (var x : 3) { echo(x); sleep(20ms); echo (100 + x); };
[00000000] *** 0
[00000000] *** 100
[00000000] *** 1
[00000000] *** 101
[00000000] *** 2
[00000000] *** 102
\end{urbiscript}

\item \lstinline'each|(\var{fun})'\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, with tight sequentiality.
\begin{urbiscript}[firstnumber=last]
{
  var res = [];
  3.'each|'(function (i) { res << 100 + i });
  assert(res == [100, 101, 102]);
};

{
  var res = [];
  for|(var x : 3) { res << x; sleep(20ms); res << (100 + x); };
  assert(res == [0, 100, 1, 101, 2, 102]);
};
\end{urbiscript}%>>>>>>

\item \lstinline|each&(\var{fun})|\\
  Call the functional argument \var{fun} on every integer from 0 to
  target - 1, concurrently.
\begin{urbiscript}[firstnumber=last]
{
  var res = [];
  for& (var x : 3) { res << x; sleep(30ms); res << (100 + x) };
  assert(res == [0, 1, 2, 100, 101, 102]);
};
\end{urbiscript}%>>>>

\item \lstinline|exp|\\
  Exponential of the target.
\begin{urbiscript}[firstnumber=last]
1.exp;
[00000000] 2.71828
\end{urbiscript}

\item \lstinline|format(\var{finfo})|\\
  Format according to the \refObject{FormatInfo} object \var{finfo}.
  The precision, \lstinline|\var{finfo}.precision, sets the maximum
  number of digits after decimal point when in fixed or scientific
  mode, and in total when in default mode.  Beware that 0 plays a
  special role, as it is not a ``significant'' digit.
\begin{urbiscript}[firstnumber=last]
assert("%1.0d" % 0.1 == "0.1");
assert("%1.0d" % 1.1 == "1");

assert("%1.0f" % 0.1 == "0");
assert("%1.0f" % 1.1 == "1");
\end{urbiscript}

\item \lstinline|inf|\\
  Return the infinity.
\begin{urbiscript}[firstnumber=last]
Float.inf;
[00000000] inf
\end{urbiscript}

\item \lstinline|log|\\
  The logarithm of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.log == -inf);
assert(1.log == 0);
assert(1.exp.log == 1);
\end{urbiscript}

\item \lstinline|nan|\\
  The ``not a number'' special float value.  More precisely, this
  returns the ``quiet NaN'', i.e., it is propagated in the various
  computations, it does not raise exceptions.
\begin{urbiscript}[firstnumber=last]
Float.nan;
[00000000] nan
(Float.nan + Float.nan) / (Float.nan - Float.nan);
[00000000] nan
\end{urbiscript}

A {NaN} has one distinctive property over the other Floats: it is
equal to no other float, not even itself.  This behavior is mandated
by the \wref[IEEE_754-2008]{IEEE 754-2008} standard.
\begin{urbiscript}[firstnumber=last]
assert({ var n = Float.nan; n === n});
assert({ var n = Float.nan; n  != n});
\end{urbiscript}

\item \lstinline|random|\\
  A random integer between 0 and the target.
\begin{urbiscript}[firstnumber=last]
for (3)
  echo(5.random);
[00000000] *** 3
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

\item \lstinline|round|\\
  The target, rounded to the nearest integer.
\begin{urbiscript}[firstnumber=last]
assert(1.6.round == 2);
assert(1.4.round == 1);
\end{urbiscript}

\item \lstinline|seq|\\
  The sequence of integers from 0 to \lstinline|this| - 1 as a list.
\begin{urbiscript}[firstnumber=last]
assert(3.seq == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|sgn|\\
  Return 1 if \lstinline|this| is positive, 0 if it is null, -1
  otherwise.
\begin{urbiscript}[firstnumber=last]
assert((-1164).sgn == -1);
assert(0.sgn       == 0);
assert((1164).sgn  == 1);
\end{urbiscript}

\item \lstinline|sin|\\
  The sine of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.sin == 0);
\end{urbiscript}

\item \lstinline|sqr|\\
  Square of the target.
\begin{urbiscript}[firstnumber=last]
assert(32.sqr == 1024);
\end{urbiscript}

\item \lstinline|sqrt|\\
  The square root of the target.
\begin{urbiscript}[firstnumber=last]
assert(1024.sqrt == 32);
\end{urbiscript}

\item \lstinline|tan|\\
  Tangent of the target.
\begin{urbiscript}[firstnumber=last]
assert(0.tan == 0);
(pi/4).tan;
[00000000] 1
\end{urbiscript}

\item \lstinline|times(\var{fun})|\\
  Call the functional argument \var{fun} \lstinline|this| times.

\begin{urbiscript}[firstnumber=last]
3.times(function () { echo("ping")});
[00000000] *** ping
[00000000] *** ping
[00000000] *** ping
\end{urbiscript}

\item \lstinline|trunc|\\
  Return the target truncated.
\begin{urbiscript}[firstnumber=last]
assert(1.9.trunc == 1);
assert((-1.9).trunc == -1);
\end{urbiscript}

\item \lstinline|'^'(\var{that})|\\
  Bitwise exclusive or between \lstinline|this| and \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(3 ^ 6 == 5);
\end{urbiscript}

\item \lstinline|'>>'(\var{that})|\\%>>
  \lstinline|this| shifted by \var{that} bits towards the right.
\begin{urbiscript}[firstnumber=last]
assert(4 >> 2 == 1);
\end{urbiscript}

\item \lstinline|'<'(\var{that})|\\
  Whether \lstinline|this| is less than \var{b}. The other comparison
  operators (\lstinline|<=|, \lstinline|>|, \ldots) can thus also be
  applied on floats since Float inherits \refObject{Orderable}.
\begin{urbiscript}[firstnumber=last]
assert(  0 < 1);
assert(!(1 < 0));
\end{urbiscript}

\item \lstinline|'<<'(\var{that})|\\
  \lstinline|this| shifted by \var{that} bit towards the left.
\begin{urbiscript}[firstnumber=last]
assert(4 << 2 == 16);
\end{urbiscript}

\item \lstinline|'-'(\var{that})|\\
  \lstinline|this| subtracted by \var{b}.
\begin{urbiscript}[firstnumber=last]
assert(6 - 3 == 3);
\end{urbiscript}

\item \lstinline|'+'(\var{that})|\\
  The sum of \lstinline|this| and \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(1 + 1 == 2);
\end{urbiscript}

\item \lstinline|'/'(\var{that})|\\
  The quotient of \lstinline|this| divided by \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(50 / 10 == 5);
assert(10 / 50 == 0.2);
\end{urbiscript}

\item \lstinline|'%'(\var{that})|\\
  \lstinline|this| modulo \var{b}.
\begin{urbiscript}[firstnumber=last]
assert(50 % 11 == 6);
\end{urbiscript}

\item \lstinline|'*'(\var{that})|\\
  Product of \lstinline|this| by \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(2 * 3 == 6);
\end{urbiscript}

\item \lstinline|'**'(\var{that})|\\
  \lstinline|this| to the \var{that} power (${this}^{that}$).
\begin{urbiscript}[firstnumber=last]
assert(2 ** 10 == 1024);
\end{urbiscript}

\item \lstinline|'=='(\var{that})|\\
  Whether \lstinline|this| equals \var{that}.
\begin{urbiscript}[firstnumber=last]
assert(  1 == 1);
assert(!(1 == 2));
\end{urbiscript}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  Orderable lst acos arccosine asin arcsine asString atan bitand
% LocalWords:  arctangent bitwise bitor compl sqrt trunc asFloat sqr sgn rshift
% LocalWords:  lshift eq
