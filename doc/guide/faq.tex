\chapter{Frequently Asked Questions}
\label{sec:faq}

\section{Tools}
\paragraph{The server dies with ``stack exhaustion''}
Your program might be deeply recursive, or use large temporary
objects.  Use \option{--stack-size} to augment the stack size, see
\autoref{sec:tools:urbi}.

Note that one stack is allocated per ``light thread''.  This can
explain why programs that heavily rely on concurrency might succeed
where sequential programs can fail.  For instance the following
program is very likely to quickly exhaust the (single) stack.

\begin{urbiunchecked}
function consume (num)
{
  if (num)
    consume(num - 1) | consume(num - 1)
} |
consume (512);
\end{urbiunchecked}

But if you use \lstinline{&} instead of \lstinline{|}, then each
recursive call to \lstinline{consume} will be spawn with a fresh
stack, and therefore none will run out of stack space:

\begin{urbiunchecked}
function consume (num)
{
  if (num)
    consume(num - 1) & consume(num - 1)
} |
consume (512);
\end{urbiunchecked}

However your machine will run out of resources: this heavily
concurrent program aims at creating no less than $2^{513}$ threads,
about $2.68 \times 10^{156}$ (a 156-digit long number, by far larger
than the number of atoms in the observable universe, estimated to
$10^{80}$).

\section{\us}
\subsection{Objects lifetime}

\paragraph{How do I create a new Object derivative?}
Urbi is based on prototypes. To create a new Object derivative (which
will inherit all the Object methods), you can do:

\begin{urbiscript}
var myObject = Object.new;
[00000001] Object_0x76543210
\end{urbiscript}

\paragraph{How do I destroy an Object?}
There is no \lstinline{delete} in Urbi, for a number of reasons (see
\autoref{sec:k122:delete}).  Objects are deleted when they are no
longer used/referenced to.

In practice, users who want to ``delete an object'' actually want to
remove a slot --- see \autoref{sec:tut:objects}.  Users who want to
clear an object can empty it --- see \autoref{sec:k122:delete}.

Note that \lstinline{myObject = nil} does not explicitly destroy the
object bound to the name \lstinline{myObject}, yet it may do
so provided that \lstinline{myObject} was the last and only reference
to this object.

\subsection{Slots and variables}

\paragraph{How do I add a new slot in an object?}
To add a slot to an object \lstinline{O}, you have to use the
\lstinline{var} keyword, which is syntactic sugar for the
\lstinline{setSlot} method:

\begin{urbiscript}
var O2 = Object.new |
// Syntax...
var O2.mySlot1 = 42;
[00000001] 42

// and semantics.
O2.setSlot("mySlot2", 23);
[00000001] 23
\end{urbiscript}

Note that in a method, \lstinline{this} designates the current
object.  It is needed to distinguish the name of a slot in the current
object, versus a local variable name:

\begin{urbiscript}[firstnumber=last]
{
  // Create a new slot in the current object.
  var this.foo = 42;

  // Create a local variable, which will not be known anymore
  // after we exit the current scope.
  var bar = 23;
}|
bar;
[00000001:error] !!! lookup failed: bar
foo;
[00000001] 42
\end{urbiscript}


\paragraph{How do I modify a slot of my object?}

Use the \lstinline|=| operator, which is syntactic sugar for the
\lstinline|updateSlot| method.

\begin{urbiscript}[firstnumber=last]
class O
{
  var mySlot = 42;
}|
// Sugarful.
O.mySlot = 51;
[00000001] 51

// Sugarfree.
O.updateSlot("mySlot", 23);
[00000001] 23
\end{urbiscript}

\paragraph{How do I create or modify a local variable?}
Use \lstinline|var| and \lstinline|=|.

\begin{urbiscript}[firstnumber=last]
// In two steps: definition, and initial assignment.
var myLocalVariable;
myLocalVariable = "foo";
[00000001] "foo"
// In a single step: definition with an initial value.
var myOtherLocalVariable = "bar";
[00000001] "bar"
\end{urbiscript}


\paragraph{How do I make a constructor?}
You can define a method called \lstinline{init} which will be called
automatically by \lstinline{new}. For example:

\begin{urbiunchecked}
class myObject {
  function init(x, y) {
    var this.x = x;
    var this.y = y;
  };
};
myInstance = myObject.new(10, 20);
\end{urbiunchecked}


\paragraph{How can I manipulate the list of prototypes of my objects?}
The \lstinline{protos} method returns a list (which can be manipulated)
containing the list of your object prototype.

\begin{urbiunchecked}
var myObject = Object.new;
myObject.protos;
[00000001] [Object]
\end{urbiunchecked}

\paragraph{How can I know the slots available for a given object?}
The \lstinline{localSlotNames} and \lstinline{allSlotNames} methods
return respectively the local slot names and the local+inherited slot
names.

\paragraph{How do I create a new function?}
Functions are first class objects. That means that you can add them as
any other slot in an object:

\begin{urbiunchecked}
var myObject = Object.new;
var myObject.myFunction = function (x, y)
  { echo ("myFunction called with " + x + " and " + y) };
\end{urbiunchecked}

You can also use the following notation to add a function to your
object:

\begin{urbiunchecked}
var myObject = Object.new;
function myObject.myFunction (x, y) { /* ... */ };
\end{urbiunchecked}

\noindent
or even group definitions within a \lstinline{do} scope, which will
automatically define new slots instead of local variables and
functions:

\begin{urbiunchecked}
var myObject = Object.new;
do (myObject) {
  function myFunction (x, y) { /* ... */ };
};
\end{urbiunchecked}

\noindent
or group those two statements by using a convenient \lstinline{class}
scope:

\begin{urbiunchecked}
class myObject {
  function myFunction (x, y) { /* ... */ };
};
\end{urbiunchecked}


\subsection{Tags}
\paragraph{How do I create a tag?}
See \autoref{stdlib:tag:ctor}.

\paragraph{How do I stop a tag?}

Use the \lstinline|stop| method.
\begin{urbiunchecked}
myTag.stop;
\end{urbiunchecked}

\paragraph{Can tagged statements return a value?}
By default, tagged statements will return the latest evaluated expression if
they have not been stopped:

\begin{urbiunchecked}
var myTag = Tag.new;
var res;
res = { myTag: { do_something; 42 } };
\end{urbiunchecked}

After the execution, \lstinline{res} will contain 42.

However, when a tag is stopped, all the statements tagged with that
tag may be forced to return a value, by giving it as a parameter to
\lstinline{stop}:

\begin{urbiunchecked}
var myTag = Tag.new;
var res;
{ res = { myTag: sleep(inf) } }, // Sleep forever (infinite amount of time),
                                 // note the "," to put the tagged statement in
                                 // the background
myTag.stop(42);
res;
[00000001] 42
\end{urbiunchecked}

\subsection{Events}
\paragraph{How do I create an event?}
Events are objects, and must be created as any object by using
\lstinline{new} to create derivatives of the \lstinline{Event} object.

\begin{urbiunchecked}
var ev = Event.new;
\end{urbiunchecked}

\paragraph{How do I emit an event?}
Use the \lstinline|!| operator.

\begin{urbiunchecked}
ev!(1, "foo");
\end{urbiunchecked}

\paragraph{How do I catch an event?}

Use the \lstinline|at(\var{event}?\var{args})| construct.

\begin{urbiunchecked}
at(ev?(1, var msg))
  echo ("Received event with 1 and message " + msg);
\end{urbiunchecked}

The \lstinline{?} marker indicates that we are looking for an event
instead of a boolean condition. The construct \lstinline{var msg}
indicates that the \lstinline{msg} variable will be bound (as a local
variable) in the body part of the \lstinline{at} construct, with
whatever value is present in the event that triggered the
\lstinline{at}.

\subsection{Lists}
\paragraph{How can I iterate over a list?}

Use the \lstinline{for} construct (\autoref{sec:lang:for:each}), or
the \lstinline|each| method (\refObject{List}):

\begin{urbiscript}[firstnumber=last]
for (var i: [10, 11, 12]) echo (i);
[00000001] *** 10
[00000002] *** 11
[00000003] *** 12
\end{urbiscript}

\subsection{\lstinline|at| and \lstinline|waituntil| with expressions}
\label{sec:faq:atexp}
Because the development of \us was focused on other features, the
initial implementation for the \lstinline|waituntil(\var{cond})| and
the \lstinline|at(\var{cond})| features are expensive: the expressions
\var{cond} are repeatedly evaluated at every ``cycle''.  As a
consequence, \strong{the whole \us program is slowed down!}.  And of
course this considerably hinders the battery lifetime.

In the future, they will be evaluated only when they are likely to
change.

There are at least two means to avoid this problems.

\paragraph{Events}
The key \us feature for event-based programming are... events (see
\refObject{Event} and \autoref{sec:tut:events}).  The use of
\lstinline|at| and \lstinline|waituntil| with events is well
optimized, and incurs no cost on the whole program: it is effective
only when events are fired.

There, rather than observing the values of a variable for changes, it
is preferable to subscribe to the variable to be notified when it is
changed, and then to check that your conditions are verified.  For
instance, instead of the costly following program:

\begin{urbiscript}[firstnumber=last]
{
  var x = 0;
  at (x == 1)
    echo ("one!");
  for (var i : [0, 1, 2])
  {
    echo (i);
    x = i
  };
};
[00000003] *** 0
[00000003] *** 1
[00000003] *** one!
[00000003] *** 2
\end{urbiscript}

\noindent
use the following implementation:

\begin{urbiscript}[firstnumber=last]
{
  var x = 0;
  at (x->changed?)
    if (x == 1)
      echo ("one!");
  for (var i : [0, 1, 2])
  {
    echo (i);
    x = i
  };
};
[00000003] *** 0
[00000003] *** 1
[00000003] *** one!
[00000003] *** 2
\end{urbiscript}

You may also use the event guard using %
\lstinline|at (\var{event}? if \var{cond}|:

\begin{urbiscript}[firstnumber=last]
{
  var x = 0;
  at (x->changed? if x == 1)
      echo ("one!");
  for (var i : [0, 1, 2])
  {
    echo (i);
    x = i
  };
};
[00000003] *** 0
[00000003] *** 1
[00000003] *** one!
[00000003] *** 2
\end{urbiscript}

The optimization of \lstinline|waituntil(\var{cond})| can be done
similarly.

\paragraph{Loops}

Alternatively, \lstinline|waituntil| can be simulated with a
\lstinline|while|, but rather that looping intensively on an empty
body, you may \lstinline|sleep| for a little while, say 20ms.  This is
especially useful when there is no value that changes, such as the
creation of a new slot.

\begin{urbiscript}[firstnumber=last]
waituntil(Object.hasSlot("foo")) | echo (Object.foo),
var Object.foo = "foo"|;
[00000003] *** foo
\end{urbiscript}

\begin{urbiscript}[firstnumber=last]
while (!Object.hasSlot("bar"))
  sleep(20ms) |
echo (Object.bar),
var Object.bar = "bar"|;
sleep(100ms);
[00000003] *** bar
\end{urbiscript}

\section{UObjects}

\paragraph{urbi-launch fails with 'myuobject: file not found'. What can I do?}
If you are sure the file is there, the most probable cause is an
undefined symbol in your shared library. A libltdl quirk prevents us
from displaying a more accurate error message.  You can use a tool
named \command{ltrace} to obtain the exact error message.  Ltrace is a
standard package on most Linux distributions.  Run it with
\samp{ltrace -C -s 1024 urbi-launch ...}, and look for lines
containing \samp{dlerror} in the output. One will contain the exact
message that occurred while trying to load your shared library.

Under Mac OS X, the \code{DYLD\_PRINT\_APIS} environment variable can
be set to 1 to make the shared library loader more verbose and display
all its attempts to load a file to stderr.

Note that this problem is Mac OS X and Linux specific.

\section{Miscellaneous}
\paragraph{How can I know what has changed since the latest beta release I got?}
The file \file{RELEASE-NOTES.txt} at the top of the distribution
contains the list of user-visible changes between consecutive
releases.

\paragraph{How do I report a bug?}
See the file \file{REPORTING-BUGS.txt} at the top of the
distribution. We insist on keeping \email{k2-beta@lists.gostai.com} in
copy at all times, because it helps us to track conversations with our
users.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "urbi-sdk"
%%% End:
