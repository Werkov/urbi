#! /usr/bin/perl -w

# Read a LaTeX file, and extract chk files for each urbiscript
# environment listing.  The label is used to name the created chk
# file.  If there is no label, FILE:LINE is used to name the file.
#
# lstlisting has a notion of split listing, using the attribute "name"
# to decide how pieces must be glued together (this is used when
# numbering).  Listings with the same "name" are glued togeter.  This
# is especially needed when a listing uses objects defined in earlier
# listings.
#
# Another means to glue together urbiscript snippets is to use the
# attribute firstnumber=last in the snippet that should be fused with
# the previous one.

use strict;
use English;
use IO::File;
use File::Path qw(mkpath rmtree);

# All the tests.
my %chk;

# Those with a name.
my %by_name;

# The name of the previous test.
my $previous_label = undef;

# A regexp that matches 0 or more repetitions of either a
# non-backtracking word with no parens/braces, or a braced group, or a
# parenthezied group.
#
# Note that since it is greedy and non-backtracking, it might eat too
# much.  Use $braced instead.
my $balanced;
$balanced =
  qr{
       (?:
          (?> [^(){}\[\]]+ )         # Non-parens/braces without backtracking
        |
          \( (??{ $balanced }) \)     # Group with matching parens
        |
          \{ (??{ $balanced }) \}     # Group with matching braces
        |
          \[ (??{ $balanced }) \]     # Group with matching brackets
       )*
    }x;

# Same as above, but allow backtracking on non-braced parts, so that
# we don't eat places where we want to catch operators.
my $braced =
  qr{
      (?:
          \{ $balanced \}
        | \( $balanced \)
        | \[ $balanced \]
        | [^(){}\[\]]+        # Non-parens/braces with backtracking
      )*
    }x;

# The (Boolean) operators in urbiScript.  Beware of operators "nested"
# in other operators: we must not cut "===" into "==" as operator, and
# "=" as lhs or rhs.
my $operators =
  qr{
      (?<![!=])
      (?:
         [!=]={1, 2} # ==, ===, !=, !==.
       | [<>]=?      # <, <=, >, >=.
       | =?~=        # =~=, ~=.
      )
      (?![=])
    }x;

# strip $STRING
# -------------
# Kill leading/trailing spaces.
sub strip ($)
{
  local ($_) = @_;
  s/^\s+//;
  s/\s+$//g;
  $_;
}

# lineno
# ------
# Issue an urbiScript //#line for test $lst.
sub lineno (\%)
{
  my ($lst) = @_;
  my $line = $$lst{_line};
  my $file = $$lst{_file};
  "clog << \"$file:$line\";\n"
  . "//#line $line \"$file\"\n"
}

# register ($FILE, $LINE, \%LST)
# ------------------------------
# Register a listing.
sub register ($$\%)
{
  my ($file, $line, $lst) = @_;
  # If this listing has a name which is already used, append to
  # this existing listing.
  my $name = $$lst{name};
  if ($name)
    {
      if ($by_name{$name})
        {
          $by_name{$name}{_contents} .=
            "\n\n"
            . lineno(%$lst)
            . $$lst{_contents};
          return;
        }
      else
        {
          $by_name{$name} = $lst;
        }
    }

  my $label = $$lst{label};
  if ($chk{$label})
    {
      # Collision.
      print STDERR
        "warning: label `$label' defined twice\n",
        "  $chk{$label}{_location}: first definition\n",
        "  $file:$line: second definition\n";
    }
  elsif (exists $$lst{firstnumber}
         && $$lst{firstnumber} eq "last")
    {
      # Extension of the previous listing.
      die "$file:$line: [firstnumber=last] used without preceding listing\n"
        unless defined $previous_label;
      $chk{$previous_label}{_contents} .=
        "\n\n"
        . lineno(%$lst)
        . $$lst{_contents};
    }
  else
    {
      $chk{$label} = $lst;
      $previous_label = $label;
    }
}

sub assert_name($)
{
  my ($op) = @_;
  my %op =
    (
     '!='  => 'ne',
     '!==' => 'mne',
     '<'   => 'lt',
     '<='  => 'le',
     '=='  => 'eq',
     '===' => 'meq',
     '>'   => 'gt',
     '>='  => 'ge',
    );
  "assert_" . $op{$op};
}

sub process_listing ($$$)
{
  my ($file, $line, $lst) = @_;
#  print STDERR "[[[$lst]]]\n";

  my $loc = "$file:$line";
  my %res;
  $res{'_file'} = $file;
  $res{'_line'} = $line;
  $res{'_location'} = $loc;

  $lst =~
     /
       \\begin{urbiscript}
       (?:\[((?:[^\[\]]|\[[^\]]*\])*)\])?  # $1 optional options.
                    # Optional argument may include `[...]'.
       \n
       (.*)\n                 # $2 contents
       \\end{urbiscript}
     /xs;

  $res{'_contents'} = $2;
  my $options = $1;

#  print STDERR "$2\n";

  # assert_eq is clearer when there are failures, but it is not nice
  # looking in the documentation.  Beware of === and !== that contain
  # ==.
  #
  # Be also woried about precedence.  1 < 2 == true should not be
  # cut on `<'.  I don't feel like parsing urbi in Perl...
  $res{'_contents'} =~
    s{^(\s*)                 # $1 indentation
       assert
       \s*\(
       ($braced)             # $2 lhs
       \s*
       (?<![!=])
       (<|<=|>|>=|!=|==|===|!==)     # $3 operator
       (?![=])\s*}
     { $1 . assert_name($3) . '(' . strip ($2) . ", "}gmsex;

  # Decode and normalize the options.
  if ($options)
  {
    foreach my $opt (split (/\s*,\s*/, $options))
    {
      $opt =~ /(\w+)\s*=\s*(.*)/;
      $res{$1} = $2;
    }
  }

  # If there is no label defined, use the location.
  if (defined $res{label})
  {
    # Get rid of the "lst:" prefix from the labels.
    $res{label} =~ s/^lst://;
    # float-new -> new, since we're in float/ anyway.
    (my $base = $file) =~ s,.*/,,;
    $base =~ s,\..*,,;
    $res{label} =~ s/^$base-//;
  }
  else
  {
    $res{label} = $res{_location};
    # Remove the directory part of the file.
    $res{label} =~ s,^.*/,,;
    $res{label} =~ s/\.tex//;
  }

  # Make dislikes colon in file names.
  $res{label} =~ s/:/-/g;

  # Clean up the contents.
  $res{_contents} =~ s/:hide\]/\]/g;

  return %res;
}

sub process_file ($)
{
  my ($file) = @_;
  my $in = new IO::File $file
      or die "cannot open $file";
  local $_;
  my $test;
  my $line;
  while ($_ = $in->getline)
  {
    if (/^\\begin{urbiscript}/ .. /^\\end{urbiscript}/)
    {
      if (/^\\begin{urbiscript}/)
      {
        # Issue a #line for the first line of Urbi, not the LaTeX line.
        $line = $in->input_line_number + 1;
        $test = $_;
      }
      elsif (!/^\\end{urbiscript}/)
      {
        $test .= $_;
      }
      else # \end{urbiscript}
      {
        $test .= $_;
        my %res = process_listing $file, $line, $test;
        register ($file, $line, %res);
      }
    }
  }
}

# dump_chk $DIR
# -------------
# Generate all the *chk files and there associated test.mk.
sub dump_chk ($)
{
  my ($dir) = @_;
  my @file;
  for my $k (keys %chk)
  {
    my %c = %{$chk{$k}};
    my $file = "$dir/$c{label}.chk";
    push @file, $file;
    my $out = new IO::File ">$file.tmp"
        or die "cannot create $file.tmp: $!";
    print $out lineno(%c);
    print $out "$c{_contents}\n";
    system ("$ENV{move_if_change} -s -I '^//' $file.tmp $file") == 0
      or die "$ENV{move_if_change} failed: $?";
  }
  my $local_mk = "$dir/test.mk";
  my $mk = new IO::File ">$local_mk"
      or die "cannot create $local_mk: $!";
  # Do not include the ../.. stuff in the Makefile.
  @file = map { s,^$ENV{srcdir}/,,; $_ } @file;
  # Output in order.  It would be nice to have a combinaison between
  # alphabetical and numerical, so that abc-2 < abc-10.
  @file = sort @file;
  print $mk join ("\t\\\n  ", "TESTS += ", @file), "\n";
}

process_file $ARGV[0];
# The directory we will output the tests in.
my $dir = $ARGV[0];
$dir =~ s,^$ENV{srcdir},$&/tests,;
$dir =~ s/\.tex$//;

# FIXME: Find a means to remove the old ones.
# rmtree $dir
#  if -d $dir;
if (! -d $dir)
{
  mkpath $dir
    or die "cannot mkpath $dir: $!";
}
dump_chk $dir;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
