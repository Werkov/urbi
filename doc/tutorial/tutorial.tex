\chapter{Getting started}

\us comes with a set of tools, two of which being of particular
importance:
\begin{description}
\item[\dfn{urbi}] launches an \urbi server.  There are several means
  to interact with it, which we will see later.
\item[\dfn{urbi-launch}] runs \urbi components, the UObjects, and connects
  them to an \urbi server.
\end{description}

Please, first make sure that these tools are properly installed.  If
you encounter problems, please see \autoref{sec:installation}, which
is more detailed, and possibly \autoref{sec:faq} for frequently asked
questions.

\begin{shell}
# Make sure urbi is properly installed.
$ urbi --version
Urbi Kernel version preview/2.0/beta3-425 rev. 000913e
Copyright (C) 2005-2009 Gostai SAS.

URBI SDK Remote version preview/1.6/beta1-666 rev. 92ec3b4
Copyright (C) 2004-2009 Gostai SAS.

Libport version preview/1.0/beta1-1048 rev. f1c5170
Copyright (C) 2005-2009 Gostai SAS.
\end{shell}%$


There are several means to interact with a server spawned by
\command{urbi}, see \autoref{sec:tools:urbi} for details.  First of
all, you may use the options
\option{-e}/\option{--expression \var{code}} and
\option{-f}/\option{--file \var{file}} to send some \var{code} or the
contents of some \var{file} to the newly run server.  You may combine
any number of these options, but beware that being event-driven, the
server does not ``know'' when a program ends.  Therefore, batch
programs should end by calling \lstinline{shutdown}:

\begin{shell}[alsolanguage={[interactive]Urbi}]
# A classical program.
$ urbi -e 'echo("Hello, World!");' -e 'shutdown;'
[00000004] *** Hello, World!
\end{shell}%$

To run an interactive session, use option
\option{-i}/\option{--interactive}.  Like most interactive
interpreters, \urbi will evaluate the given commands and print out the
results.

\begin{shell}[alsolanguage={[interactive]Urbi}]
$ urbi -i
[00000000:start] *** **********************************************************
[00000000:start] *** Urbi Kernel version preview/2.0/beta3-425 rev. 000913e
[00000000:start] *** Copyright (C) 2005-2009 Gostai SAS.
[00000000:start] ***
[00000000:start] *** URBI SDK Remote version preview/1.6/beta1-666 rev. 92ec3b4
[00000000:start] *** Copyright (C) 2004-2009 Gostai SAS.
[00000000:start] ***
[00000000:start] *** Libport version preview/1.0/beta1-1048 rev. f1c5170
[00000000:start] *** Copyright (C) 2005-2009 Gostai SAS.
[00000000:start] ***
[00000000:start] *** URBI comes with ABSOLUTELY NO WARRANTY.
[00000000:start] *** This software can be used under certain conditions;
[00000000:start] *** see LICENSE file for details.
[00000000:start] ***
[00000000:start] *** See http://www.urbiforge.com for news and updates.
[00000000:start] *** **********************************************************
[00000000:start] ***
[00000000:ident] *** ID: U3154688
[00000000:start] *** Urbi is up and running.
1+2;
[00000000] 3
shutdown;
\end{shell}%$

The output from the server is prefixed by a number surrounded by
square brackets: this is the date (in milliseconds since the server
was launched) at which that line was sent by the server. This is
useful at occasions, since \urbi is meant to run many parallel
commands.  But since these timestamps are irrelevant in most examples,
they will often be filled with zeroes through this documentation.

The program \command{rlwrap} provides additional services (history of
commands, advanced command line edition etc.); run \samp{rlwrap
  urbi -i}.

In either case the server can also be made available for network-based
interactions using option \option{--port \var{port}}.  Note that while
\lstinline{shutdown} asks the server to quit, \lstinline{quit} only
quits one interactive session.  In the following example the server is
still available for other, possibly concurrent, sessions.

\begin{shell}[alsolanguage={[interactive]Urbi}]
$ urbi --port 54000 &
[1] 77024
$ telnet localhost 54000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[00000758:start] *** **********************************************************
[00000758:start] *** Urbi Kernel version preview/2.0/beta3-425 rev. 000913e
[00000758:start] *** Copyright (C) 2005-2009 Gostai SAS.
[00000758:start] ***
[00000758:start] *** URBI SDK Remote version preview/1.6/beta1-666 rev. 92ec3b4
[00000758:start] *** Copyright (C) 2004-2009 Gostai SAS.
[00000758:start] ***
[00000758:start] *** Libport version preview/1.0/beta1-1048 rev. f1c5170
[00000758:start] *** Copyright (C) 2005-2009 Gostai SAS.
[00000758:start] ***
[00000758:start] *** URBI comes with ABSOLUTELY NO WARRANTY.
[00000758:start] *** This software can be used under certain conditions;
[00000758:start] *** see LICENSE file for details.
[00000758:start] ***
[00000758:start] *** See http://www.urbiforge.com for news and updates.
[00000758:start] *** **********************************************************
[00000758:start] ***
[00000758:ident] *** ID: U348160
12345679*8;
[00018032] 98765432
quit;
\end{shell}%$

The program \command{urbi-send} provides a nice interface to
interact with a running server.

\begin{shell}[alsolanguage={[interactive]Urbi}]
$ urbi-send -p 54000 -e '1+2*3;' -e 'quit;'
[00018032:] 7
# Have the server shutdown;
$ urbi-send -p 54000 -e 'shutdown;'
\end{shell}

\medskip

You can now send commands to your \urbi server. If at any point you
get lost, or want a fresh start, you can simply close and reopen your
connection to the server to get a clean environment.  In some cases,
particularly if you made global changes in the environment, it is
simpler start anew: shut your current server down, and spawn a new
one.

\chapter{First steps}

This section intends to provide the most basic notions to write \us
code. Some aspects are presented only superficially. The point of this
section is to bootstrap yourself with the \us language, to be able
to study more in-depth examples afterward.

\section{Comments\index{comment}}

Commenting your code is crucial, so let's start by learning how to do
this in \us. Comments are ignored by the interpreter, and
can be left as documentation, reminder, \ldots \us supports \C and
\Cxx style style comments:

\begin{itemize}
\item \C style comments start with \texttt{/*} and end with \texttt{*/}.
\item \Cxx style comments start with \texttt{//} and last until the
  end of the line.
\end{itemize}


\begin{urbiscript}
1; // This is a C++ style comment.
[00000000] 1
2 + /* This is a C-style comment. */ 2;
[00000000] 4
/* Contrary to C/C++, this type of comment /* does nest */. */
3;
[00000000] 3
\end{urbiscript}


\section{Literal values}

As already seen, we can evaluate literal integers. \us supports
several other literals, such as:

\begin{description}
\item[floats] floating point numbers.
\item[strings] character strings.
\item[lists] ordered collection of values.
\item[nil] neutral value. Think of it as the value that fits anywhere.
\item[void] absence of value. Think of it as the value that fits nowhere.
\end{description}

These literal values can be obtained with the syntax presented below.

\begin{urbiscript}
42; // Integer literal.
[00000000] 42
3.14; // Floating point number literal.
[00000000] 3.14
"string"; // Character string literal.
[00000000] "string"
[1, 2, "a", "b"]; // List literal.
[00000000] [1, 2, "a", "b"]
nil;
void;
\end{urbiscript}

This listing highlights some point:
\begin{itemize}
\item Lists in \us are heterogeneous. That is, one list can hold
  values of different types.
\item The printing of nil and void is empty.
\end{itemize}

\section{Function calls}

You can call functions with the classical, mathematical notation.

\begin{urbiscript}
cos(0); // Compute cosine
[00000000] 1
max(1, 3); // Get the maximum of the arguments.
[00000000] 3
max(1, 3, 4, 2);
[00000000] 4
\end{urbiscript}

Again, the result of the evaluation are printed out. You can see here
that function in \us can be variadic, that is, take different number
of arguments, such as the \lstinline{max} function. Let's now try the
\lstinline{echo} function, that prints out its argument.

\begin{urbiscript}
echo("Hello world!");
[00000000] *** Hello world!
\end{urbiscript}

The server prints out \lstinline{Hello world!}, as expected. Note that
this output is still prepended with the time stamp. Since echo returns
void, no evaluation result is printed.

\section{Variables\index{variable}}
Variables can be introduced with the \lstinline{var} keyword, given a
name and an initial value. They can be assigned new values with the
\lstinline{=} operator.

\begin{urbiscript}
var x = 42;
[00000000] 42
echo(x);
[00000000] *** 42
x = 51;
[00000000] 51
x;
[00000000] 51
\end{urbiscript}

Note that, just as in \Cxx, affectation returns the affected value, so
you can write code like ``\lstinline|x = y = 0|''. The rule for valid
identifiers is also the same as in \Cxx: they may contain alphanumeric
characters and underscores, but they may not start with a digit.

You may omit the initialization value, in which case it defaults to
\lstinline|void|.

\begin{urbiscript}
var x;
x;
// Remember, the interpreter remains silent
// because void is printed out as nothing.
// You can convince yourself that x is actually
// void with the following methods.
x.asString;
[00000000] "void"
x.isVoid;
[00000000] true
\end{urbiscript}

\section{Scopes\index{scope}}
Scopes can be introduced with curly brackets (\lstinline|{}|), and can
contain any number of expressions. Variables declared in a scope only
exist within this scope.

\begin{urbiscript}
{
  var x = "test";
  echo(x);
};
[00000000] *** test
// x is no longer defined here
\end{urbiscript}

Note that the interpreter waits for the whole scope to be inputted to
evaluate it. Also note the mandatory terminating semicolon after the
closing curly bracket.

\section{Method calls}

Methods are called on objects with the dot (\lstinline{.}) notation as in
\Cxx. Method calls can be chained. Methods with no arguments don't
require the parentheses.

\begin{urbiscript}
0.cos();
[00000000] 1
"a-b-c".split("-");
[00000000] ["a", "b", "c"]
// Empty parentheses are optional
"foo".length();
[00000000] 3
"foo".length;
[00000000] 3
// Method call can be chained
"".length.cos;
[00000000] 1
\end{urbiscript}

In \lstinline|obj.method|, we say that \lstinline{obj} is the
\dfn{target}, and that we are sending him the \lstinline{method}
\dfn{message}.

\section{Function definition}

You know how to call routines, let's learn how to write
some. Functions can be declared thanks to the \lstinline{function}
keyword, followed by the comma separated, parentheses surrounded list
of formal arguments, and the body between curly brackets.

\begin{urbiscript}
// Define myFunction
function myFunction()
{
  echo("Hello world");
  echo("from my function!");
};
[00000000] function () {
[:]  echo("Hello world");
[:]  echo("from my function!");
[:]}

// Invoke it
myFunction();
[00000000] *** Hello world
[00000000] *** from my function!
\end{urbiscript}

Note the strange output after you defined the function. \us seems to
be printing the function you just typed in again. This is because
a function definition evaluates to the freshly created function.

Functions are first class citizen: they are values, just as
\lstinline{0} or \lstinline{"foobar"}.  The evaluation of a function
definition yields the new function, and as always, the interpreter
prints out the evaluation result, thus showing you the function
again:

\begin{urbiscript}
// Work in a scope.
{
  // Define f
  function f()
  {
    echo("f");
  };
  // This does not invoke f
  // We are just evaluating it as a function
  f;
};
[00000000] function () {
[:]  echo("f");
[:]}
{
  // Define f
  function f()
  {
    echo("Hello World");
  };
  // This actually calls f
  f();
};
[00000000] *** Hello World
\end{urbiscript}

Here you can see that \lstinline{f} is actually a simple value. You can just
evaluate it to see its value, that is, its body. By adding the
parentheses, you can actually call the function. This is a difference
with methods calling, where empty parentheses are optional: method are
always evaluated, you cannot retrieve their functional value --- of
course, you can with a different construct, but that's not the point
here.

Since this output is often irrelevant, it is often hidden in this
documentation using the \lstinline'|{};' trick (or even
\lstinline'|;'): when evaluating \lstinline'\var{code} | {};', the
server first evaluates \var{code}, then evaluates \lstinline'{}' and
return its value, \lstinline'void', which prints to nothing.

\begin{urbiscript}
function sum(a, b, c)
{
  return a + b + c;
} | {};
sum(20, 2, 20);
[00000000] 42
\end{urbiscript}

The \lstinline{return} keyword enables to return a value from the
function. If no \lstinline{return} statement is executed, the
evaluation of the last expression is returned.

\begin{urbiscript}
function succ(i) { i + 1 } | {};
succ(50);
[00000000] 51
\end{urbiscript}

\section{Conclusion}

You're now up and running with basic \us code, and we can dive in
details into advanced \us code.

\chapter{Basic objects, \us values model} % FIXME: values model

In this section, we focus on urbi values as objects, and study \us
by-reference values model. We won't study classes and actual objective
programming yet, these points will be presented in
\autoref{section:objective}.

\section{Objects in \us}
\label{sec:tut:objects}
An object in \us is a rather simple concept: a list of slots. A
\dfn{slot} is a value associated to a name. So an \dfn{object} is a
list of slot names, each of which indexes a value --- just like a
dictionary. You can get an object's slot value by using the dot
(\lstinline{.}) operator on this object, followed by the name of the
slot. You can list the names of the slots of an object with the
\lstinline{slotNames} method.

\begin{urbiscript}
// Create a fresh object with two slots.
class Foo { var a = 42; var b = "foo"; };
[00000000] Foo
// Inspect it.
Foo.slotNames.sort;
[00000000] ["a", "asFoo", "b", "type"]
// We now know the name of its slots.
// Let's see their value.
Foo.a;
[00000000] 42
Foo.b;
[00000000] "foo"
\end{urbiscript}

It's as simple as this. Let's now try to build such an object. First,
we want a fresh object to work on. In \us, \lstinline{Object} is the
parent type of every object (in fact, since \us is prototype-based,
\lstinline{Object} is the uppermost prototype of every object, but
we'll talk about prototypes later). An instance of object, is an
empty, neutral object, so let's start by instantiating one with the
\lstinline{clone} method of \lstinline{Object}.

\begin{urbiscript}
// Create the o variable as a fresh object.
var o = Object.clone;
[00000000] Object_0x00000000
// Check its content
o.slotNames;
[00000000] []
\end{urbiscript}

As you can see, we obtain an empty fresh object. Note that it still
inherits from \lstinline{Object} features that all objects share, such as
the \lstinline{slotNames} method.

Also note how \lstinline{o} is printed out: \lstinline{Object\_}, followed by an
hexadecimal number. Since this object is empty, its printing is quite
generic: its type (\lstinline{Object}), and its unique identifier (every
\us object has one). Since these identifiers are often irrelevant
and might differ between two executions, they are often filled with
zeroes in this document.

We're now getting back to our empty object. We want to give it two
slots, \lstinline{a} and \lstinline{b}, with values \lstinline|42| and
\lstinline|"foo"| respectively. We can do this with the
\lstinline{setSlot} method, which takes the slot name and
its value.

\begin{urbiscript}
o.setSlot("a", 42);
[00000000] 42
o.slotNames;
[00000000] ["a"]
o.a;
[00000000] 42
\end{urbiscript}

Here we successfully created our first slot, a. A good shorthand for
setting slot is using the \lstinline{var} keyword.

\begin{urbiscript}
// This is equivalent to o.setSlot("b", "foo").
var o.b = "foo";
[00000000] "foo"
o.slotNames.sort;
[00000000] ["a", "b"]
o.b;
[00000000] "foo"
\end{urbiscript}

The latter form with \lstinline{var} is preferred, but you need to know
the name of the slot at the time of writing the code. With the former
one, you can compute the slot name at execution time. Likewise, you
can read a slot with a run-time determined name with the
\lstinline{getSlot} method, which takes the slot name as
argument.  The following listing illustrates the use of
\lstinline{getSlot} and \lstinline{setSlot} to read and write slots whose
names are unknown at code-writing time.

% mefyl: FIXME: I never introduced that '+' concatenates strings.

\begin{urbiscript}
function set(object, name, value)
{
  // We have to use setSlot here, since we don't
  // know the actual name of the slot.
  return object.setSlot("x_" + name, value);
} | {};
function get(object, name)
{
  // We have to use getSlot here, since we don't
  // know the actual name of the slot.
  return object.getSlot("x_" + name);
} | {};
var x = Object.clone;
[00000000] Object_0x00000000
set(x, "foo", 0);
[00000000] 0
set(x, "bar", 1);
[00000000] 1
x.slotNames.sort;
[00000000] ["x_bar", "x_foo"]
get(x, "foo");
[00000000] 0
get(x, "bar");
[00000000] 1
\end{urbiscript}

Right, now we can create fresh objects, create slots in them and read
them afterward, even if their name is dynamically computed, with
\lstinline{getSlot} and \lstinline{setSlot}. Now, you might wonder if
there's a method to update the value of the slot. Guess what, there's
one, and it's named\ldots \lstinline{updateSlot} (originality
award). Getting back to our \lstinline{o} object, let's try to update one
of its slots.

\begin{urbiscript}
o.a;
[00000000] 42
o.updateSlot("a", 51);
[00000000] 51
o.a;
[00000000] 51
\end{urbiscript}

Again, there's a shorthand for \lstinline{updateSlot}: operator
\lstinline{=}.

\begin{urbiscript}
o.b;
[00000000] "foo"
// Equivalent to o.updateSlot("b", "bar")
o.b = "bar";
[00000000] "bar"
o.b;
[00000000] "bar"
\end{urbiscript}

Likewise, prefer the '\lstinline{=}' notation whenever
possible, but you'll need \lstinline{updateSlot} to update a slot whose
name you don't know at code-writing time.

Note that defining the same slot twice, be it with \lstinline{setSlot} or
\lstinline{var}, is an error. The slot must be defined once with setSlot,
and subsequent writes must be done with \lstinline{updateSlot}.

\begin{urbiscript}
var o.c = 0;
[00000000] 0
// Can't redefine a slot like this
var o.c = 1;
[00000000:error] !!! slot redefinition: c
// Okay.
o.c = 1;
[00000000] 1
\end{urbiscript}

Finally, use \lstinline{removeSlot} to delete a slot from an object.

\begin{urbiscript}
o.slotNames.sort;
[00000000] ["a", "b", "c"]
o.removeSlot("c");
[00000000] Object_0x00000000
o.slotNames.sort;
[00000000] ["a", "b"]
\end{urbiscript}

Here we are, now you can inspect and modify objects at will. Don't
hesitate to explore \us objects you'll encounter through this
documentation like this. Last point: reading, updating or removing a
slot which does not exist is, of course, an error.

\begin{urbiscript}
o.d;
[00000000:error] !!! lookup failed: d
o.d = 0;
[00000000:error] !!! lookup failed: d
\end{urbiscript}

\section{Methods}

Methods in \us are simply object slots containing functions. We made a
little simplification earlier by saying that \lstinline|obj.slot| is
equivalent to \lstinline|obj.getSlot("slot")|: if the fetched value is
executable code such as a function, the dot form evaluates it, as
illustrated below. Inside a method, \lstinline|this| gives access to
the target --- as in \Cxx.  It can be omitted if there is no ambiguity
with local variables.

\begin{urbiscript}
var o = Object.clone;
[00000000] Object_0x0
// This syntax stores the function in the 'f' slot of 'o'.
function o.f ()
{
  echo("This is f with target " + this);
  return 42;
} | {};
// The slot value is the function.
o.getSlot("f");
[00000001] function () {
[:]  echo("This is f with target " . '+'(this));
[:]  return 42;
[:]}
// Huho, the function is invoked!
o.f;
[00000000] *** This is f with target Object_0x0
[00000000] 42
// The parentheses are in fact optional.
o.f();
[00000000] *** This is f with target Object_0x0
[00000000] 42
\end{urbiscript}

This was designed this way so as one can replace an attribute, such as
an integer, with a function that computes the value. This enables to
replace an attribute with a method without changing the object
interface, since the parentheses are optional.

This implies that getSlot can be a better tool for object inspection
to avoid invoking slots, as shown below.

\begin{urbiscript}
// The 'empty' method of strings return
// whether they're the empty string.
"foo".empty;
[00000000] false
"".empty;
[00000000] true
// Using getSlot, we can fetch the function
// without calling it
"".getSlot("empty");
[00000000] function () {
[:]  this . '=='("")
[:]}
\end{urbiscript}

So the empty function simply checks whether the target string is empty
with the equality operator! Let's try \lstinline{getSlot}'ing another method:

\begin{urbiscript}
"foo".size;
[00000000] 3
"foo".getSlot("size");
[00000000] Primitive_0x0
\end{urbiscript}

So the \lstinline{size} method of \refObject{String} is another type
of object, a \refObject{Primitive}. These objects are executable, like
functions, but they are actually primitives implemented in \Cxx. You
have thus no means to see their body.

\section{Everything is an object}

If you're wondering what is an object and what is not, the answer is
simple: every single bit of value you manipulate in \us is an
object, including primitive types, types themselves, functions, \ldots

\begin{urbiscript}
var x = 0;
[00000000] 0
x.slotNames;
[00000000] []
var x.slot = 1;
[00000000] 1
x.slotNames;
[00000000] ["slot"]
x.slot;
[00000000] 1
x;
[00000000] 0
\end{urbiscript}

% FIXME: I'm saying integer through this whole documentation, even
% though 42 is a float for now. But it will eventually be an integer
% (right? right?).
As you can see, integers are objects just like any other value.

\section{The \us values model}

We are now going to focus on the \us value model, that is how values
are stored and passed around. The whole point is to understand when
variables point to the same object.  For this, we introduce
\lstinline{uid}, a method that returns the target's unique identifier
--- the same one that was printed when we evaluated
\lstinline|Object.clone|.  Since uids might vary from an execution to
another, their values in this documentation are dummy, yet not null to
be able to differentiate them.

\begin{urbiscript}
var o = Object.clone;
[00000000] Object_0x1
o.uid;
[00000000] "0x1"
42.uid;
[00000000] "0x2"
42.uid;
[00000000] "0x3"
\end{urbiscript}

% FIXME: maybe should I introduce == and other basic operator before.
Our objects have different uids, reflecting the fact that they are
different objects. Note that inputting the same integer twice
(\lstinline{42} here) yields different objects. Let's introduce new
operators before diving in this concept. First the equality operator:
\lstinline{==}. This operator is the exact same as \C or \Cxx's one,
it simply returns whether its two operands are \emph{semantically}
equal. The second operator is \lstinline{===}, which is the
\emph{physical} equality operator. It returns whether its two operands
are the same object, which is equivalent to having the same uid. This
can seem a bit confusing; let's have an example.

\begin{urbiscript}
var a = 42;
[00000000] 42
var b = 42;
[00000000] 42
a == b;
[00000000] true
a === b;
[00000000] false
\end{urbiscript}

Here, the \lstinline{==} operator shows us that a and b are equal ---
indeed, they both evaluate to 42. Yet, the \lstinline{===} operator show
us that they are not the same object, that they are two different
instances of integers, even if they both equal 42.

Thanks to this operator, we can point out the fact that slots and
local variables in \us have a reference semantic. That is, when you
defining a local variable or a slot, you're not copying any value (as
you would be in \C or \Cxx), you're only making it refer to an already
existing value (as you would in \ruby or \java).

\begin{urbiscript}
var a = 42;
[00000000] 42
var b = 42;
[00000000] 42
var c = a; // c refers to the same object as a.
[00000000] 42
// a, b and c are equal: they have the same value.
a == b && a == c;
[00000000] true
// Yet only a and c are actually the same object.
a === b;
[00000000] false
a === c;
[00000000] true
\end{urbiscript}

So here we see that \lstinline|a| and \lstinline|c| point to the same
integer, while \lstinline|b| points to a second one. This a
non-trivial fact: any modification on \lstinline|a| will affect
\lstinline|c| as well, as shown below.

\begin{urbiscript}
a.slotNames;
[00000000] []
b.slotNames;
[00000000] []
c.slotNames;
[00000000] []
var a.flag; // Create a slot in a.
a.slotNames;
[00000000] ["flag"]
b.slotNames;
[00000000] []
c.slotNames;
[00000000] ["flag"]
\end{urbiscript}

Updating slots or local variables does not update the referenced
value. It simply redirects the variable to the new given value.

\begin{urbiscript}
var a = 42;
[00000000] 42
var b = a;
[00000000] 42
// b and a point to the same integer.
a === b;
[00000000] true
// Updating b won't change the referred value, 42,
// it makes it reference a fresh integer with value 51.
b = 51;
[00000000] 51
// Thus, a is left unchanged:
a;
[00000000] 42
\end{urbiscript}

Understanding the two latter examples is really important, to be aware
of what your variable are referring to.

Finally, function and method arguments are also passed by reference:
they can be modified by the function.

\begin{urbiscript}
function test(arg)
{
  var arg.flag;  // add a slot in arg
  echo(arg.uid); // print its uid
} | {};
var x = Object.clone;
[00000000] Object_0x1
x.uid;
[00000000] "0x1"
test(x);
[00000000] *** 0x1
x.slotNames;
[00000000] ["flag"]
\end{urbiscript}

Beware however that arguments are passed by reference, and the
behavior might not be what you may expected.

\begin{urbiscript}
function test(arg)
{
  // Updates the local variable arg to refer 1.
  // Does not affect the referred value, nor the actual external argument.
  arg = 1;
} | {};
var x = 0;
[00000000] 0
test(x);
[00000000] 1
// x wasn't modified
x;
[00000000] 0
\end{urbiscript}

\section{Conclusion}

You should now understand the reference semantic of local variables,
slots and arguments. It's very important to keep them in mind,
otherwise you will end up modifying variables you didn't want, or
change a copy of reference, failing to update the desired one.

\chapter{Flow control constructs}

In this section, we'll introduce some flow control structures that
will prove handy later. Most of them are inspired by \C/\Cxx.

\section{if}

The \lstinline{if} construct is the same has \C/\Cxx's one. The
\lstinline{if} keyword is followed by a condition between parentheses and
an expression, and optionally the \lstinline{else} keyword and another
expression. If the condition evaluates to true, the first expression
is evaluated. Otherwise, the second expression is evaluated if
present.

\begin{urbiscript}
if (true)
  echo("ok");
[00000000] *** ok
if (false)
  echo("ko")
else
  echo("ok");
[00000000] *** ok
\end{urbiscript}

The \lstinline|if| construct is an expression: it has a value.

\begin{urbiscript}
echo({ if (false) "a" else "b" });
[00000000] *** b
\end{urbiscript}

\section{while}

The \lstinline{while} construct is, again, the same as in \C/\Cxx. The
\lstinline{while} keyword is followed by a condition between parentheses
and an expression. If the expression evaluation is false, the
execution jumps after the while block; otherwise, the expression is
evaluated and control jumps before the while block.

% FIXME: += wasn't introduced
\begin{urbiscript}
var x = 2;
[00000000] 2
while (x < 40)
{
  x += 10;
  echo(x);
};
[00000000] *** 12
[00000000] *** 22
[00000000] *** 32
[00000000] *** 42
\end{urbiscript}

\section{for}

The \lstinline{for} keyword supports different constructs, as in
languages such as Java, \Cs, or even the forthcoming \Cxx revision.

The first construct is hardly more than syntactic suggar for a
\lstinline{while} loop.

\begin{urbiscript}
for (var x = 2; x < 40; x += 10)
  echo(x);
[00000000] *** 2
[00000000] *** 12
[00000000] *** 22
[00000000] *** 32
\end{urbiscript}

The second construct allows to iterate over members of a collection,
such as a list. The \lstinline{for} keyword, followed by
\lstinline|var|, an identifier, a semicolon (or \lstinline|in|), an
expression and a scope, executes the scope for every element in the
collection resulting of the evaluation of the expression, with the
variable named with the identifier referring to the list
elements.

\begin{urbiscript}
for (var e : [1, 2, 3]) { echo(e) };
[00000000] *** 1
[00000000] *** 2
[00000000] *** 3
\end{urbiscript}

\section{switch}

The syntax of the \lstinline|switch| construct is similar to \C/\Cxx's
one, except it works on any kind of object, not only integral
ones. Comparison is done by semantic equality (operator
\lstinline{==}). Execution will jump out of the
\lstinline|switch|-block after a case has been executed (no need to
\lstinline{break}).  Also, contrary to \Cxx, the whole construct has a
value: that of the matching \lstinline{case}.

\begin{urbiscript}
switch ("bar")
{
  case "foo":  0;
  case "bar":  1;
  case "baz":  2;
  case "qux":  3;
};
[00000000] 1
\end{urbiscript}

\section{do}
\label{section:constructs/do}

A do scope is a shorthand to perform several actions on an
object.

\begin{urbiscript}
var o = Object.clone;
[00000000] Object_0x0
var o.one = 1;
[00000000] 1
var o.two = 2;
[00000000] 2
echo(o.uid);
[00000000] *** 0x0
\end{urbiscript}

The same result can be obtained with a short \lstinline|do| scope, that redirect
method calls to their target, as in the listing below. This is
similar to the \pascal ``\lstinline{with}'' construct.  The value of
the \lstinline{do}-block is the target itself.

\begin{urbiscript}
var o = Object.clone;
[00000000] Object_0x0
// All the message in this scope are destined to o.
do (o)
{
 var one = 1; // var is a shortcut for the setSlot
 var two = 2; // message, so it applies on obj too.
 echo(uid);
};
[00000000] *** 0x0
[00000000] Object_0x0
\end{urbiscript}


%\section{Conclusion} FIXME?

\chapter{Advanced functions and scoping}

This section presents advanced uses of functions and scoping, as well
as their combo: lexical closures, which prove to be a very powerful
tool.

\section{Scopes as expressions}

Scope are expressions, just as \lstinline|1 + 1| or \lstinline|"foo"|.
They evaluate to the last expression they contain, or void if they're
empty. The following listing illustrates the use of scopes as
expressions. Note that the last semicolon inside a scope is optional.

\begin{urbiscript}
// scope evaluate to the
// last expression they contain
{ 1; 2; 3};
[00000000] 3
// They are expression
echo({1; 2; 3});
[00000000] *** 3
\end{urbiscript}

\section{Advanced scoping}

Scopes can be nested. Variables can be redefined in sub-scope. In this
case, the new variables hide the old one in this scope (that is, the
innermost variable takes precedence), as illustrated below.

\begin{urbiscript}
var x = 0; // Define the outer x.
[00000000] 0
{
  var x = 1; // Define an inner x.
  x = 2;     // These refer to
  echo(x);   // the inner x
};
[00000000] *** 2
x;           // This is the outer x again.
[00000000] 0
{
  x = 3;     // This is still the outer x.
  echo(x);
};
[00000000] *** 3
x;
[00000000] 3
\end{urbiscript}

\section{Local functions}

Functions can be defined anywhere local variables can --- that is,
about anywhere. These functions' visibility are limited to the scope
they're defined in, like variables. This enables for instance to write
local helper functions like ``max2'' in the example belox.

\begin{urbiscript}
function max3(a, b, c) // Max of three values
{
  function max2(a, b)
  {
    if (a > b)
      return a
    else
      return b
  };
  max2(a, max2(b, c));
} | {};
\end{urbiscript}

\section{Lexical closures}

A \dfn{closure} is the capture by a function of a variable external to this
function. \us supports lexical closure: functions can refer to outer
local variables, as long as they are visible (in scope) from where
the function is defined.

\begin{urbiscript}
function printSalaries(rate)
{
  var charges = 100;
  function computeSalary(hours)
  {
    // Here rate and charges are captured
    // from the environment by closure
    rate * hours - charges
  };

  echo("Alice's salary is " + computeSalary(35));
  echo("Bob's salary is " + computeSalary(30));
} | {};
printSalaries(15);
[00000000] *** Alice's salary is 425
[00000000] *** Bob's salary is 350
\end{urbiscript}

Closures can also write to captured variables, as shown below.

% Fixme: these are not actually closures because of the toplevel ...
\begin{urbiscript}
var x = 0;
[00000000] 0
var y = 0;
[00000000] 0
function add(n)
{
  // x and y are updated by closure
  x += n;
  y += n;
  void
} | {};
add(25);
add(25);
add(1);
x;
[00000000] 51
y;
[00000000] 51
\end{urbiscript}

Closure can be really powerful tools in some situation, and they are
even more useful when combined with functional programing, as
described in \autoref{section:functional}.

%\section{Conclusion}

\chapter{Objective programming, \us object model}
\label{section:objective}

% FIXME: this section content will soon become mostly crap

We are now at the point you waited for: object programing. We will
here study the prototype-based object model of \us, and how to
define and use classes.

\section{Prototype-based programing in \us}

You're probably already familiar with class-based object programing,
since this is the \Cxx model. Prototype-based object programing is
slightly different: it has no actual types. Instead, you have an
object, that is already an instance, and that you might clone to
obtain a new one that you can modify afterward. Prototype-based
programming was introduced by the Self language, and is used in
several popular script languages such as \io or \js.

Consider pairs for instance (see \refObject{Pair}). Pairs are objects
that hold two values,
first and second, like an \lstinline{std::pair} in \Cxx. Since \us is
prototype-based, there is no pair class. Instead, \lstinline|Pair| is
really a pair.

\begin{urbiscript}
Pair;
[00000000] (nil, nil)
\end{urbiscript}

We can see here that Pair is a pair whose two values are equal to nil
--- which is a reasonable neutral value. To get a pair of our own, we
simply clone \lstinline|Pair|. We can then use it as a
regular pair.

\begin{urbiscript}
var p = Pair.clone;
[00000000] (nil, nil)
p.first = "101010";
[00000000] "101010"
p.second = true;
[00000000] true
p;
[00000000] ("101010", true)
Pair;
[00000000] (nil, nil)
\end{urbiscript}

Since \lstinline|Pair| is a regular pair object, you can modify and
use it at will. Yet this is not a good idea, since you will alter your
base prototype, which alters any derivative, future or past.

\begin{urbiscript}
var before = Pair.clone;
[00000000] (nil, nil)
Pair.first = false;
[00000000] false
var after = Pair.clone;
[00000000] (false, nil)
before;
[00000000] (false, nil)
// before and after share the same first: that of Pair.
assert(Pair.first === before.first);
assert(Pair.first === after.first);
\end{urbiscript}

\section{Prototypes and slot lookup}

In prototype-based language, 'is-a' relations (being an instance of
some type) and inheritance relations (extending another type) are
simplified in a single relation: prototyping. You can inspect an
object prototypes with the \lstinline{protos} method.

\begin{urbiscript}
var p = Pair.clone;
[00000000] (nil, nil)
p.protos;
[00000000] [(nil, nil)]
\end{urbiscript}

As expected, our fresh pair has one prototype, \lstinline|(nil, nil)|,
which is Pair. We can check this as presented below.

\begin{urbiscript}
// Lists 'head' method returns the first element
p.protos.head;
[00000000] (nil, nil)
// We can make sure the prototype is really Pair
p.protos.head === Pair;
[00000000] true
\end{urbiscript}

Prototypes are the base of the slot lookup mechanism. Slot lookup is
the action of finding an object slot when \lstinline{getSlot} or the dot
notation is used. So far, when we typed \lstinline|obj.slot|, ``slot''
was always a slot of \lstinline|obj|.
Yet, this call can be valid even if obj has
no ``slot'' slot, because slots are also looked up in prototypes. For
instance, \lstinline|p|, our clone of \lstinline|Pair|, has no
``first'' or ``second'' slots. Yet, \lstinline|p.first| and
\lstinline|p.second| succeed because these slots are present in
\lstinline|Pair|, which is \lstinline|p|'s prototype. This is
illustrated below.

\begin{urbiscript}
var p = Pair.clone;
[00000000] (nil, nil)
// p has absolutely no slots.
p.slotNames;
[00000000] []
// Yet this works
p.first;
// This is because p has Pair for prototype,
// and Pair has a 'first' slot.
p.protos.head === Pair;
[00000000] true
"first" in Pair.slotNames && "second" in Pair.slotNames;
[00000000] true
\end{urbiscript}

As shown here, the \lstinline{clone} method simply creates an empty
object, with its target as prototype. The new object has the exact
same behavior as the cloned on thanks to slot lookup.

Let's experience slot lookup by ourselves. In \us, you can add and
remove prototypes from an object thanks to \lstinline{addProto} and
\lstinline{removeProto}.

\begin{urbiscript}
// We create a fresh object
var c = Object.clone;
[00000000] Object_0x1
// As expected, it has no 'slot' slot
c.slot;
[00000000:error] !!! lookup failed: slot
var p = Object.clone;
[00000000] Object_0x2
var p.slot = 0;
[00000000] 0
c.addProto(p);
[00000000] Object_0x1
// Now, slot is found in c,
// because it is inherited from p.
c.slot;
[00000000] 0
c.removeProto(p);
[00000000] Object_0x1
// Back to our good old lookup error
c.slot;
[00000000:error] !!! lookup failed: slot
\end{urbiscript}

The slot lookup algorithm in \us in a depth-first traversal of the
object prototypes tree. Formally, when the "s" slot is requested from
x:

\begin{itemize}
\item If x itself has the slot, the requested value is found.
\item Otherwise, the same lookup algorithm is applied on all
  prototypes, most recent first.
\end{itemize}

Thus, slots from the last prototype added take precedence over other
prototype's slots.

\begin{urbiscript}
var proto1 = Object.clone;
[00000000] Object_0x00000000
var proto2 = Object.clone;
[00000000] Object_0x00000000
var o = Object.clone;
[00000000] Object_0x00000000
o.addProto(proto1);
[00000000] Object_0x00000000
o.addProto(proto2);
[00000000] Object_0x00000000
// We give o an x slot through proto1
var proto1.x = 0;
[00000000] 0
o.x;
[00000000] 0
// proto2 is visited first during lookup.
// Thus its "x" slot take precedence over proto1's
var proto2.x = 1;
[00000000] 1
o.x;
[00000000] 1
// o's own slots still have the higher precedence
var o.x = 2;
[00000000] 2
o.x;
[00000000] 2
\end{urbiscript}

You can check where in the prototype hierarchy a slot is found with
the \lstinline{locateSlot} method. This is a very
handful tool when inspecting an object.

\begin{urbiscript}
var p = Pair.clone;
[00000000] (nil, nil)
// Check that the 'first' slot is found in Pair
p.locateSlot("first") === Pair;
[00000000] true
// Where does locateSlot itself come from? Object itself!
p.locateSlot("locateSlot");
[00000000] Object
\end{urbiscript}

You can see here that the prototype model is rather simple. Obtaining
a fresh object simply consist in cloning a model object, a prototype,
that was provided to you. Moreover, you can add behavior to an object
at any time with a simple \lstinline{addProto}: you can make any object a
fully functional Pair with a simple \lstinline|myObj.addProto(Pair)|.

\section{Copy on write}

One point might be bothering you though: what if you want to update a
slot value in a clone of your prototype?

Say we implement a simple prototype, with an "x" slot equal to
\lstinline|0|, and clone it twice. We have three object with an "x"
slot, yet only one actual \lstinline|0| integer. Will modifying x in
one of the clone change the prototype's "x", thus altering the
prototype and the other clone as well?

The answer is, of course, no, as illustrated below.

\begin{urbiscript}
var proto = Object.clone;
[00000000] Object_0x1
var proto.x = 0;
[00000000] 0
var o1 = proto.clone;
[00000000] Object_0x2
var o2 = proto.clone;
[00000000] Object_0x3
// Are we modifying proto's x slot here?
o1.x = 1;
[00000000] 1
// Obviously not
o2.x;
[00000000] 0
proto.x;
[00000000] 0
o1.x;
[00000000] 1
\end{urbiscript}

This work thanks to copy-on-write: slots are first duplicated to the
local object when they're updated, as we can check below.

\begin{urbiscript}
// This is the continuation of previous example.

// As expected, o2 finds "x" in proto
o2.locateSlot("x") === proto;
[00000000] true
// Yet o1 doesn't anymore
o1.locateSlot("x") === proto;
[00000000] false
// Because the slot was duplicated locally
o1.locateSlot("x") === o1;
[00000000] true
\end{urbiscript}

This is why, when we cloned Pair earlier, and modified the ``first''
slot of our fresh Pair, we didn't alter Pair one all its other clones.

% BIG FIXME: classes, classes ... c'mon, these are not classes but
% prototypes ...
\section{Defining classes}

Now that we know the internals of \urbi's object model, we can start
defining our own classes. For instance, we can define our own
\lstinline{Pair} class. We just have to create a pair, with its first and
second slots. For this we use the \lstinline{do} scope described in
\autoref{section:constructs/do}. The listing below defines a new
\lstinline{Pair} class. The \lstinline{asString} function is simply used to
customize pairs printing - don't give it too much attention for now.

\begin{urbiscript}
var MyPair = Object.clone;
[00000000] Object_0x1
do (MyPair)
{
  var first = nil;
  var second = nil;
  function asString ()
  {
    "MyPair: " + first + ", " + second
  };
} | {};
// We just defined a pair
MyPair;
[00000000] MyPair: nil, nil
// Let's try it out
var p = MyPair.clone;
[00000000] MyPair: nil, nil
p.first = 0;
[00000000] 0
p;
[00000000] MyPair: 0, nil
MyPair;
[00000000] MyPair: nil, nil
\end{urbiscript}

That's it, we defined a pair that can be cloned at will! \us
provides a shorthand to define classes as we did above: the
\lstinline{class} keyword.

\begin{urbiscript}
class MyPair
{
  var first = nil;
  var second = nil;
  function asString() { "(" + first + ", " + second + ")"; };
};
[00000000] (nil, nil)
\end{urbiscript}

The \lstinline{class} keyword simply creates MyPair with Object.clone,
and provides you with a \lstinline|do (MyPair)| scope. It actually also
predefines a few slots, but this is not the point here.

\section{Constructors}
\label{sec:tut:ctor}
As we've seen, we can use the clone method on any object to obtain an
identical object. Yet, some class provide more elaborated
constructors, accessible by calling \lstinline{new} instead of
\lstinline{clone}, potentially passing it arguments.

\begin{urbiscript}
var p = Pair.new("foo", false);
[00000000] ("foo", false)
\end{urbiscript}

While \lstinline{clone} guarantees you obtain a empty fresh object
inheriting from the prototype, \lstinline{new} behavior is left to the
discretion of the cloned prototype --- although its behavior is the
same as \lstinline{clone} by default.

To define such constructors, prototypes only need to provide an
\lstinline{init} method, that will be called with the arguments given to
new. For instance, we can improve our previous \lstinline{Pair} class
with a constructor.

\begin{urbiscript}
do (MyPair)
{
  function init(f, s)
  {
    first = f;
    second = s;
  }
};
[00000000] (nil, nil)
MyPair.new(0, 1);
[00000000] (0, 1)
\end{urbiscript}

%\section{Conclusion}

\chapter{Functional programming}
\label{section:functional}

\us support functional programming through first class functions and
lambda expressions.

\section{First class functions}

\us has first class functions. That is, function are regular values,
just like an integer or a string, enabling you to store them or pass
them as arguments. For instance, you don't need to write
\lstinline|function object.f(){/* ... */}| to insert a function in an
object, you can simply use \lstinline{setSlot}.

% FIXME: doesn't work, toplevel, puke, etc
\begin{urbiscript}
var o = Object.clone | {};
// Here we can use f as any regular value
o.setSlot("m1", function () { echo("Hello") }) | {};
// This is strictly equivalent
var o.m2 = function () { echo("Hello") } | {};
o.m1;
[00000000] *** Hello
o.m2;
[00000000] *** Hello
\end{urbiscript}

This enables to write powerful pieces of code, like functions that
take function as argument. For instance, consider the \lstinline{all}
function: given a list and a function, it applies the function to each
element of the list, and returns whether all calls returned true. This
enables to check very simply if all elements in a list verify a
predicate.

\begin{urbiscript}
function all(list, predicate)
{
  for (var elt : list)
    if (!predicate(elt))
      return false;
  return true;
} | {};
// Check if all elements in a list are positive.
function positive(x) { x >= 0 } | {};
all([1, 2, 3], getSlot("positive"));
[00000000] true
all([1, 2, -3], getSlot("positive"));
[00000000] false
\end{urbiscript}

It turns out that \lstinline|all| already exists: instead of
\lstinline|all(\var{list}, \var{predicate})|, use
\lstinline|\var{list}.all(\variables{predicate})|, see \refObject{List}.

\section{Lambda functions}

Another nice feature is the ability to write lambda functions, which
are anonymous functions. You can create a functional value as an
expression, without naming it, with the syntax shown below.

\begin{urbiscript}
// Create an anonymous function
function (x) {x + 1} | {};
// This enable to easily pass function
// to our "all" function:
[1, 2, 3].all(function (x) { x > 0});
[00000000] true
\end{urbiscript}

In fact, the \lstinline{function} construct we saw earlier is only a
shorthand for a variable assignment.

\begin{lstlisting}
// This ...
function obj.f (/*...*/) {/*...*/};
// ... is actually a shorthand for this
var obj.f = function (/*...*/) {/* ... */};
\end{lstlisting}

% This should maybe be outside the functional section. It is also
% incomplete.
\section{Lazy arguments}

Most popular programming languages use strict arguments evaluation:
arguments are evaluated before functions are called. Other languages
use lazy evaluation: argument are evaluated by the function only when
needed. In \us, evaluation is strict by default, but you can ask a
function not to evaluate its arguments, and do it by hand. This works
by not specifying formal arguments. The function is provided with a
\lstinline{call} object that enables you to evaluate arguments.

\begin{urbiscript}
// Note the lack of formal arguments specification
function first
{
  // Evaluate only the first argument.
  call.evalArgAt(0);
} | {};
first(echo("first"), echo("second"));
[00000000] *** first
function reverse
{
  call.evalArgAt(1);
  call.evalArgAt(0);
} | {};
reverse(echo("first"), echo("second"));
[00000000] *** second
[00000000] *** first
\end{urbiscript}

A good example are logic operators. Although \Cxx is a strict
language, it uses a few logic operators. For instance, the logical and
(\lstinline{&&}) does not evaluate its right operand if the left
operand is false (the result will be false anyway).

\us logic operator mimic this behavior. The listing below shows how
one can implement such a behavior.

\begin{urbiscript}
function myand
{
  var lhs = call.evalArgAt(0);
  if (lhs)
    return call.evalArgAt(1)
  else
    return false;
} | {};
function f()
{
  echo("f executed");
  return true;
} | {};
myand(false, f());
[00000000] false
myand(true, f());
[00000000] *** f executed
[00000000] true
\end{urbiscript}

%\section{Pattern matching}

\chapter{Parallelism, concurrent flows control}

Parallelism is one of the major features of \us. So far, all we've
seen already existed in other language - although we tried to pick,
mix and adapt features and paradigm to create a nice scripting
language. Parallelism is one of the corner stone of its paradigm, and
what makes it so adapted to high level scripting of interactive
agents, such as robotics or \ai.

\section{Parallelism operators}

For now, we've separated our different commands with a semicolon
(\lstinline{;}). There are actually other separators in \us:

\begin{itemize}
\item ``\lstinline{;}'': Serialization operator. Wait for the left
  operand to finish before continuing.
\item ``\lstinline{&}'': Parallelism n-ary operator. All operands are
  started simultaneously, and executed in parallel. The \lstinline{&}
  block itself finishes when both operands finish. \lstinline{&} has
  higher precedence than other separators.
\item ``\lstinline{,}'': Background operator. Left operand is started,
  and evaluation continues immediately. End of execution of the left
  operand is waited at the exit of the scope.
\end{itemize}

The listing below show usage of \lstinline{&} to
launch two functions in parallel.

\begin{urbiscript}
function test(name)
{
  echo(name + ": 1");
  echo(name + ": 2");
  echo(name + ": 3");
} | {};
// Serialized executions
test("left") ; test ("middle"); test ("right");
[00000000] *** left: 1
[00000000] *** left: 2
[00000000] *** left: 3
[00000000] *** middle: 1
[00000000] *** middle: 2
[00000000] *** middle: 3
[00000000] *** right: 1
[00000000] *** right: 2
[00000000] *** right: 3
// Parallel execution
test("left") & test("middle") & test ("right");
[00000000] *** left: 1
[00000000] *** middle: 1
[00000000] *** right: 1
[00000000] *** left: 2
[00000000] *** middle: 2
[00000000] *** right: 2
[00000000] *** left: 3
[00000000] *** middle: 3
[00000000] *** right: 3
\end{urbiscript}

In this test, we see that the \lstinline{&} runs its operands
simultaneously.

The difference between ``\lstinline{&}'' and ``\lstinline{,}'' is
rather subtle:

\begin{itemize}
\item In the top level, will wait for you to terminate your
  ``\lstinline{&}'' block to start executing anything, while it will
  run the code terminated by ``\lstinline{,}'' immediately.
\item Execution is blocked after a ``\lstinline{&}'' group until all
  its children have finished.
\end{itemize}

\begin{urbiscript}
function test(name)
{
  echo(name + ": 1");
  echo(name + ": 2");
  echo(name + ": 3");
} | {};
// Run test and echo("right") in parallel,
// and wait until both are done before continuing
test("left") & echo("right"); echo("done");
[00000000] *** left: 1
[00000000] *** right
[00000000] *** left: 2
[00000000] *** left: 3
[00000000] *** done
// Run test in background, then both echos without waiting.
test("left") , echo("right"); echo("done");
[00000000] *** left: 1
[00000000] *** right
[00000000] *** left: 2
[00000000] *** done
[00000000] *** left: 3
\end{urbiscript}

That's about all there is to say about these operators. Although
they're rather simple, they are really powerful and enables you to
include parallelism anywhere at no syntactical cost.

\section{Detach}

The \lstinline{detach} function backgrounds the execution of its
argument. Its behavior is the same as the comma (\lstinline{,}) operator,
except the execution is completely detached, and not waited for at the
end of the scope.

\begin{urbiscript}
function test()
{
  // wait 1 second, and echo "foo"
  detach({sleep(1s); echo("foo")});
} | {};
test();
echo("Not blocked");
[00000000] *** Not blocked
sleep(1s);
[00005000] *** foo
/*(*/sleep(200ms);/*)*/
\end{urbiscript}

\section{Tags for parallel control flows}
\label{sec:tut:tags}

Tags are a multipurpose code execution control and instrumentation
feature. Any chunk of code can be tagged, by preceding it with a tag
and a colon (\lstinline{:}). Tag can be created with
\lstinline|Tag.new("name")|. Giving tags a name is optional, yet it's
probably a better idea since it will be used for many
features. The listing below illustrates how to tag chunks of code.

\begin{urbiscript}
// Create a new tag
var mytag = Tag.new("name");
[00000000] Tag<name>
// Tag the evaluation of 42
mytag: 42;
[00000000] 42
// Tag the evaluation of a block.
mytag: { "foo"; 51 };
[00000000] 51
// Tag a function call.
mytag: echo("tagged");
[00000000] *** tagged
\end{urbiscript}

You can use tag that wasn't declared previously, they will be created
implicitly like in the listing below. However, this is fragile code since
tags will be created in a global scope, the \lstinline{Tag} object. This
feature can be used when inputting test code in the top level to avoid
bothering to declare each tag, yet it should be considered very bad
practice in regular code.

\begin{urbiscript}
// Since mytag is not declared, this will first do:
// var Tag.mytag = Tag.new("mytag");
mytag : 42;
[00000000] 42
\end{urbiscript}

So you can tag code, yet what's the use? One of the primary purpose of
tags is to be able to control the execution of code running in
parallel. Tags have a few control methods:

\begin{description}
\item[freeze] Suspend execution of all tagged code.
\item[unfreeze] Resume execution of previously frozen code.
\item[stop] Stop the execution of the tagged code. The flows of
  execution that where stopped jump immediately at the end of the
  tagged block.
\item[block] Block the execution of the tagged code, that is:
  \begin{itemize}
  \item Stop it.
  \item When an execution flow encounters the tagged block, it simply
    skips it.
  \end{itemize}
  You can think of \lstinline{block} like a permanent \lstinline{stop}.
\item[unblock] Stop blocking the tagged code.
\end{description}

The three listings below illustrate usage of these tag features.

\begin{urbiscript}
// Launch in background (using the comma) code that prints "ping"
// every second.  Tag it to keep control over it.
mytag:
{
  loop
  {
    echo("ping");
    sleep(0.5s)
  }
},
sleep(1.6s);
[00000000] *** ping
[00001000] *** ping
[00002000] *** ping
// Suspend execution
mytag.freeze;
// No printing anymore
sleep(1.6s);
// Resume execution
mytag.unfreeze;
sleep(0.1s);
[00007000] *** ping
\end{urbiscript}

\begin{urbiscript}
// Now, we print out a message when we get out of the tag.
{
  mytag:
  {
    loop
    {
      echo("ping"); sleep(1s)
    }
  };
  // Execution flow jumps here if mytag is stopped.
  echo("Background job stopped")|
},
sleep(3s);
[00000000] *** ping
[00001000] *** ping
[00002000] *** ping
// Stop the tag
mytag.stop;
[00002500] *** Background job stopped
// Our background job finished.
// Unfreezing the tag has no effect.
mytag.unfreeze;
\end{urbiscript}

\begin{urbiscript}
// Now, print out a message when we get out of the tag.
{
  loop
  {
    echo("ping"); sleep(1s);
    mytag: { echo("pong"); sleep(1s); };
  };

  // Execution flow will jump here if mytag is stopped
  echo("Background job stopped")|
},
sleep(4s);
/*(*/sleep(100ms);/*)*/
[00000000] *** ping
[00001000] *** pong
[00002000] *** ping
[00003000] *** pong
// Block printing of pong.
mytag.block;
sleep(3s);
/*(*/sleep(100ms);/*)*/
// The second half of the while isn't executed anymore.
[00004000] *** ping
[00005000] *** ping
[00006000] *** ping
// Reactivate pong
mytag.unblock;
sleep(4s);
/*(*/sleep(100ms);/*)*/
[00007000] *** ping
[00008000] *** pong
[00009000] *** ping
[00010000] *** pong
[00011000] *** ping
\end{urbiscript}

\section{Advanced example with parallelism and tags}

In this section, we implement a more advanced example with
parallelism.

The listing below presents how to implement a \lstinline{timeOut}
function, that takes code to execute and a timeout as arguments. It
executes the code, and returns its value. However, if the code
execution takes longer than the given timeout, it aborts it, print
\lstinline|"Timeout!"| and returns void. In this example, we use:

\begin{itemize}
\item Lazy arguments, since we want to delay the execution of the
  given code, to keep control on it.
\item Parallelism operators, to launch a timeout job in background.
\end{itemize}

% FIXME: doesn't work (inner return)
\begin{urbiscript}
// timeout (Code, Duration).
function timeOut
{
  // In background, launch a timeout job that waits
  // for the given duration before aborting the function.
  // call.evalArgAt(1) is the second argument, the delay.
  {
    sleep (call.evalArgAt(1));
    echo("Timeout!");
    return;
  },
  return call.evalArgAt(0);
} | {};
timeOut({sleep(1s); echo("On time"); 42}, 2s);
[00000000] *** On time
[00000000] 42
timeOut({sleep(2s); echo("On time"); 42}, 1s);
[00000000] *** Timeout!
\end{urbiscript}

% FIXME: add example with tags

% Add chronograms
\chapter{Event-based programming}
\label{sec:tut:event-prog}

When dealing with highly interactive agent programming, sequential
programming is inconvenient. We want to react to external, random
events, not execute code linearly with a predefined flow. \us has a
strong support for event-based programming.

\section{Event related constructs}

The first construct we will study is the \lstinline|at| keyword. Given
a condition, and an expression, \lstinline|at| will evaluate the
expression every time the condition becomes true. That is,
when a rising edge occurs on the condition.

\begin{urbiscript}
var x = 0;
[00000000] 0
at (x > 5)
  echo("ping");
x = 5;
[00000000] 5
// This triggers the event
x = 6;
[00000000] 6
[00000000] *** ping
// Does not trigger, since the condition is already true.
x = 7;
[00000000] 7
// The condition becomes false here.
x = 3;
[00000000] 3

x = 10;
[00000000] 10
[00000000] *** ping
\end{urbiscript}

An \lstinline|onleave| block can be appended to execute an expression
when the expression \emph{becomes} false --- that is, on falling edges.

\begin{urbiscript}
var x = false;
[00000000] false
at (x)
  echo("x")
onleave
  echo("!x");
x = true;
[00000000] true
[00000000] *** x
x = false;
[00000000] false
[00000000] *** !x
\end{urbiscript}

The \lstinline|whenever| construct is similar to \lstinline|at|,
except the expression evaluation is systematically restarted when it
finishes as long as the condition stands true.

\begin{urbiscript}
var x = false;
[00000000] false
whenever (x)
{
  echo("ping");
  sleep(1s);
};
x = true;
[00000000] true
sleep(3s);
// Whenever keeps triggering
[00000000] *** ping
[00001000] *** ping
[00002000] *** ping
x = false;
[00002000] false
// Whenever stops triggering
\end{urbiscript}

Just like \lstinline|at| has \lstinline|onleave|, \lstinline|whenever|
has \lstinline|else|: the given expression is evaluated as long as the
condition is false.

\begin{urbiscript}
var x = false;
[00002000] false
whenever (x)
{
  echo("ping");
  sleep(1s);
}
else
{
  echo("pong");
  sleep(1s);
};
sleep (3s);
[00000000] *** pong
[00001000] *** pong
[00002000] *** pong
x = true;
[00003000] true
sleep (3s);
[00003000] *** ping
[00004000] *** ping
[00005000] *** ping
x = false;
[00006000] false
sleep (2s);
[00006000] *** pong
[00007000] *** pong
\end{urbiscript}

\section{Events}
\label{sec:tut:events}
\us enables you to define events, that can be caught with the
\lstinline|at| and \lstinline|whenever| constructs we saw earlier. You
can create events by cloning the \lstinline|Event| prototype. They can
then be emitted with the \lstinline|!| keyword.

\begin{urbiscript}
var myEvent = Event.new;
[00000000] Event_0x0
at (myEvent?)
  echo("ping");
myEvent!;
[00000000] *** ping
// events work well with parallelism
myEvent! & myEvent!;
[00000000] *** ping
[00000000] *** ping
\end{urbiscript}

Both \lstinline|at| and \lstinline|whenever| have the same behavior on
punctual events. However, if you emit an event for a given duration,
and \lstinline|whenever| will keep triggering for this duration,
contrary to \lstinline|at|.

\begin{urbiscript}
var myEvent = Event.new;
[00000000] Event_0x0
whenever (myEvent?)
{
  echo("ping (whenever)")|
  sleep(200ms)
};
at (myEvent?)
{
  echo("ping (at)")|
  sleep(200ms)
};
// Emit myEvent for .3 second.
myEvent! ~ 300ms;
[00000000] *** ping (at)
[00000000] *** ping (whenever)
[00000100] *** ping (whenever)
\end{urbiscript}

%\section{Valued events}

%\chapter{Standard \us library}

%\section{Printing}

%\chapter{Binding with \Cxx - UObjects}

% LocalWords:  urbi UObjects faq Gostai SAS SDK ec Libport ident rlwrap isVoid
% LocalWords:  localhost variadic prepended asString myFunction succ slotNames
% LocalWords:  asFoo setSlot getSlot updateSlot removeSlot uid uids arg ok ko
% LocalWords:  elt baz quux printSalaries computeSalary protos addProto lookup
% LocalWords:  removeProto proto o's locateSlot myObj MyPair predefines init
% LocalWords:  evalArgAt myand lhs ary mytag timeOut onleave myEvent


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
