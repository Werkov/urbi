#+TITLE: Semantics issues in defining the Urbi 2.0 programming language
#+AUTHOR: Gostai SAS
#+LANGUAGE: en

* Introduction

This document contains the current open issues about the Urbi 2.0 language
semantics and characteristics. It is a work document and is in no way the
real specification.

* Types

The types listes here are those found in kernel/src/object.

** Code

Its purpose is to keep the bits of the AST used as Urbi values.

** Delegate

Its purpose is to serve as support for UObject values.

** Float

Floating point numbers, the only numeric type at this time.

Dubious conversion is used with certain operators (logical shift)
which can only work with integers. For example, 1.5 << 1.5 works,
albeit its result is *very* dubious.

** Integer

Dormant at this time as there is nothing in the parser to produce
Integer nodes.

** List

Mutable list. See note on dictionaries below.

At the implementation level, it would be great to have those lists shared
with C++. This way, the list of prototypes of an object could be manipulated
on the Urbi side and immediately seen in the C++ implementation of getSlot
for example. Also, it would allow the removal of hardcoded addProto and
removeProto, since it would be easy to work on the list returned by protos
(right now, a copy is returned).

** Lobby

A private user space available for each connection. This lets a user modify
its view of the world without changing it globally for other users, although
this is possible to go out of the lobby and make global modifications.

** Object

The root of all evil.

** Primitive

A primitive is a C++ function body.

** String

Regular strings.

** Other possible types

*** Boolean

There is no Boolean type. One could be declared as

## --------- ##
## Boolean.  ##
## --------- ##

var Boolean = Object.clone();
var true = Boolean.clone();
do true {
  var not = function() { false };
  var and = function(x) { x };
  var or = function(x) { true };
  var xor = function(x) { x.not };
  var toInteger = 1;
};
var false = Boolean.clone();
do false {
  var not = function() { true };
  var and = function(x) { false };
  var or = function(x) { x };
  var xor = function(x) { x };
  var toInteger = 0;
};
var Float.toBoolean = function(x) { x == 0 };

At this time, it is not possible to implement them as "true" and "false"
are hardcoded in the parser.

*** Dictionaries

In Lua, the basic compound type is the dictionary. Even a list is
a dictionary where keys are integers ranging from 0 to length-1.

We could add such a dictionary type in Urbi and have the List type
derive from it and override appropriate methods (for example, deleting
an element will slice the list). A List could be seen as a Dictionary
and it would be possible to ask for its keys or values for example.

Having dictionaries, we could use one of them for the local slots (localSlots).
We would then be able to write things such as

  var Object.slotNames = function () { localSlots.keys; };
  var Object.setLocalSlot = function (key, value) { localSlots.set(key, value)};

and so on.

If course, for efficiency reason, the underlying list would really be a list,
it would only implement the Dictionary protocol with specialized methods.

Dictionary is probably not the only type that could be added to Urbi to
get a clean and usable system. One could add other protocols:

  - Sequence (anything you can get an iterator on, such a list)

  - Range (a special kind of sequence allowing you to do big 1..n loops
    for example)

The complexity of adding those kind of types should be properly thought of.
IMO, not only are they not complex to add, but also they would lead to
cleaner and more straightforward Urbi code. Defining small protocols helps
having easily manipulable functions, and it is easy to then add generic
functions using the well-defined protocols.

This model has been adopted by Factor and for having used it, I like it.

* Variables

New named binding can be declared by "var x = expression". The new
binding takes place in the current scope. By default, for an
interactive connection, this is the connection lobby.

An update, such as "x = expression", updates the object locally
(creating it if needed) unless the current scope is a locals
container. This allows this kind of constructs:

{
  var a = 1;
  {
    var b = 2;       <= create b in the current scope
    a = b;           <= update the parent's a
  };
  a;                 <= contains 2 here
}

It is not allowed to declare with "var" a slot which already exists in
the current scope. Objects are lexically scoped.

* Assignment

How should the assignment behave? In kernel 1, you could associate
properties to an object (such as ->rangemin and ->rangemax). Should
the properties be reset by such an assignment?

  a = 2;

What about assignment from a named object, such as

  a = b;

Note that b may have different constraints itself, should they be
copied as well if the object is replaced?

What about the triggers ("at", ...) running on "a". Should they still
run, even if it makes no sense? 

Look at one of the examples in the v1 tutorial:

  at (ball.visible ~ 100ms) speaker = found onleave speaker = lost;

Akim answer, to be completed:

 In k2 we will address these horrors at the level
 of the objects.  There is just *one* smart entity in k2:
 the objects.  Slots are dumb.  The objects they contain
 have the intelligent part.

 If we can find something intelligent to reify the slots,
 it might change.  The Claire/Laure programming languages
 might be very good sources of inspiration in this regard.
 But I will never accept to hard code in every single
 slot the concept of rangemin/rangemax.

* Control flow

** Instructions

Each instruction has a beginning and an end time.

Each instruction has a result.

** Separators

Instructions separated by ";" are executed one after another. Any
instruction started before the ";" must have finished before the
execution of ";" terminates.

Instructions separated by "&" are started in parallel and considered
to have been started by their most inner enclosing block. "&" is more
binding than ";", so the following expression

  a & b; c & d;

must execute a and b in parallel, wait for both executions to
terminate, start c and d in parallel and wait for both executions to
terminate.

What is the result of a parallel execution? Blend mode will work only
for variables modifications, but what about

random = function() { random1 & random2; }

Note: add something about "|" and ","

** if/then/else

What is the status of separators in the test instruction? We are used
to writing the following:

  if (test) a else b;

Should the following phrases be equivalent, forbidden, or semantically
different?

  if (test) a; else b;
  if (test) {a;} else b;
  if (test) {a}; else b;

They should probably be semantically equivalent.

The

  if (test) a, else b;

is interesting too.

As a matter of fact what is often overlooked in the definition of
these connectives, is their "scope".  something put in bg via "," is
"waited for" at the next }.  So in the previous example, even if we
code support for
                                                                                
        if (t) a, else b;
                                                                                
the scoping rules will make it exactly equivalent to
                                                                                
        if (t) a; else b;
                                                                                
Besides, it must be clearly understood that the last ";" "belongs" to
the "if", not to "b".  This is in sharp constrast with C.  We will
certainly never be able to mock ";" a la C.

** break

"break" exits the innermost "for" or "while" loop. An exception is
thrown if we are not in a loop.

** return

"return" returns from the innermost executing function. An exception is
thrown if we are not in a function.

** Block

The end time of a block corresponds to the end time of the latest
instruction started from within this block. In short, it contains an
implicit ";" at the end which causes a join to occur if needed.

In a regular case, a block is an anonymous scope in which newly
declared variables will be created; they will disappear at the end of
the block, at the same time as the block itself.

* Events

** Generalities

Event handlers ("at", etc.) are attached to an object. By default,
they are attached to the scope in which they have been declared, which
means that they will be interrupted when leaving the scope. It is
possible (how?) to attach them to a longer-lived object.

Variables in event handlers need to be captured, be they in the expression
or in the action block. The references are lexically scoped and have no
relation with the object to which the handler is attached.

** at

Event handling can be declared with

  at (condition)
    positive-action
  [onleave
    negative-action]

Are positive and negative actions allowed to be complex statements?
Should they be blocks? Can there be concurrent execution of both of
them, or of several occurrences of each, if positive-action or
negative-action takes a long time to execute and the event is toggled
during this time?

The execution time of the "at" construct itself is immediate, right?

How do you cancel such an event? Can it be started with a tag?

If the condition is true when this construct is handled, should
positive-action be executed right away even if there is no edge in
this case?

In which context does "condition" evaluate? In which context does
"positive-action" evaluate? Do we need closures here? Do we attach
handlers to a particular object?

It may be acceptable to warn against modifying the structure of items
references in the condition. This opens up optimization opportunities
until we have made our mind on an efficient model to refresh the
condition.

** every

  every (ms)
    action

executes "action" every "ms" milliseconds.

** whenever

Repetitive event handling can be declared with

  whenever (condition)
    positive-action
  [else
    negative-action]

This is the same thing as "at" except that no trigger is needed, the
positive-action or negative-action block is executed repeatidly
depending on the condition value.

Same questions as with the at construct, what if the previous execution
didn't terminate? What should be the rate of execution? (for example,
printing something in positive-action and negative-action can generate
lots of output at an unknown rate, depending on factors such as the machine
speed)

If the positive-action contains an inner "if" at the top-level, the
"else" should be associated with it if it makes sense (no other "else").

* Timing

** wait

  wait(ms)

waits for "ms" milliseconds before resuming execution. Potentially blocking.

** waituntil

  waituntil(condition)

will block until condition becomes true. Potentially blocking.

** timeout

  timeout(ms) instruction

will stop "instruction" after "ms" milliseconds if it has not
finished. Potentially blocking.

** stopif

  stopif(condition) instruction

will stop "instruction" if "condition" becomes true.

** freezeif

  freezeif(condition) instruction

will freeze "instruction" as long as "condition" is true.

If "instruction" terminates, the "freezeif" block should be removed.

** Soft tests

All those instructions can use soft tests, that are conditions that
have to stay valid for at least a given time, using

  condition ~ ms

Must the condition be false for "ms" milliseconds for the "freezeif"
instruction to resume too or is it immediate?

* Tags

* Various

** Sheduler

There are two kind of conditions that can wake up Urbi's scheduler:

  - a timeout has expired
  - an IO is possible (data is available or data can be written)

A sensor implemented through an Uobject for example will ask to be woken
up after a certain period; it often makes no sense to read inputs as fast
as possible as sampling may take some time. Also, an effector doesn't
not need to be modified as fast as possible and will ask to be rescheduled
when appropriate.

That means that no data can be modified when the scheduler is dead. By
extension, this is never useful to try to evaluate "at" or similar guards
at any moment except when the scheduler wakes up or goes to sleep.

Using such a scheme would allow to put the scheduler (and large parts of
the system) at rest most of the time and should save battery life and
ease components cooling.

** nil

A nil object could represent a "void" value. Such a declaration could
be conceptually similar to

  var nil = Object.clone();
  nil.clone = function() { self }
  nil.setLocalSlot = function (key, value) { }

to lock up the nil object.

One thing to discuss is whether nil should evaluate to true or false (I think
it should be true, and only a real "false" singleton should evaluate to false).
