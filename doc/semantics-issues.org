#+TITLE: Semantics issues in defining the Urbi 2.0 programming language
#+AUTHOR: Gostai SAS
#+LANGUAGE: en

* Introduction

This document contains the current open issues about the Urbi 2.0 language
semantics and characteristics. It is a work document and is in no way the
real specification.

* Types

The types listes here are those found in kernel/src/object.

** Code

Its purpose is to keep the bits of the AST used as Urbi values.

** Delegate

Its purpose is to serve as support for UObject values.

** Float

Floating point numbers, the only numeric type at this time.

Dubious conversion is used with certain operators (logical shift)
which can only work with integers. For example, 1.5 << 1.5 works,
albeit its result is *very* dubious.

** Integer

Dormant at this time as there is nothing in the parser to produce
Integer nodes.

** List

Mutable list.

** Lobby

A private user space available for each connection. This lets a user modify
its view of the world without changing it globally for other users, although
this is possible to go out of the lobby and make global modifications.

** Object

The root of all evil.

** Primitive

A primitive is a C++ function body.

** String

Regular strings.

* Variables

New named binding can be declared by "var x = expression". The new
binding takes place in the current scope. By default, for an
interactive connection, this is the connection lobby.

An update, such as "x = expression", updates the object locally
(creating it if needed) unless the current scope is a locals
container. This allows this kind of constructs:

{
  var a = 1;
  {
    var b = 2;       <= create b in the current scope
    a = b;           <= update the parent's a
  };
  a;                 <= contains 2 here
}

It is not allowed to declare with "var" a slot which already exists in
the current scope.

* Assignment

How should the assignment behave? In kernel 1, you could associate
properties to an object (such as ->rangemin and ->rangemax). Should
the properties be reset by such an assignment?

  a = 2;

What about assignment from a named object, such as

  a = b;

Note that b may have different constraints itself, should they be
copied as well if the object is replaced?

What about the triggers ("at", ...) running on "a". Should they still
run, even if it makes no sense? 

Look at one of the examples in the v1 tutorial:

  at (ball.visible ~ 100ms) speaker = found onleave speaker = lost;

Akim answer, to be completed:

 In k2 we will address these horrors at the level
 of the objects.  There is just *one* smart entity in k2:
 the objects.  Slots are dumb.  The objects they contain
 have the intelligent part.

 If we can find something intelligent to reify the slots,
 it might change.  The Claire/Laure programming languages
 might be very good sources of inspiration in this regard.
 But I will never accept to hard code in every single
 slot the concept of rangemin/rangemax.

* Control flow

** Instructions

Each instruction has a beginning and an end time.

Each instruction has a result.

** Separators

Instructions separated by ";" are executed one after another. Any
instruction started before the ";" must have finished before the
execution of ";" terminates.

Instructions separated by "&" are started in parallel and considered
to have been started by their most inner enclosing block. "&" is more
binding than ";", so the following expression

  a & b; c & d;

must execute a and b in parallel, wait for both executions to
terminate, start c and d in parallel and wait for both executions to
terminate.

What is the result of a parallel execution? Blend mode will work only
for variables modifications, but what about

random = function() { random1 & random2; }

Note: add something about "|" and ","

** if/then/else

What is the status of separators in the test instruction? We are used
to writing the following:

  if (test) a else b;

Should the following phrases be equivalent, forbidden, or semantically
different?

  if (test) a; else b;
  if (test) {a;} else b;
  if (test) {a}; else b;

They should probably be semantically equivalent.

The

  if (test) a, else b;

is interesting too.

As a matter of fact what is often overlooked in the definition of
these connectives, is their "scope".  something put in bg via "," is
"waited for" at the next }.  So in the previous example, even if we
code support for
                                                                                
        if (t) a, else b;
                                                                                
the scoping rules will make it exactly equivalent to
                                                                                
        if (t) a; else b;
                                                                                
Besides, it must be clearly understood that the last ";" "belongs" to
the "if", not to "b".  This is in sharp constrast with C.  We will
certainly never be able to mock ";" a la C.

** break

"break" exits the innermost "for" or "while" loop. An exception is
thrown if we are not in a loop.

** return

"return" returns from the innermost executing function. An exception is
thrown if we are not in a function.

** Block

The end time of a block corresponds to the end time of the latest
instruction started from within this block. In short, it contains an
implicit ";" at the end which causes a join to occur if needed.

In a regular case, a block is an anonymous scope in which newly
declared variables will be created; they will disappear at the end of
the block, at the same time as the block itself.

* Events

** at

Event handling can be declared with

  at (condition)
    positive-action
  [onleave
    negative-action]

Are positive and negative actions allowed to be complex statements?
Should they be blocks? Can there be concurrent execution of both of
them, or of several occurrences of each, if positive-action or
negative-action takes a long time to execute and the event is toggled
during this time?

The execution time of the "at" construct itself is immediate, right?

How do you cancel such an event? Can it be started with a tag?

If the condition is true when this construct is handled, should
positive-action be executed right away even if there is no edge in
this case?

In which context does "condition" evaluate? In which context does
"positive-action" evaluate? Do we need closures here? Do we attach
handlers to a particular object?

It may be acceptable to warn against modifying the structure of items
references in the condition. This opens up optimization opportunities
until we have made our mind on an efficient model to refresh the
condition.

** whenever

Repetitive event handling can be declared with

  whenever (condition)
    positive-action
  [else
    negative-action]

This is the same thing as "at" except that no trigger is needed, the
positive-action or negative-action block is executed repeatidly
depending on the condition value.

Same questions as with the at construct, what if the previous execution
didn't terminate? What should be the rate of execution? (for example,
printing something in positive-action and negative-action can generate
lots of output at an unknown rate, depending on factors such as the machine
speed)

If the positive-action contains an inner "if" at the top-level, the
"else" should be associated with it if it makes sense (no other "else").

* Timing

** wait

  wait(ms)

waits for "ms" milliseconds before resuming execution.

** waituntil

  waituntil(condition)

will block until condition becomes true.

** timeout

  timeout(ms) instruction

will stop "instruction" after "ms" milliseconds if it has not
finished.

** stopif

  stopif(condition) instruction

will stop "instruction" if "condition" becomes true.

** freezeif

  freezeif(condition) instruction

will freeze "instruction" as long as "condition" is true.

If "instruction" terminates, the "freezeif" block should be removed.

** Soft tests

All those instructions can use soft tests, that are conditions that
have to stay valid for at least a given time, using

  condition ~ ms

Must the condition be false for "ms" milliseconds for the "freezeif"
instruction to resume too or is it immediate?

* Tags

