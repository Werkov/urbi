# -*- org -*-
#+TITLE: Urbi kernel roadmap
#+AUTHOR: Gostai kernel team
#+EMAIL: kernel@lists.gostai.com
#+OPTIONS: num:2 toc:2
#+LANG: en

* Scope of this document

The goal of this document is to gather ideas and features to be
implemented in the upcoming kernels.

Please do not edit this file unless something has been agreed (except
in the initial phase where we are filling up features).

* Planned features

** Version 2.0 technical preview 3 (2008-07-10)

*** Boost 1.35 (ae6a0a6666dd79a3e99a4d48be73b79d0c832377)
We move to 1.35.  Or decide if we do, in particular, see the impact on:
- compressed streams,
- encryption.

*** Webots
This must be usable.

*** Implement events (0be5e2a7dc02e7c0c6c2b74dffcaaf2624975377)

We need to settle on the syntax used to represent unbound variables
that will be matched against incoming events. We also need to
implement proper events support, including timed events.

See also the item on pattern matching.

*** Use on some robot

Or maybe Webots, but a true robot is preferred.

*** Cleanup "at" scoping
Decide what scoping is appropriate for "at" jobs.

*** Fix the Booleans (done: 43653fc957dd6bf3078097d8d99fd0d75c2c10e4)
They should no longer behave like Floats.

*** ICE (done: f1645d70e538c8d9124049e50ffbbae3c828861f)
We should catch the SEGVs, not only to display something nicer to the
user, but also because SEGV are really a problem for the BF under
Windows.

*** on, off, switch (e62fe6e934fc15f324d4bd9445abbdddfaf9404c)
Put this into some interface that we can derive from, but don't
provide by default.

*** Synonyms
"and" is an alias for "&&" etc., with the same behavior (binary
operator, same associativity and precedence).  How far should we go?
Should '&&' be equal to 'and'?

** Version 2.0 technical preview 4 (2008-07-24)

*** Start exploring dlopen
We need to address the foreign dependencies such as Boost.

*** Fix parser memory leaks

This requires:
  - that we delete unused data structures in the grammar;
  - or that we use a modified version of Bison which can use
    boost::variant or an equivalent type supporting non-POD C++ types

*** Fix events memory leaks

This requires that we can properly execute some code at scope exit time.

*** Real-time features

We need to prioritize jobs or tagged jobs.

*** Add time and space benchmarks

We need a way to benchmark the kernel reliably, including with
Uobjects.  Code coverage (of the C++ code, not the Urbi code).

*** Arrays
We need "a[1]", "a[1] = 2" etc.

** Version 2.0 beta 1 (2008-09-01)

This must be usable by real users (BA systems, Spanish team etc.).
Blend modes are not required (dixit JCB).

*** Nary, vs. Pipe, vs. And
The point was to have a single structure to support them all,
something was lost during the evolution.  Try to factor again.

*** Add tags signalling

The tools team will need to know when a tagged statement starts or
ends its execution by use of a special event.

*** Cleanup output presented to the user

Right now, the user sees an expanded version of the tree which may not
correspond to something that could be used as input.

*** Add complete kernel documentation

We need the Urbiscript language reference manual as well as the
UObject (plugged and remote) reference manual. This will be necessary
for the engines team to build engines and associated sensors and
effectors, and for the tools team to build their tools on them.

We also need to document clearly the differences between kernel 1.x
and kernel 2.0 so that developers can adapt their code easily.

** Version 2.0 beta 2 (2008-08-25)

*** Tools support

This version should have fixed problems found by the tools and engines
teams. Tools should be roughly functional.

*** Engines
Engines so that people can really use Urbi.

*** Use dlopen
To address the foreign dependencies such as Boost.

** Version 2.0 release candidate 1 (date?)

*** Tutorials

We need an Urbiscript and an Uobject tutorial.

** Version 2.0 final (date?)

Hopefully, the final version will correspond to one of the release
candidates.

** Version 2.0.1 (date?)

This will be a bugfix version.

** Version 2.1 (date?)

** Future features not associated with any particular version

*** Load compressed .u files in the kernel

We might need to load compressed Urbiscript files in the kernel in
order to reduce the space requirement on embedded targets.

*** Embed .u files into the kernel
It would be great to have Urbiscript files embedded into the kernel,
in a compressed or uncompressed form, so that we can ship one sole
executable.  Maybe store the serialized AST instead of the .u.

*** Separate parser and execution modules

We may not have enough room available on some targets to be able to
embed the parser. Some sort of AST serialization is needed.

*** Use real slots

Check what other languages have been using. Once we have real slots,
we will be able to set properties on local variables as well.

We need:
- to be able to capture set_x and get_x events

- to be able to add properties to the slots themselves
  (or whatever we need for contraints such as rangemin)

- maybe be able to type them

- be able to stack slot decorators.

*** Start-of-cycle and end-of-cycle executions

This is needed for UObject to work correctly, by being able to read
sensors at the beginning of each cycle and give orders to effectors at
the end of each cycle.

*** Better syntax for lambda functions

Lambda functions are quite verbose, a lightweight syntax should be
used.  More generally, we should pay particular attention to C++-0x
and try to anticipate the syntactic changes.

*** Pattern matching

It would be great to have broad pattern matching available.

*** More numerical types

We may need more numerical types, such as Integer, or even BigInteger.

*** Exceptions

We may want to throw and catch exceptions from Urbiscript.

*** Charsets

What are the correct input charset and encoding? ASCII? UTF8?

*** Internationalization and localization

Should we do something about that?

*** Push parser
The current prescanner is really a PITA.  It forbids constructs such
as

        class a : b, c {};

*** Strings
**** Symbols
Currently all our strings are Symbols underneath.  This is a no-no.

**** Long string
Support something like """..."""?

**** Operator%
Interpolation a la Python.

**** Binary
We need to be able to use binary strings, in particular to send raw
Binaries, something based on the length.  This enables compressed
strings btw.

*** Flyweight
See if it can be used for us.

*** Lookup
Our current lookup algorithm is not resilient.  Look at the
litterature and chose something better.

*** inline documentation
We should find some scheme to document in the sources.  Maybe we want
to define some grammar for some of our comments.  That's probably
something else to store for some slots.

*** Faith full parsing

*** Caret errors

** Point that must be dispatched, potentially to 2.0 beta

*** Use asBool

For now, any unknown object is considered true. We could use their
asBool method to enable users to customize their object behavior in
boolean context, and make code more robust by throwing type errors
when irrelevant values are tested.

*** "element in container" (dccc55fa0f3b85599facf21d1e11bfb1f4720db6)
Bounces to "container.has(element)".
