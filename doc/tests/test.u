//                                      -*- urbi -*-

// Too many unpredictable changes in the error messages.
LookupError.fixSpellingErrors = false |

// Determinism: asList and asString.
do (Dictionary)
{
  copySlot("keys", "oldKeys");
  keys->constant = false;
  keys = function ()
    {
      oldKeys.sort;
    };
}|

// We want random to become deterministic.
do (Float)
{
  var this.random_counter = 0;
  // chosen by fair dice roll.
  // guaranteed to be random.
  var this.random_values = [3, 1, 2];
  random->constant = false;
  random =
    function ()
    {
      var res = random_values[random_counter];
      // We don't want COW here, as the doc calls "5.random" repeatedly.
      Float.random_counter = (random_counter + 1) % random_values.size;
      res
    }
}|

// Deterministic localSlotNames.
do (Object)
{
  copySlot("localSlotNames", "oldLocalSlotNames");
  localSlotNames->constant = false;
  localSlotNames = function ()
    {
      oldLocalSlotNames.sort;
    };
}|

// Deterministic String.fresh.
do (String)
{
  var counter_ = 5;
  fresh->constant = false;
  fresh = function ()
  {
    this + "_" + counter_++;
  }
}|

// Keep sync with urbivalid/test.u.
if (System.Platform.isWindows)
  do (System)
  {
    var this.count = 1;

    // On Windows, use /bin/sh to please our tests.
    var 'system.orig' = getSlot("system");
    system->constant = false;
    system = function (command)
    {
      // For some reason I don't understand, the command is
      // backgrounded on Windows (or by Wine).  So use some stamp file
      // to mark the end of the command.  This also provides a means
      // to get the real exit status with Wine.
      var stamp = Path.new("%s.stamp" % count) |
      count += 1 |
      // As a subshell, not a subcommand ({ %s; }) so that if the
      // command includes an "exit", then the stamp file is really
      // created anyway with the right value.
      command = "( %s ); echo $? >%s" % [command, stamp]|

      // Escape all the quotes and backslashes, and call /bin/sh.
      var cmd = "/bin/sh -c \"" |
      for| (var c: command)
        cmd += {if (c in ["\\", "\""]) "\\" else ""} + c |
      cmd += "\"" |

      // Run the command, wait for the stamp.
      'system.orig'(cmd) |
      while| (!stamp.exists)
        sleep(20ms)
      var res = File.new(stamp).asList[0].asFloat |
      clog << ("system wrapper: " + command + ": " + cmd + ": " + res) |
      res
    };
  }|

;
