#! /usr/bin/env python

import re, string
import sys, os.path
import ast, tools

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

## Globals --------------------------------------------------------------------

re_access_r = re.compile (".*r.*"); re_access_R = re.compile (".*R.*")
re_access_w = re.compile (".*w.*"); re_access_W = re.compile (".*W.*")

## Abstract syntax tree C++ classes generator ---------------------------------

def print_inline_code (node, file, where):
  if node.inline.has_key(file + ' ' + where):
    str = node.inline[file + ' ' + where]
    print str

def print_banner(file, name, description):
  print >>file, tools.banner("ast/" + name,  description)

def guard_name (node, ext):
  return tools.define_id ("ast_" + node.name + "_" + ext)

def print_guard_open (file, node, ext):
  guard = guard_name (node, ext)
  print >>file, "#ifndef " + guard
  print >>file, "# define " + guard
  print >>file, ""

def print_guards_open (node, header, inline, impl):
  """Output the multiple inclusion guard."""
  # Shortands
  define_id = tools.define_id (node.name)
  print_guard_open (header, node, "hh")
  print_guard_open (inline, node, "hxx")

def print_guard_close (file, node, ext):
  print >>file, "#endif // !" + guard_name (node, ext)

def print_guards_close (node, header, inline, impl):
  sys.stdout = header
  # Shortands.
  print_inline_code (node, "header", "epilogue")

  # Close protection
  print >>header, "# include \"ast/" + node.hxx () + "\""
  print >>header, ""
  print_guard_close (header, node, "hh")
  print_guard_close (inline, node, "hxx")

  sys.stdout = impl
  print_inline_code (node, "impl", "epilogue")

def print_includes (node, header, inline, impl):
  """Generate the required header inclusions."""
  # Shortands.

  includes = {}
  for sup in node.super:
    includes["\"ast/" + sup.hh () + "\""] = True
  need_misc_algorithm = False
  for attribute in node.attributes:
    type = attribute.root_type ()
    if ast.re_list.match (type):
      need_misc_algorithm = True
    if type in ast_params['includes_map']:
      includes[ast_params['includes_map'][type]] = True
    elif not type == node.name and \
	 not type in ast_params['atomic_types'] and \
	 not ('compound_types' in ast_params and \
		type in ast_params['compound_types']):
      # Don't include ourselves.
      # Don't include headers for atomic types.
      # Don't include headers for types defined elsewhere.
      includes["\"ast/" + tools.file_id (type) + ".hh\""] = True

  # *.hh
  sys.stdout = header
  for i in includes:
    print >>header, "# include " + i
  print_inline_code (node, "header", "prologue")

  # *.hxx
  sys.stdout = inline
  print >>inline, "# include \"ast/" + node.hh () + "\""
  print_inline_code (node, "inline", "prologue")

  # *.cc
  sys.stdout = impl
  if need_misc_algorithm:
    print >>impl, "#include \"libport/containers.hh\""
  print >>impl, "#include \"ast/visitor.hh\""
  print >>impl, "#include \"ast/" + node.hh () + "\""
  print_inline_code (node, "impl", "prologue")

def print_namespace_class_open (node, header, inline, impl):
  # Shortands
  class_id = node.name
  # Open namespace
  for f in [header, inline, impl]:
    print >>f, """
namespace ast
{
"""
    if node.hide:
      if not (f == inline and len(node.attributes) == 0):
	print >>f, "//<<"

  # Declare class
  sys.stdout = header
  decl = "class " + node.name
  first = True
  for sup in node.super:
    if first:
      decl += " : "
    else:
      decl += ", "
    first = False
    decl += "public " + sup.name
  if node.desc:
    print node.desc
  else:
    print "  /// " + node.name + "."
  print "  " + decl
  print "  {"

def print_namespace_class_close (node, header, inline, impl):
  sys.stdout = header
  print "  };"

  # Close namespace
  for f in [header, inline, impl]:
    sys.stdout = f
    if node.hide:
      if not (f == inline and len(node.attributes) == 0):
	print "//>>"
    print """
} // namespace ast
"""


def print_ctor_dtor (node, header, inline, impl):
  """Issue the constructors and destructor."""
  args = node.ctor_args (False)
  init = node.ctor_init (False)
  hide = node.need_duplicate ()
  if hide:
    args_h = node.ctor_args (True)
    init_h = node.ctor_init (True)

  sys.stdout = header
  print """    /** \\name Ctor & dtor.
     ** \\{ */
  public:"""
  if hide:
    print "    //<<-"
  print "    /// Construct " + tools.indef_article (node.name) + " " + \
	node.name + " node."
  print tools.wrap_proto ("    " + node.name + " (" + args + ");", 75)
  if hide:
    print "    //->>"
    print "    /// Construct " + tools.indef_article (node.name) + " " + \
	  node.name + " node."
    print tools.wrap_proto ("    " + node.name + " (" + args_h + ");", 75)
  print "    /// Destroy " + tools.indef_article (node.name) + " " + \
	node.name + " node."
  print "    virtual ~" + node.name + " ();"
  print "    /** \\} */"
  sys.stdout = impl
  if hide:
    print "  //<<-"
  if init == "":
    print tools.wrap_proto ("  " + node.name + "::" + node.name + " ()", 75)
  else:
    print tools.wrap_proto ("  " + node.name + "::" + node.name + " (" + \
	  re.sub(" =.*(, )?", "", args) + ")", 75)
    print init
  print "  { }"
  if hide:
    print "  //->>"
    print ""
    print tools.wrap_proto ("  " + node.name + "::" + node.name + " (" + \
	  re.sub(" =.*(, )?", "", args_h) + ")", 75)
    print init_h
    print "  { }"
  print ""
  print "  " + node.name + "::~" + node.name + " ()"
  print "  {"
  for a in node.attributes:
    if a.delete ():
      print a.delete (),
  print "  }"
  print ""

def print_attributes (node, header, inline, impl):
  # Declare attribute accessors
  if len(node.attributes) > 0:
    sys.stdout = header
    print """
    /** \\name Accessors.
     ** \\{ */
  public:"""

    for a in node.attributes:
      get_comment = "    /// Return " + a.description () + "."
      set_comment = "    /// Set " + a.description () + "."

      get_deref = ""
      set_deref = ""
      if a.pointer_p () and a.mandatory:
	get_deref = "*"
	set_deref = "&"

      # Hide following code to students
      if a.hide:
	sys.stdout = header
	print "    //<<-"

      # Read-only accessor (const get)
      if re_access_r.match (a.access):
	sys.stdout = header
	print get_comment
	print "    " + ast.decl (a.r_type (), a.name) + "_get () const;"
	sys.stdout = inline
	if a.hide:
	  print "  //<<-"
	print "  inline " + a.r_type ()
	print "  " + node.name + "::" + a.name + "_get () const"
	print "  {"
	print "    return " + get_deref + a.name + "_;"
	print "  }"
	if a.hide:
	  print "  //->>"

      # Read/Write accessor (non const get)
      if re_access_w.match (a.access):
	sys.stdout = header
	print get_comment
	print "    " + ast.decl (a.w_type (), a.name) + "_get ();"
	sys.stdout = inline
	if a.hide:
	  print "  //<<-"
	print "  inline " + a.w_type ()
	print "  " + node.name + "::" + a.name + "_get ()"
	print "  {"
	print "    return " + get_deref + a.name + "_;"
	print "  }"
	if a.hide:
	  print "  //->>"

      # Write accessor (set)
      if re_access_W.match (a.access):
	sys.stdout = header
	print set_comment
	print "    void " + a.name + "_set (" + a.W_type () + ");"
	sys.stdout = inline
	if a.hide:
	  print "  //<<-"
	print "  inline void"
	print "  " + node.name + "::" + a.name + "_set (" + \
	      ast.decl (a.W_type (), a.name) + ")"
	print "  {"
	print "    " + a.name + "_ = "+ a.name +";"
	print "  }"
	if a.hide:
	  print "  //->>"

      sys.stdout = inline
      print ""
      sys.stdout = header
      if a.hide:
	print "    //->>"
    print "    /** \\} */\n"

    # Declare attributes.
    print "  protected:"
    for a in node.attributes:
      sys.stdout = header
      if a.hide:
	print "    //<<-"
      print "    /// "+ a.desc + "."
      print "    " + a.attr_decl () + ";"
      if a.hide:
	print "    //->>"


def declare_visitor(node, header, abstract):
  "Declare the (possible abstract) `accept' methods for node."

  sys.stdout = header
  impl = ""
  if abstract:
    impl = " = 0"
  print """
    /// \\name Visitors entry point.
    /// \\{ */
  public:
    /// Accept a const visitor \\a v.
    virtual void accept (ConstVisitor& v) const%s;
    /// Accept a non-const visitor \\a v.
    virtual void accept (Visitor& v)%s;
    /// \\}""" % (impl, impl)

def print_visitor(node, header, inline, impl):
  """Output the Visitor support routine declaration, and implementation
  if the class is concrete."""

  if node.concrete:
    declare_visitor (node, header, False)
    sys.stdout = inline
    print ""
    sys.stdout = impl
    print """  void
  """ + node.name + """::accept (ConstVisitor& v) const
  {
    v (*this);
  }

  void
  """ + node.name + """::accept (Visitor& v)
  {
    v (*this);
  }"""
  # In our design, the class is concrete iff it has a single parent.
  # This excludes roots, and "joins".
  elif len (node.super) != 1:
    declare_visitor (node, header, True)




## Generate the class corresponding to node
def class_generate(node):
  # Shortands.
  define_id = tools.define_id (node.name)

  # Open destination header, inline and implementation files
  header = file(node.fname ("hh.tmp"),  "w")
  inline = file(node.fname ("hxx.tmp"), "w")
  impl   = file(node.fname ("cc.tmp"),  "w")

  # A flag for developpers.
  # Document the file
  print_banner (header, node.hh (),
		"Declaration of ast::" + node.name + ".")
  print_banner (inline, node.hxx (),
		"Inline methods of ast::" + node.name + ".")
  print_banner (impl, node.cc (),
		"Implementation of ast::" + node.name + ".")

  print_guards_open (node, header, inline, impl)
  print_includes (node, header, inline, impl)

  print_namespace_class_open(node, header, inline, impl)

  # Print inside hand written code.
  for f in [(header, "header"),
	    (inline, "inline"),
	    (impl,   "impl")]:
    sys.stdout = f[0]
    print_inline_code (node, f[1], "inside")

  # Constructor(s) and destructor.
  print_ctor_dtor (node, header, inline, impl)

  # Visitor entry point.
  print_visitor (node, header, inline, impl)

  # Attributes and accessors.
  print_attributes (node, header, inline, impl)

  # End of declaration.
  print_namespace_class_close (node, header, inline, impl)

  # Print epilogue.
  print_guards_close (node, header, inline, impl)

  # Restore stdout.
  sys.stdout = sys.__stdout__

  # Check differences between old and new files.
  for f in [(header, "hh"),
	    (inline, "hxx"),
	    (impl,   "cc")]:
    f[0].close ()
    tools.lazy_install (srcdir, node.fname (f[1]))

## Main -----------------------------------------------------------------------
loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)

for node in nodes.values ():
  class_generate (node)
