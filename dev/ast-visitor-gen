#!/usr/bin/env python

import re
import sys, os, os.path
import ast, tools

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

## Abstract syntax tree C++ visitor - header ----------------------------------
loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)
concrete = ast.concrete(nodes)

visitor_hh = file("visitor.hh.tmp", "w")
sys.stdout = visitor_hh

print tools.banner("ast/visitor.hh",
		   "Definition of ast::Visitor.") + """
""" + ast_params['visitor_hh_prologue'] + """

namespace ast
{

  /*----------------------------------------------------.
  | Boost PP macros to ease the declaration of visits.  |
  `----------------------------------------------------*/

/// Declare an abstract visit method for Elem for a GenVisitor.
# define ABSTRACT_VISITOR_VISIT_NODE_(R, Data, Elem)            \\
    virtual void %(visit)s (typename Const<ast::Elem>::type& e) = 0;

/// Declare abstract visits for an abstract GenVisitor.
# define ABSTRACT_VISITOR_VISIT_NODES(Nodes)                    \\
  BOOST_PP_SEQ_FOR_EACH(ABSTRACT_VISITOR_VISIT_NODE_, ~, Nodes)

/// Declare a visit method for Elem for a GenVisitor.
# define GEN_VISITOR_VISIT_NODE_(R, Data, Elem)            \\
    virtual void %(visit)s (typename Const<ast::Elem>::type& e);

/// Declare visits for a GenVisitor.
# define GEN_VISITOR_VISIT_NODES(Nodes)                    \\
  BOOST_PP_SEQ_FOR_EACH(GEN_VISITOR_VISIT_NODE_, ~, Nodes)

/// Declare a visit method for Elem.  Pass Const = const or not.
# define VISITOR_VISIT_NODE_(R, Const, Elem)            \\
    virtual void %(visit)s (Const ast::Elem& e);

/// Declare visit methods for Nodes.  Pass Const = const or not.
# define VISITOR_VISIT_NODES_(Nodes, Const)             \\
  BOOST_PP_SEQ_FOR_EACH(VISITOR_VISIT_NODE_, Const, Nodes)


  /** \\brief Root class of all Ast visitors.
   **
   ** GenVisitor<CONSTIFY> is the root class of all Ast visitors. */
  template <template <typename> class Const>
  class GenVisitor : public std::unary_function<Ast, void>
  {
    /** \\name Ctor & dtor.
     ** \\{ */
  public:
    /// Destroy a GenVisitor.
    virtual ~GenVisitor ();
    /** \\} */

    /// The entry point: visit \\a e.
    virtual void operator() (typename Const<Ast>::type& e);
""" % ast_params

print tools.indent(4, ast.visit(concrete, "ABSTRACT_VISITOR_VISIT_NODES"))

print
for dec_type in ast.subclasses(nodes, 'Dec'):
  print "    virtual void %s (typename Const<%ss>::type&) = 0;"\
      % ast_params['visit'], dec_type.name
print """\
  protected:
    /** A convenient shortcut for recurring code like this:

	\\code
	if (e)
	  %(visit)s (*e);
	\\endcode

	However, the drawback of this approach is that it doesn't take
	care of the constness, and any \\a const violation will be
	reported \\em within the body of this method, not at its
	corresponding call site.

	We cannot use the libport/select_const.hh approach here, since
	the compiler cannot resolve a function overloaded or
	specialized on an associated type of a template.  E.g., writing
	\\a %(visit)s like this:

	\\code
	template <typename E>
	void %(visit)s (typename Const<E>::type* e);
	\\endcode

	won't work directly.  Of course, on can help the compiler,
	providing it with \\a E

	\\code
	%(visit)s<NameTy> (e.result_get ());
	\\endcode

	but this is painful.  */
    template <typename E>
    void %(visit)s (E* e);
  };

  /*----------.
  | Visitor.  |
  `----------*/

  /// Shorthand for a non const visitor.
  typedef GenVisitor<libport::id_traits> Visitor;

  /// Declare visits for a non-const visitor.
# define VISITOR_VISIT_NODES(Nodes)                     \\
    VISITOR_VISIT_NODES_(Nodes, )


  /*---------------.
  | ConstVisitor.  |
  `---------------*/

  /// Shorthand for a const visitor.
  typedef GenVisitor<libport::constify_traits> ConstVisitor;

  /// Declare visits for a const visitor.
# define CONST_VISITOR_VISIT_NODES(Nodes)               \\
    VISITOR_VISIT_NODES_(Nodes, const)


} // namespace ast

# include "ast/visitor.hxx"

#endif // !AST_VISITOR_HH""" % ast_params

# Restore stdout and close files
sys.stdout = sys.__stdout__
visitor_hh.close ()
tools.lazy_install (srcdir, "visitor.hh")
