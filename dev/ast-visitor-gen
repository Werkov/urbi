#!/usr/bin/env python

import re
import sys, os, os.path
import ast, tools
from string import lower

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

## Abstract syntax tree C++ visitor - header ----------------------------------
loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)

visitor_hh = file("visitor.hh.tmp", "w")
sys.stdout = visitor_hh

print tools.banner("ast/visitor.hh",
		   "Definition of ast::Visitor.") + """

#ifndef AST_VISITOR_HH
# define AST_VISITOR_HH

""" + ast_params['visitor_hh_prologue'] + """

namespace ast
{

  /** \\brief Root class of all Ast visitors.
   **
   ** GenVisitor<CONSTIFY> is the root class of all Ast visitors. */
  template <template <typename> class Const>
  class GenVisitor : public std::unary_function<Ast, void>
  {
    /** \\name Ctor & dtor.
     ** \\{ */
  public:
    /// Destroy a GenVisitor.
    virtual ~GenVisitor ();
    /** \\} */

    /** This \\c typedef and the following ones are only here to workaround a
     * bug in MSVC 2005 SP1, see:
     * http://forums.microsoft.com/msdn/showpost.aspx?postid=987536
     * http://support.microsoft.com/kb/930198 */
    typedef typename Const<ast::Ast>::type ast_type;
    /// The entry point: visit \\a e.
    virtual void operator() (typename Const<ast::Ast>::type& e);
"""
arr = nodes.values ()
arr.sort (lambda x, y: cmp(x.name, y.name))
for node in arr:
  if node.concrete:
    print """
    /// MSVC 2005 SP1 workaround.
    typedef typename Const<ast::%s>::type %s_type;
    virtual void operator() (typename Const<ast::%s>::type&) = 0;
""" % (node.name, lower(node.name), node.name)
print
dec_subclasses = \
  filter (lambda node: node.name != 'Dec' and node.is_a ('Dec'),
	   arr)
for dec_type in dec_subclasses:
  print "   " \
	" virtual void" \
	" operator() (typename Const<" + dec_type.name + "s" + ">::type&) = 0;"
print """\
  protected:
    /** A convenient shortcut for recurring code like this:

	\\code
	if (e)
	  e->accept (*this);
	\\endcode

	However, the drawback of this approach is that it doesn't take
	care of the constness, and any \\a const violation will be
	reported \\em within the body of this method, not at its
	corresponding call site.

	We cannot use the libport/select_const.hh approach here, since
	the compiler cannot resolve a function overloaded or
	specialized on an associated type of a template.  E.g., writing
	\\a accept like this:

	\\code
	template <typename E>
	void accept (typename Const<E>::type* e);
	\\endcode

	won't work directly.  Of course, on can help the compiler,
	providing it with \\a E

	\\code
	accept<ast::NameTy> (e.result_get ());
	\\endcode

	but this is painful.  */
    template <typename E>
    void accept (E* e);
  };

# define VISITOR_VISIT_NODE_(Z, N, Array)                      \\
    virtual void operator() (ast::BOOST_PP_ARRAY_ELEM(N, Array)& e);

# define VISITOR_VISIT_NODES(Nodes)                    \\
  BOOST_PP_REPEAT(BOOST_PP_ARRAY_SIZE(Nodes),          \\
		 VISITOR_VISIT_NODE_,                  \\
		 Nodes)

  /// Shorthand for a const visitor.
  typedef GenVisitor<libport::constify_traits> ConstVisitor;
  /// Shorthand for a non const visitor.
  typedef GenVisitor<libport::id_traits> Visitor;

} // namespace ast

# include "ast/visitor.hxx"

#endif // !AST_VISITOR_HH"""

# Restore stdout and close files
sys.stdout = sys.__stdout__
visitor_hh.close ()
tools.lazy_install (srcdir, "visitor.hh")
