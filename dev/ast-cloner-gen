#! /usr/bin/env python

import string
import sys, os, os.path
import ast, tools

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)
arr = nodes.values ()
concrete_nodes = filter ((lambda node: node.concrete), arr)
concrete_nodes.sort (lambda x, y: cmp(x.name, y.name))

# FIXME: The definition of dec_subclasses is redundant with
# ast-visitor-gen's.
dec_subclasses = \
  filter (lambda node: node.name != 'Dec' and node.is_a ('Dec'),
	   concrete_nodes)

clonerlib = ast_params['clonerlib'];
CLONERLIB = clonerlib.upper();

## Abstract syntax tree C++ clone visitor - header ----------------------------

cloner_hh = file("cloner.hh.tmp", "w")
sys.stdout = cloner_hh

print tools.banner(clonerlib + "/cloner.hh",
		   "Declaration of " + clonerlib + "::Cloner.") + """
#ifndef """ + CLONERLIB + """_CLONER_HH
# define """ + CLONERLIB + """_CLONER_HH

# include "ast/default-visitor.hh"

namespace """ + clonerlib + """
{

  /// \\brief Duplicate an Ast.
  class Cloner : public ast::DefaultConstVisitor
  {
  public:
    typedef ast::DefaultConstVisitor super_type;

    // Import overloaded virtual functions.
    using super_type::operator();

    /// Destroy a Cloner.
    virtual ~Cloner ();

    // Return the cloned Ast.
    ast::Ast* result_get ();

    template <typename T>
    T* recurse (const T& t);

    template <typename T>
    T* recurse (const T* const t);

    /** \\brief Clone a collection object.

	Using overloading for this method is tempting, but it would
	lead to the same prototype than the first \\a recurse method.

	A partial specialization for \\a std::list<T> would work, but is
	not allowed by C++ standard. As a consequence, we are stuck to
	using different names.
     */
    template <typename CollectionType>
    CollectionType* recurse_collection (const CollectionType& c);


    // Visit methods.
  public:"""
for node in concrete_nodes:
  print "    virtual void operator() (const ast::" + node.name + "&);"

print """
    template <typename DecsType>
    /** \\brief Visit a chunk (i.e., a list of Function, Var, and Type decs).
     **
     ** It is exactly the same in the three cases, so the code is
     ** factored via a template method. */
    void decs_visit (const DecsType& e);

    // As we can't mix template and virtual methods, we have to
    // duplicate these methods.  That's too bad.  :("""
for dec_type in dec_subclasses:
  print "    virtual void operator() (const ast::" + dec_type.name + "s" + "&);"

print """
  protected:
    /// The cloned Ast.
    ast::Ast* result_;
  };

} // namespace ast

# include \"""" + clonerlib + """/cloner.hxx"

#endif // !""" + CLONERLIB + """_CLONER_HH"""

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_hh.close ()
tools.lazy_install(srcdir, "cloner.hh");


## Abstract syntax tree C++ clone visitor - implementation --------------------

# Helper.  Should be part of dev/ast.py?
def node_all_attributes (node):
  attrs = []
  for sup in node.super:
    sup_attrs = node_all_attributes (sup)
    if len (sup_attrs) > 0:
      attrs.extend (sup_attrs)
  attrs.extend (node.attributes)
  return attrs

cloner_cc = file("cloner.cc.tmp", "w")
sys.stdout = cloner_cc

print """\
//<<-
// Generated, do not edit by hand.
//->>
/**
 ** \\file """ + clonerlib + """/cloner.cc
 ** \\brief Implementation of """ + clonerlib + """::Cloner.
 */

#include "ast/all.hh"
#include \"""" + clonerlib + """/cloner.hh"
#include \"""" + ast_params['auxlib'] + """/symbol.hh"

namespace """ + clonerlib + """
{
  using namespace ast;

  Cloner::~Cloner ()
  {
  }

  Ast*
  Cloner::result_get ()
  {
    return result_;
  }
"""

for node in concrete_nodes:
  print "  void"
  print "  Cloner::operator() (const ast::" + node.name + "& e)"
  print "  {"
  if node.hide:
    print "    //<<"

  args = node.ctor_args (False, False)

  # Clone recursively the children of E.
  for a in (node_all_attributes (node)):
    if not a.init:
      accessor = "e." + a.name + "_get ()"
      # Non visitable attributes.
      if a.type in ast_params['non_visitable_types']:
	type = a.W_type ()
	get_deref = ""
	if a.pointer_p () and a.mandatory:
	  get_deref = "&"
	print "    " + type + " " + a.name + " = " + \
	      get_deref + accessor + ";"

      # Collection attributes.
      elif a.root_type () in ast_params['collections']:
	if a.pointer_p ():
	  print "    " + a.root_type () + "* " + a.name + \
		" = recurse_collection (" + accessor + ");"
	else:
	  print "    " + a.root_type () + " " + a.name + \
		" = *recurse_collection (" + accessor + ");"

      # Visitable attributes.
      else:
	print "    " + a.W_type () + " " + a.name + \
	      " = recurse (" + accessor + ");"

  # Result.
  if node.name == "FunctionDec":
    # Special case for FunctionDec: copy the sl_needed_ and sl_escapes_ fields.
    print "    FunctionDec* fundec ="
    print "      new " + node.name + " (" + args + ");"
    print "    //<<-"
    for a in ["sl_needed", "sl_escapes"]:
      print "    fundec->" + a + "_set (e." + a + "_get ());"
    print "    //->>"
    print "    result_ = fundec;"
  else:
    # Normal case.
    print "    result_ = new " + node.name + " (" + args + ");"
  if node.hide:
    print "    //>>"
  print """  }
"""

first_decs_type_p = True
for dec_type in dec_subclasses:
  print """
  void
  Cloner::operator() (const ast::""" + dec_type.name + "s" + """& e)
  {
    decs_visit<ast::""" + dec_type.name + "s" + """> (e);
  }"""
  # Show the visit method for the first instance of decs types, but
  # hide the others.
  if first_decs_type_p:
    first_decs_type_p = False
    print """
  //<< Other declarations.""",
print """  //>>

} // namespace """ + clonerlib

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_cc.close ()
tools.lazy_install(srcdir, "cloner.cc");
