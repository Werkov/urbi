#! /usr/bin/env python

import string
import sys, os, os.path
import ast, tools

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)
arr = nodes.values ()
concrete_nodes = filter ((lambda node: node.concrete), arr)
concrete_nodes.sort (lambda x, y: cmp(x.name, y.name))

# FIXME: The definition of dec_subclasses is redundant with
# ast-visitor-gen's.
dec_subclasses = \
  filter (lambda node: node.name != 'Dec' and node.is_a ('Dec'),
	   concrete_nodes)

clonerlib = ast_params['clonerlib'];
guard = tools.define_id(clonerlib + "/cloner.hh")

## Abstract syntax tree C++ clone visitor - header ----------------------------

cloner_hh = file("cloner.hh.tmp", "w")
sys.stdout = cloner_hh

print tools.banner(clonerlib + "/cloner.hh",
		   "Declaration of " + clonerlib + "::Cloner.") + """
#ifndef """ + guard + """
# define """ + guard + """

# include <boost/type_traits/remove_const.hpp>

# include "ast/default-visitor.hh"

namespace %(clonerlib)s
{

  /// \\brief Duplicate an Ast.
  class Cloner : public ast::DefaultConstVisitor
  {
  public:
    typedef ast::DefaultConstVisitor super_type;

    /// Destroy a Cloner.
    virtual ~Cloner ();

    // Return the cloned Ast.
    ast::Ast* result_get ();

    // Visit methods.
  public:
    // Import overloaded virtual functions.
    using super_type::operator();
""" % ast_params

for node in concrete_nodes:
  print "    virtual void operator() (const ast::" + node.name + "&);"

print """\

  protected:
    template <typename T>
    T* recurse (const T& t);

    template <typename T>
    typename boost::remove_const<T>::type* recurse (T* t);

    /** \\brief Clone a collection object.

	Using overloading for this method is tempting, but it would
	lead to the same prototype than the first \\a recurse method.

	A partial specialization for \\a std::list<T> would work, but is
	not allowed by C++ standard. As a consequence, we are stuck to
	using different names.
     */
    template <typename CollectionType>
    CollectionType* recurse_collection (const CollectionType& c);"""

if dec_subclasses:
  print """
    template <typename DecsType>
    /** \\brief Visit a chunk (i.e., a list of Function, Var, and Type decs).
     **
     ** It is exactly the same in the three cases, so the code is
     ** factored via a template method. */
    void decs_visit (const DecsType& e);

    // As we can't mix template and virtual methods, we have to
    // duplicate these methods.  That's too bad.  :("""
  for dec_type in dec_subclasses:
    print "    virtual void operator() (const ast::" + dec_type.name + "s" + "&);"

print """
    /// The cloned Ast.
    ast::Ast* result_;
  };

} // namespace ast

#endif // !""" + guard

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_hh.close ()
tools.lazy_install(srcdir, "cloner.hh");


## Abstract syntax tree C++ clone visitor - implementation --------------------
def attribute_clone(a):
  accessor = "e." + a.name + "_get ()"
  # Non visitable attributes.
  if a.type in ast_params['non_visitable_types']:
    type = a.W_type ()
    get_deref = ""
    if a.pointer_p () and a.mandatory:
      get_deref = "&"
    print "    " + type + " " + a.name + " = " + \
          get_deref + accessor + ";"

  # Collection attributes.
  elif a.root_type () in ast_params['collections']:
    if a.pointer_p ():
      if a.mandatory:
        print "    " + a.root_type () + "* " + a.name + \
            " = recurse_collection (" + accessor + ");"
      else:
        print "    " + a.root_type () + "* " + a.name + " ="
        print "      " + accessor + \
            " ? recurse_collection (*" + accessor + ") : 0;"
    else:
      print "    " + a.root_type () + " " + a.name + \
            " = *recurse_collection (" + accessor + ");"

  # Visitable attributes.
  else:
    print "    " + a.W_type () + " " + a.name + \
          " = recurse (" + accessor + ");"

def children_clone (node):
  """Print on stdout the definition of local variables that copy/clone
  the attributes of node."""
  # Clone recursively the children of E.
  for a in (node.all_attributes()):
    # Attributes with a default value are cloned with the default value.
    if a.init:
      continue
    attribute_clone(a)


cloner_cc = file("cloner.cc.tmp", "w")
sys.stdout = cloner_cc

print """\
//<<-
// Generated, do not edit by hand.
//->>
/**
 ** \\file %(clonerlib)s/cloner.cc
 ** \\brief Implementation of %(clonerlib)s::Cloner.
 */

#include "ast/all.hh"
#include "%(clonerlib)s/cloner.hh"
// This file contains only protected functions, not loading it
// from cloner.hh saves cycles.
#include "%(clonerlib)s/cloner.hxx"
#include "%(auxlib)s/symbol.hh"

namespace %(clonerlib)s
{
  using namespace ast;

  Cloner::~Cloner ()
  {
  }

  Ast*
  Cloner::result_get ()
  {
    return result_;
  }
""" % ast_params

for node in concrete_nodes:
  print "  void"
  print "  Cloner::operator() (const ast::" + node.name + "& e)"
  print "  {"
  if node.hide:
    print "    //<<"

  children_clone(node)
  # Result.
  args = node.ctor_args (False, False)
  if node.name == "FunctionDec":
    # Special case for FunctionDec: copy the sl_needed_ and sl_escapes_ fields.
    print "    FunctionDec* fundec ="
    print "      new " + node.name + " (" + args + ");"
    print "    //<<-"
    for a in ["sl_needed", "sl_escapes"]:
      print "    fundec->" + a + "_set (e." + a + "_get ());"
    print "    //->>"
    print "    result_ = fundec;"
  else:
    # Normal case.
    print "    result_ = new " + node.name + " (" + args + ");"
  if node.hide:
    print "    //>>"
  print """  }
"""

first_decs_type_p = True
for dec_type in dec_subclasses:
  print """
  void
  Cloner::operator() (const ast::""" + dec_type.name + "s" + """& e)
  {
    decs_visit<ast::""" + dec_type.name + "s" + """> (e);
  }"""
  # Show the visit method for the first instance of decs types, but
  # hide the others.
  if first_decs_type_p:
    first_decs_type_p = False
    print """
  //<< Other declarations.""",
print """  //>>

} // namespace """ + clonerlib

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_cc.close ()
tools.lazy_install(srcdir, "cloner.cc");
