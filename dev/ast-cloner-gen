#! /usr/bin/env python

import string
import sys, os, os.path
import ast, tools

if len(sys.argv) != 2:
  tools.error("Usage: .. SRCDIR")
srcdir = sys.argv[1]

loader = ast.Loader ()
nodes, ast_params = loader.load (sys.stdin)
# Concrete classes.
concrete = ast.concrete(nodes)

dec_subclasses = ast.subclasses(nodes, 'Dec')

clonerlib = ast_params['clonerlib'];
guard = tools.define_id(clonerlib + "/cloner.hh")

## Abstract syntax tree C++ clone visitor - header ----------------------------

cloner_hh = file("cloner.hh.tmp", "w")
sys.stdout = cloner_hh

print tools.banner(clonerlib + "/cloner.hh",
		   "Declaration of " + clonerlib + "::Cloner.") + """
# include <boost/type_traits/remove_const.hpp>

# include "%(ast_basedir)sdefault-visitor.hh"

namespace %(clonerlib)s
{

  /// \\brief Duplicate an Ast.
  class Cloner : public ast::DefaultConstVisitor
  {
  public:
    typedef ast::DefaultConstVisitor super_type;

    /// Destroy a Cloner.
    virtual ~Cloner ();

    // Return the cloned Ast.
    ast::rAst result_get ();

    // Visit methods.
  public:
    // Import overloaded virtual functions.
    using super_type::visit;
""" % ast_params

print tools.indent(4, ast.visit(concrete, True))

print """\

  protected:
    template <typename T>
    libport::shared_ptr<T> recurse (libport::shared_ptr<const T> t);

    template <typename T>
    libport::shared_ptr<T>
    recurse (libport::shared_ptr<T> t);

    /** \\brief Clone a collection object.

	Using overloading for this method is tempting, but it would
	lead to the same prototype than the first \\a recurse method.

	A partial specialization for \\a std::list<T> would work, but is
	not allowed by C++ standard. As a consequence, we are stuck to
	using different names.
     */
    template <typename CollectionType>
    CollectionType* recurse_collection (const CollectionType& c);"""

if dec_subclasses:
  print """
    template <typename DecsType>
    /** \\brief Visit a chunk (i.e., a list of Function, Var, and Type decs).
     **
     ** It is exactly the same in the three cases, so the code is
     ** factored via a template method. */
    void decs_visit (const DecsType& e);

    // As we can't mix template and virtual methods, we have to
    // duplicate these methods.  That's too bad.  :("""
  for dec_type in dec_subclasses:
    print "    virtual void visit (const ast::%ss&);" \
        % (dec_type.name)

print """
    /// The cloned Ast.
    ast::rAst result_;
  };

} // namespace ast

#endif // !""" + guard

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_hh.close ()
tools.lazy_install(srcdir, "cloner.hh");


## Abstract syntax tree C++ clone visitor - implementation --------------------
def attribute_dup(a):
  "Return a clone (an expression) of a's value."
  accessor = "e->" + a.name + "_get ()"
  # Non visitable attributes.
  if a.type in ast_params['non_visitable_types']:
    type = a.W_type ()
    get_deref = ""
    if a.pointer_p () and a.mandatory:
      get_deref = "&"
    return get_deref + accessor

  # Collection attributes.
  elif a.root_type () in ast_params['collections']:
    if a.pointer_p ():
      if a.mandatory:
        return "recurse_collection (" + accessor + ")"
      else:
        return accessor + " ? recurse_collection (*" + accessor + ") : 0"
    else:
      return "*recurse_collection (" + accessor + ")"

  # Visitable attributes.
  else:
    return "recurse (" + accessor + ")"


def attribute_clone(a):
  "Build a copy of attribute a in a local variable."
  print "    " + a.W_type () + " " + a.name + " = " + attribute_dup(a) + ";"

def children_clone (node):
  """Print on stdout the definition of local variables that copy/clone
  the attributes of node."""
  # Clone recursively the children of E.
  for a in (node.all_attributes()):
    # Attributes with a default value are cloned with the default value.
    if a.init:
      continue
    attribute_clone(a)


cloner_cc = file("cloner.cc.tmp", "w")
sys.stdout = cloner_cc

print """\
//<<-
// Generated, do not edit by hand.
//->>
/**
 ** \\file %(clonerlib)s/cloner.cc
 ** \\brief Implementation of %(clonerlib)s::Cloner.
 */

#include "%(ast_basedir)sall.hh"
#include "%(clonerlib)s/cloner.hh"
// This file contains only protected functions, not loading it
// from cloner.hh saves cycles.
#include "%(clonerlib)s/cloner.hxx"
#include "%(auxlib)s/symbol.hh"

namespace %(clonerlib)s
{
  using namespace ast;

  Cloner::~Cloner ()
  {
  }

  rAst
  Cloner::result_get ()
  {
    return result_;
  }
""" % ast_params

for node in concrete:
  print "  void"
  print "  Cloner::visit (ast::rConst%s e)" % node.name
  print "  {"
  if node.hide:
    print "    //<<"

  children_clone(node)
  # Result.
  args = node.ctor_args (False, False)
  print "    %s* res = new %s (%s);" % (node.name, node.name, str(args))
  # Copy the fields that are not passed as ctor arguments: the hidden
  # one, and those with an "init" field.
  for a in node.attributes:
    if a.hide:
      print "   //<<-"
    if a.hide or a.init != None:
      print "    res->%s_set(%s);" % (a.name, str(attribute_dup(a)))
    if a.hide:
      print "   //->>"
  print "    result_ = res;"
  if node.hide:
    print "    //>>"
  print """  }
"""

if dec_subclasses:
  first_decs_type_p = True
  for dec_type in dec_subclasses:
    print """
    void
    Cloner::visit (const ast::%ss& e)
    {
      decs_visit<ast::%ss> (e);
    }"""  % (dec_type.name, dec_type.name)
    # Show the visit method for the first instance of decs types, but
    # hide the others.
    if first_decs_type_p:
      first_decs_type_p = False
      print """
    //<< Other declarations.""",
  print "  //>>\n"

print "} // namespace " + clonerlib

# Restore stdout and close files
sys.stdout = sys.__stdout__
cloner_cc.close()
tools.lazy_install(srcdir, "cloner.cc");
