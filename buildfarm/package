#! /bin/sh

set -e
. $(dirname "$0")/common


# make_tarball DIRECTORY
# ----------------------
#
# Prepare a tarball (*.zip on Windows, tar.bz2 elsewhere) with an
# inner MANIFEST.txt file.  Take care of permission issues.  Set
# make_tarball_res to the name of the created tarball.
make_tarball ()
{
  local dir=$1

  # Fix permissions on DLL that were removed through DAVfs.
  find "$dir" -name '*.dll' -exec chmod u+x {} ';'

  # MANIFEST.txt
  #
  # Build a MANIFEST.txt with the list of files to install into the
  # final destination.
  local here
  here=$(pwd)
  cd "$dir"
    find . -type f -print |
      sed -e 's,^\./,,' |
      xargs $MD5SUM \
      >"$DIR_PACKAGES/MANIFEST.txt"
  cd "$here"
  xmv $DIR_PACKAGES/MANIFEST.txt "$dir"

  # Force mode 755/644 on all files.
  chmod -R a+rX "$dir"

  # Create archives.  Don't be verbose for each one, it clutters the web
  # logs (and they take too long to load).
  local up
  up=$(dirname "$dir")
  local base
  base=$(basename "$dir")
  cd "$up"
  case $BUILDFARM_OS in
    (windows)
      make_tarball_res=$base.zip
      zip -r -q "$make_tarball_res.tmp" "$base"
      ;;

    (*)
      make_tarball_res=$base.tar.bz2
      tar --owner root -cjf "$make_tarball_res.tmp" "$base"
      ;;
  esac
  cd $here
  make_tarball_res=$up/$make_tarball_res

  # Make the tarball in two steps to ensure atomicity: some of the
  # tarballs are to be uncompressed as soon as they exist.
  xmv -f "$make_tarball_res.tmp" "$make_tarball_res"

  # Let the reader of the log be able to check what we created.
  ls -l "$dir".*
}


# move_into DIR SOURCES...
# ------------------------
# Import the SOURCES... into DIR, making it atomic so that we don't
# "see" files that are not ready to be used.
move_into ()
{
  local dir=$1
  shift
  # First, copy them all into $dir with a tmp extension.
  local i
  for i
  do
    xmv -v -f "$i" "$dir/$(basename "$i").tmp"
  done

  # Then rename them all.
  for i
  do
    xmv -v -f "$dir/$(basename "$i").tmp" "$dir/$(basename "$i")"
  done
}


# check_md5 DIR FILE
# ------------------
# Make sure we managed to publish properly.  It's sad to say, but
# there seems to be too much nondeterminism coming from our
# distributed file system.  Give it some time, otherwise the archive
# is incomplete.
check_md5 ()
{
  local dir=$1
  local file=$2
  local here=$(pwd)
  cd $dir
  local n=5
  while true;
  do
    stderr "$file: md5 check attempt..."
    ls -l "$file" "$file.md5"
    if test -s "$file.md5"; then
      cat "$file.md5"
      if $MD5SUM --check $file.md5; then
        stderr "$file: md5 check correct"
        break
      else
        fatal "$file: md5 check incorrect"
      fi
    else
      n=$(expr $n - 1)
      test 0 -lt $n ||
        fatal "$file.md5 is still empty"
      sleep 1
    fi
  done
  cd $here
}


# publish FILE-OR-DIR
# -------------------
# Publish a tarball in DIR_ARCHIVE.  Check md5sum.
publish ()
{
  # $pack: the package (tarball/zip) to publish.
  local pack=$1
  # If this is a directory, make it a tarball.
  if test -d "$pack"; then
    make_tarball "$pack"
    pack=$make_tarball_res
  fi

  # Compute the md5sum of the file.
  local here
  here=$(pwd)
  local base
  base=$(basename "$pack")
  cd $(dirname "$pack")
    $MD5SUM "$base" >"$base.md5"
  cd $here

  # Publish the archive and its md5sum.
  move_into "$DIR_ARCHIVE" "$pack" "$pack.md5"

  # Make sure we managed to publish properly.
  check_md5 $DIR_ARCHIVE "$base"

  # This looks useless, but it's an attempt to eliminate
  # nondeterministic problems of availability of shared directories
  # on OS X.
  ls "$DIR_ARCHIVE" >/dev/null
}


## ------ ##
## Main.  ##
## ------ ##

# The directories which will receive packages to publish.
rm -rf $DIR_PACKAGES
mkdir -p $DIR_PACKAGES
mkdir -p "$DIR_ARCHIVE"


## ----------- ##
## Variables.  ##
## ----------- ##

CONFIGURATION=$BUILDFARM_OS-$BUILDFARM_ARCH-$BUILDFARM_COMPILER
# If we are in release mode, do not tell it, the final users won't care.
# Otherwise, add "-debug".
test "$BUILDFARM_MODE" != "release" &&
  CONFIGURATION="$CONFIGURATION-$BUILDFARM_MODE"

# The SDK package.
urbi_sdk=$BUILDFARM_PROJECT-$SHA1-$CONFIGURATION
# The doc only package.
urbi_doc=${BUILDFARM_PROJECT%-sdk}-doc-$SHA1
# The SDK package, without the doc.
urbi_sdk_no_doc=$(echo "$urbi_sdk" | sed -e 's/urbi-sdk/urbi-sdk-no-doc/')
# The runtime package, i.e., without doc etc.
urbi_runtime=$(echo "$urbi_sdk" | sed -e 's/urbi-sdk/urbi-runtime/')

# Primary target.
name=$urbi_sdk

# 1. Documentation.
#
# If the documentation is compiled in this package, extract it as a
# separate directory.
#
# If the doc is not compiled in, then if a doc package is available,
# inline its contents in this package.  Otherwise make a package
# without the doc, but with a name that states it.
docsrc="$DIR_INSTALL/$prefix/share/doc/urbi-sdk"
if test -f "$docsrc/urbi-sdk.pdf"; then
  stderr "Documentation is compiled, shipping"
  tree_copy "$docsrc" "$DIR_PACKAGES/$urbi_doc"
  # Do not leave the COMPONENTS.txt file, which is architecture
  # specific.  It would override the existing one from the package
  # into which the documentation will be copied.
  rm "$DIR_PACKAGES/$urbi_doc/COMPONENTS.txt"
else
  stderr "Documentation is NOT compiled, looking for it in $DIR_ARCHIVE"
  ls -l "$DIR_ARCHIVE"
  if test -f "$DIR_ARCHIVE/$urbi_doc.tar.bz2"; then
    stderr "Documentation found, installing"
    # Do not remove what's in $docsrc, as we might remove architecture
    # specific files, such as COMPONENTS.txt.
    tar -C "$docsrc" --strip=1 -xf "$DIR_ARCHIVE/$urbi_doc.tar.bz2"
    # So remove the package without doc if there is one.
    rm -f "$DIR_ARCHIVE/$urbi_sdk_no_doc".*
  else
    # We couldn't find the doc, and it's not our job to compile it.
    # So, instead of blocking the generation of packages, generate
    # packages without the doc, but make it clear in the tarball name.
    stderr "Documentation NOT found"
    name=$urbi_sdk_no_doc
  fi
fi

# 2. Prebuilt-Urbi SDK.
#
# Create a fresh directory in which we put the subdirectories of the
# $DIR_INSTALL directory.
tree_copy "$DIR_INSTALL/$prefix" "$DIR_PACKAGES/$name"

# 3. Description.
#
# Extract the file that describes the contents of the package.
cp "$docsrc/COMPONENTS.txt" "$DIR_PACKAGES/$urbi_sdk.txt"

# 4. Prebuilt-Urbi Runtime.
#
# Create a run-time version of the package.
packagedir="$DIR_PACKAGES/$urbi_runtime"
tree_copy "$DIR_INSTALL/$prefix" "$packagedir"
# Keep only the bin, lib, and share/urbi directories.  Don't forget
# bin is lib on Windows.  Leave LICENSE.txt since it is used by
# Lobby.license.
(cd "$packagedir" &&
    rm -rf README.txt include libexec share/doc)

# 5. Source tarball.
tarname=$BUILDFARM_PROJECT-$SHA1.tar.bz2
if test -f $DIR_BUILD/$tarname; then
  cp -v $DIR_BUILD/$tarname $DIR_PACKAGES/$tarname.tmp
  mv $DIR_PACKAGES/$tarname.tmp $DIR_PACKAGES/$tarname
fi



## --------------------- ##
## Upload the packages.  ##
## --------------------- ##

ls -la $DIR_PACKAGES
packs=$(ls $DIR_PACKAGES)
test -n "$packs" ||
  fatal "The project's package script didn't create anything"

# Iterate over packaged content.
for pack in $packs
do
  publish "$DIR_PACKAGES/$pack"

  # On Windows, make the installers.
  case $BUILDFARM_OS in (windows)
    delegate="$DIR_SOURCE/buildfarm/make-installer"
    # This is the expected output from this delegate.
    exe=${pack%-$BUILDFARM_MODE}.exe
    "$delegate" "$DIR_ARCHIVE/$pack"
    # The delegate might not create the installer, if it was run
    # before its peer.
    if test -f "$DIR_ARCHIVE/$exe"; then
      check_md5 "$DIR_ARCHIVE" "$exe"
    fi
    ;;
  esac
done
