#! /bin/sh

set -e
. $(dirname "$0")/common

# xmv ARG...
# ----------
# Wrapper around "mv" that tries to do things three times, then forget
# about it.  This is because sometimes we get "Input/output error"
# with WebDAV, which is a huge loss of time on the BF.
xmv ()
{
  local i
  for i in 1 2 3
  do
    if mv "$@"; then
      return 0
    fi
  done
  fatal "cannot: mv $*"
}


# make_tarball DIRECTORY
# ----------------------
#
# Prepare a tarball (*.zip on Windows, tar.bz2 elsewhere) with an
# inner MANIFEST.txt file.  Take care of permission issues.  Set
# make_tarball_res to the name of the created tarball.
make_tarball ()
{
  local dir=$1

  # Fix permissions on DLL that were removed through DAVfs.
  find "$dir" -name '*.dll' -exec chmod u+x {} ';'

  # MANIFEST.txt
  #
  # Build a MANIFEST.txt with the list of files to install into the
  # final destination.
  here=$(pwd)
  cd "$dir"
    find . -type f -print |
      sed -e 's,^\./,,' |
      xargs $MD5SUM \
      >"$tmp/MANIFEST.txt"
  cd $here
  xmv $tmp/MANIFEST.txt "$dir"

  # Force mode 755/644 on all files.
  chmod -R a+rX "$dir"

  # Create archives.  Don't be verbose for each one, it clutters the web
  # logs (and they take too long to load).
  case $BUILDFARM_OS in
    (windows)
      make_tarball_res=$dir.zip
      zip -r -q "$make_tarball_res.tmp" "$dir"
      ;;

    (*)
      make_tarball_res=$dir.tar.bz2
      tar --owner root -cjf "$make_tarball_res.tmp" "$dir"
      ;;
  esac

  # Make the tarball in two steps to ensure atomicity: some of the
  # tarballs are to be uncompressed as soon as they exist.
  xmv -f "$make_tarball_res.tmp" "$make_tarball_res"

  # Let the reader of the log be able to check what we created.
  ls -l "$dir".*
}


# move_into DIR SOURCES...
# ------------------------
# Import the SOURCES... into DIR, making it atomic so that we don't
# "see" files that are not ready to be used.
move_into ()
{
  local dir=$1
  shift
  # First, copy them all into $dir with a tmp extension.
  local i
  for i
  do
    xmv -v -f "$i" "$dir/$(basename "$i").tmp"
  done

  # Then rename them all.
  for i
  do
    xmv -v -f "$dir/$(basename "$i").tmp" "$dir/$(basename "$i")"
  done
}


# check_md5 DIR FILE
# ------------------
# Make sure we managed to publish properly.  It's sad to say, but
# there seems to be too much nondeterminism coming from our
# distributed file system.  Give it some time, otherwise the archive
# is incomplete.
check_md5 ()
{
  local dir=$1
  local file=$2
  local here=$(pwd)
  cd $dir
  local n=5
  while true;
  do
    stderr "$file: md5 check attempt..."
    ls -l "$file" "$file.md5"
    if test -s "$file.md5"; then
      cat "$file.md5"
      if $MD5SUM --check $file.md5; then
        stderr "$file: md5 check correct"
        break
      else
        fatal "$file: md5 check incorrect"
      fi
    else
      n=$(expr $n - 1)
      test 0 -lt $n ||
        fatal "$file.md5 is still empty"
      sleep 1
    fi
  done
  cd $here
}

## ------ ##
## Main.  ##
## ------ ##

find_prog $MD5SUM gmd5sum md5sum
MD5SUM=$find_prog_res
test -n "$MD5SUM" ||
  fatal "cannot find md5sum"

: ${TMPDIR=/tmp}

# Make a slight effort so that instead of 2.2-8-g9b02553 we get
# 2.2-008-g9b02553, which is better with "ls".  Always show the sha1
# (--long) so that when we use repeatedly the same tag, tarballs with
# the same name are *not* stored at the same place.
SHA1=$(cd "$DIR_SOURCE" &&
       git describe --long |
         perl -ne '
  if (m{^(?:.*/)?(.*)-(\d+)-(g[\da-f]+)$})
  {
    printf "%s-%03d-%s\n", $1, $2, $3;
  }
  elsif (m{^(?:.*/)?(.*)$})
  {
    printf "%s\n", $1;
  }')
test -n "$SHA1" || SHA1=$(cd "$DIR_SOURCE" && git rev-parse HEAD)

# Create a temporary directory where to package, and be ready to clear
# it on success/failure.
cleanup ()
{
  status=$?
  cd /
  rm -rf $tmp
  exit $status
}
tmp=$(mktemp -d "$TMPDIR/buildfarm_package.XXXXXX")
trap cleanup 0 1 2 13 15

cd "$tmp"
pwd

# Where to install the packages.
case $SHA1 in
  # We could automatically install releases there, but it is feared
  # that this is too much automation, the maintainer should do that.
  # She might want also to get rid of the sha1 part when copying for
  # archives/ to releases/.
  #
  # (*-000-g*) archivedir="$DIR_DEST/releases/$SHA1";;
  (*)        archivedir="$DIR_DEST/archives/$SHA1";;
esac
export archivedir
mkdir -p "$archivedir"


## ----------- ##
## Variables.  ##
## ----------- ##

# Determine the version from the latest component of the tag. This will
# ease ordering.
CONFIGURATION=$BUILDFARM_OS-$BUILDFARM_ARCH-$BUILDFARM_COMPILER
# If we are in release mode, do not tell it, the final users won't care.
# Otherwise, add "-debug".
test "$BUILDFARM_MODE" != "release" &&
  CONFIGURATION="$CONFIGURATION-$BUILDFARM_MODE"

version=$(cd "$DIR_SOURCE" && git describe | sed -e "s,^preview/,,;s,/,-,g")

# The SDK package.
urbi_sdk=$BUILDFARM_PROJECT-$CONFIGURATION
# The doc only package.
urbi_doc=${BUILDFARM_PROJECT%-sdk}-doc-$version
# The SDK package, without the doc.
urbi_sdk_no_doc=$urbi_sdk-no-doc
# The runtime package, i.e., without doc etc.
urbi_runtime=$(echo "$urbi_sdk" | sed -e 's/urbi-sdk/urbi-runtime/')

# Primary target.
name=$urbi_sdk

# 1. Documentation.
#
# If the documentation is compiled in this package, extract it as a
# separate directory.
#
# If the doc is not compiled in, then if a doc package is available,
# inline its contents in this package.  Otherwise make a package
# without the doc, but with a name that states it.
docsrc="$DIR_INSTALL/$prefix/share/doc/urbi-sdk"
updir=.
if test -f "$docsrc/urbi-sdk.pdf"; then
  stderr "Documentation is compiled, shipping"
  tree_copy "$docsrc" "$updir/$urbi_doc"
  # Do not leave the COMPONENTS.txt file, which is architecture
  # specific.  It would override the existing one from the package
  # into which the documentation will be copied.
  rm "$updir/$urbi_doc/COMPONENTS.txt"
else
  stderr "Documentation is NOT compiled, looking for it in $archivedir"
  if test -f "$archivedir/$urbi_doc.tar.bz2"; then
    stderr "Documentation found, installing"
    # Do not remove what's in $docsrc, as we might remove architecture
    # specific files, such as COMPONENTS.txt.
    tar -C "$docsrc"  --strip=1 -xf "$archivedir/$urbi_doc.tar.bz2"
    # So remove the package without doc if there is one.
    rm -f "$archivedir/$urbi_sdk_no_doc".*
  else
    # We couldn't find the doc, and it's not our job to compile it.
    # So, instead of blocking the generation of packages, generate
    # packages without the doc, but make it clear in the tarball name.
    stderr "Documentation NOT found"
    name=$urbi_sdk_no_doc
  fi
fi

# 2. Prebuilt-Urbi SDK.
#
# Create a fresh directory in which we put the subdirectories of the
# $DIR_INSTALL directory.
tree_copy "$DIR_INSTALL/$prefix" "$updir/$name"

# 3. Description.
#
# Extract the file that describes the contents of the package.
cp "$docsrc/COMPONENTS.txt" "$updir/$urbi_sdk.txt"

# 4. Prebuilt-Urbi Runtime.
#
# Create a run-time version of the package.
packagedir="$updir/$urbi_runtime"
tree_copy "$DIR_INSTALL/$prefix" "$packagedir"
# Keep only the bin, lib, and share/urbi directories.  Don't forget
# bin is lib on Windows.  Leave LICENSE.txt since it is used by
# Lobby.license.
(cd "$packagedir" &&
    rm -rf README.txt include libexec share/doc)

# 5. Source tarball.
tarname=$BUILDFARM_PROJECT-$version.tar.bz2
if test -f $DIR_BUILD/$tarname; then
  cp -v $DIR_BUILD/$tarname $updir/$tarname.tmp
  mv $updir/$tarname.tmp $updir/$tarname
fi
pwd
ls -la
qualified_dir=$(ls)
test -n "$qualified_dir" ||
  fatal "The project's package script didn't create anything"


## --------------------- ##
## Upload the packages.  ##
## --------------------- ##

# Iterate over packaged content.
for dir in $qualified_dir
do
  # $pack: the package (tarball/zip) to publish.
  # If this is a directory, make it a tarball.
  if test -d "$dir"; then
    make_tarball "$dir"
    pack=$make_tarball_res
  else
    pack=$dir
  fi

  # Compute the md5sum of the file.
  $MD5SUM "$pack" >"$pack.md5"

  # Publish the archive and its md5sum.
  move_into "$archivedir" "$pack" "$pack.md5"

  # Make sure we managed to publish properly.
  check_md5 $archivedir $pack

  # This looks useless, but it's an attempt to eliminate
  # nondeterministic problems of availability of shared directories
  # on OS X.
  ls "$DIR_DEST" >/dev/null

  delegate="$DIR_SOURCE/buildfarm/make-installer"
  if test -x "$delegate"; then
    sleep 10
    # This is the expected output from this delegate.
    exe=${dir%-$BUILDFARM_MODE}.exe
    "$delegate" "$archivedir/$dir"
    # The delegate might not create the installer, if it was run
    # before its peer.
    if test -f "$archivedir/$exe"; then
      check_md5 "$archivedir" "$exe"
    fi
  fi
done
