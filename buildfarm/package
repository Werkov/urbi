#!/bin/sh

set -e
. $(dirname "$0")/common

# xmv ARG...
# ----------
# Wrapper around "mv" that tries to do things three times, then forget
# about it.  This is because sometimes we get "Input/output error"
# with WebDAV, which is a huge loss of time on the BF.
xmv ()
{
  local i
  for i in 1 2 3
  do
    if mv "$@"; then
      return 0
    fi
  done
  fatal "cannot: mv $*"
}


# make_tarball DIRECTORY
# ----------------------
#
# Prepare a tarball (*.zip on Windows, tar.bz2 elsewhere) with an
# inner MANIFEST.txt file.  Take care of permission issues.  Set
# make_tarball_res to the name of the created tarball.
make_tarball ()
{
  local dir=$1

  # Fix permissions on DLL that were removed through DAVfs.
  dlls=$(find "$dir" -name '*.dll')
  test -n "$dlls" && chmod u+x $dlls

  # MANIFEST.txt
  #
  # Build a MANIFEST.txt with the list of files to install into the
  # final destination.
  here=$(pwd)
  cd "$dir"
    find . -type f -print |
      sed -e 's,^\./,,' |
      xargs $MD5SUM \
      >"$tmp/MANIFEST.txt"
  cd $here
  xmv $tmp/MANIFEST.txt "$dir"

  # Force mode 755/644 on all files.
  chmod -R a+rX "$dir"

  # Create archives.  Don't be verbose for each one, it clutters the web
  # logs (and they take too long to load).
  case $OS in
    (windows)
      make_tarball_res=$dir.zip
      zip -r -q "$make_tarball_res.tmp" "$dir"
      ;;

    (*)
      make_tarball_res=$dir.tar.bz2
      tar --owner root -cvjf "$make_tarball_res.tmp" "$dir"
      ;;
  esac

  # Make the tarball in two steps to ensure atomicity: some of the
  # tarballs are to be uncompressed as soon as they exist.
  xmv -f "$make_tarball_res.tmp" "$make_tarball_res"

  # Let the reader of the log be able to check what we created.
  ls -l "$dir".*
}


# move_into DIR SOURCES...
# ------------------------
# Import the SOURCES... into DIR, making it atomic so that we don't
# "see" files that are not ready to be used.
move_into ()
{
  local dir=$1
  shift
  # First, copy them all into $dir with a tmp extension.
  local i
  for i
  do
    xmv -v -f "$i" "$dir/$(basename "$i").tmp"
  done

  # Then rename them all.
  for i
  do
    xmv -v -f "$dir/$(basename "$i").tmp" "$dir/$(basename "$i")"
  done
}


# check_md5 DIR FILE
# ------------------
# Make sure we managed to publish properly.  It's sad to say, but
# there seems to be too much nondeterminism coming from our
# distributed file system.  Give it some time, otherwise the archive
# is incomplete.
check_md5 ()
{
  local dir=$1
  local file=$2
  local here=$(pwd)
  cd $dir
  local n=5
  while true;
  do
    stderr "$file: md5 check attempt..."
    ls -l "$file" "$file.md5"
    if test -s "$file.md5"; then
      cat "$file.md5"
      if $MD5SUM --check $file.md5; then
        stderr "$file: md5 check correct"
        break
      else
        fatal "$file: md5 check incorrect"
      fi
    else
      n=$(expr $n - 1)
      test 0 -lt $n ||
        fatal "$file.md5 is still empty"
      sleep 1
    fi
  done
  cd $here
}

## ------ ##
## Main.  ##
## ------ ##

find_prog $MD5SUM gmd5sum md5sum
MD5SUM=$find_prog_res
test -n "$MD5SUM" ||
  fatal "cannot find md5sum"

: ${TMPDIR=/tmp}

PROJECT=$BUILDFARM_PROJECT    # name of the project
source=$DIR_SOURCE            # source directory
build=$DIR_BUILD              # build directory
install=$DIR_INSTALL          # install directory
# Where to put the tarballs.
dest=$sharedir/built/$BUILDFARM_PROJECT

ARCH=$BUILDFARM_ARCH      # archithecture; ex. x86
OS=$BUILDFARM_OS          # operating system; (linux|linux_lucid|macos|windows)
COMP=$BUILDFARM_COMPILER  # compiler; ex. gcc4
MODE=$BUILDFARM_MODE      # compile mode: (release|debug)_(static|dynamic)
prefix=/prefix            # prefix as given to configure

# Make a slight effort so that instead of 2.2-8-g9b02553 we get
# 2.2-008-g9b02553, which is better with "ls".  Always show the sha1
# (--long) so that when we use repeatedly the same tag, tarballs with
# the same name are *not* stored at the same place.
SHA1=$(cd "$source" &&
       git describe --long |
         perl -ne '
  if (m{^(?:.*/)?(.*)-(\d+)-(g[\da-f]+)$})
  {
    printf "%s-%03d-%s\n", $1, $2, $3;
  }
  elsif (m{^(?:.*/)?(.*)$})
  {
    printf "%s\n", $1;
  }')
test -n "$SHA1" || SHA1=$(cd "$source" && git rev-parse HEAD)

# Create a temporary directory where to package, and be ready to clear
# it on success/failure.
cleanup ()
{
  status=$?
  cd /
  rm -rf $tmp
  exit $status
}
tmp=$(mktemp -d "$TMPDIR/buildfarm_package.XXXXXX")
trap cleanup 0 1 2 13 15

cd "$tmp"
pwd

# Where to install the packages.
case $SHA1 in
  # We could automatically install releases there, but it is feared
  # that this is too much automation, the maintainer should do that.
  # She might want also to get rid of the sha1 part when copying for
  # archives/ to releases/.
  #
  # (*-000-g*) archivedir="$dest/releases/$SHA1";;
  (*)        archivedir="$dest/archives/$SHA1";;
esac
export archivedir
mkdir -p "$archivedir"

# This part should create in the temporary directory a single
# directory that will be archived and distributed. If the project
# provides its own script, let it package.
delegate="$build/scripts/package"

build_type="${ARCH}-${OS}-${COMP}"
test "$MODE" != "release" && build_type="${build_type}-${MODE}"
unqualified_dir="${PROJECT}-${build_type}"
qualified_dir="${PROJECT}-${SHA1}-${build_type}"

if test -x "$delegate"; then
  "$delegate" "$PROJECT" "$source" "$build" "$install/" \
              "." "$ARCH" "$OS" "$COMP" "$MODE" "$prefix"
  pwd
  ls -la
  qualified_dir=$(ls)
  test -n "$qualified_dir" ||
    fatal "The project's package script didn't create anything"
else
  rm -rf "$qualified_dir"
  cp -r "$install" "$qualified_dir"
fi

# Iterate over packaged content.
for dir in $qualified_dir
do
  # $pack: the package (tarball/zip) to publish.
  # If this is a directory, make it a tarball.
  if test -d "$dir"; then
    make_tarball "$dir"
    pack=$make_tarball_res
  else
    pack=$dir
  fi

  # Compute the md5sum of the file.
  $MD5SUM "$pack" >"$pack.md5"

  # Publish the archive and its md5sum.
  move_into "$archivedir" "$pack" "$pack.md5"

  # Make sure we managed to publish properly.
  check_md5 $archivedir $pack

  # This looks useless, but it's an attempt to eliminate
  # nondeterministic problems of availability of shared directories
  # on OS X.
  ls "$dest" >/dev/null

  delegate="$source/scripts/make-installer"
  if test -x "$delegate"; then
    sleep 10
    # This is the expected output from this delegate.
    exe=${dir%-$MODE}.exe
    "$delegate" "$ARCH" "$OS" "$COMP" "$MODE" \
                "$source" "$build" "$install" "$archivedir/$dir"
    # The delegate might not create the installer, if it was run
    # before its peer.
    if test -f "$archivedir/$exe"; then
      check_md5 "$archivedir" "$exe"
    fi
  fi
done
